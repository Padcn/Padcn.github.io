<?xml version="1.0" encoding="utf-8"?>
<search>
  
    <entry>
      <title><![CDATA[JDK1.8中的 ConcurrentHashMap]]></title>
      <url>/2018/08/24/ConcurrentHashMapSourceCodeV1_8/</url>
      <content type="text"><![CDATA[JDK1.8中的 ConcurrentHashmap在1.8中的ConcurrentHashMap与1.7中的数据结构有些不同，没有了外面的第一层Segement，相对来说结构与1.8的HashMap比较像。只是多了一些并发的代码。构造函数无参构造什么都不做，public ConcurrentHashMap(int initialCapacity) {    if (initialCapacity &lt; 0)        throw new IllegalArgumentException();    // 根据给定容量参数计算实际容量，计算结果为tableSizeFor(1.5*initialCapacity+1)    int cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; 1)) ?               MAXIMUM_CAPACITY :               tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; 1) + 1));    this.sizeCtl = cap;}/** * 不小于入参的最小2的幂次方 比如10 则结果为16 * Returns a power of two table size for the given desired capacity. * See Hackers Delight, sec 3.2 */private static final int tableSizeFor(int c) {    int n = c - 1;    n |= n &gt;&gt;&gt; 1;    n |= n &gt;&gt;&gt; 2;    n |= n &gt;&gt;&gt; 4;    n |= n &gt;&gt;&gt; 8;    n |= n &gt;&gt;&gt; 16;    return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;}put方法public V put(K key, V value) {    return putVal(hash(key), key, value, false, true);}final V putVal(K key, V value, boolean onlyIfAbsent) {	// 不允许空key或者value    if (key == null || value == null) throw new NullPointerException();    int hash = spread(key.hashCode());    int binCount = 0;    // 循环遍历数组table，这里跳出循环有两种情况，    for (Node&lt;K,V&gt;[] tab = table;;) {        Node&lt;K,V&gt; f; int n, i, fh; K fk; V fv;        if (tab == null || (n = tab.length) == 0) {        	// table未初始化时，进行初始化。            tab = initTable();        } else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) {        	// 在计算的坐标位置如果是空，则直接使用cas方式插入新节点，然后结束循环            if (casTabAt(tab, i, null, new Node&lt;K,V&gt;(hash, key, value)))                break;                   // no lock when adding to empty bin        }        else if ((fh = f.hash) == MOVED) {        	// 迁移数据            tab = helpTransfer(tab, f);        } else if (onlyIfAbsent // check first node without acquiring lock                 &amp;&amp; fh == hash                 &amp;&amp; ((fk = f.key) == key || (fk != null &amp;&amp; key.equals(fk)))                 &amp;&amp; (fv = f.val) != null) {            // 第一个节点就是对应的节点，替换旧值，返回旧值            return fv;        } else {            V oldVal = null;            // 获取该节点的锁。            synchronized (f) {                if (tabAt(tab, i) == f) {                    if (fh &gt;= 0) {                        binCount = 1;                        // 遍历该节点                        for (Node&lt;K,V&gt; e = f;; ++binCount) {                            K ek;                            // 找到旧值所在节点，替换并终端循环遍历节点                            if (e.hash == hash &amp;&amp;                                ((ek = e.key) == key ||                                 (ek != null &amp;&amp; key.equals(ek)))) {                                oldVal = e.val;                                if (!onlyIfAbsent)                                    e.val = value;                                break;                            }                            Node&lt;K,V&gt; pred = e;                            if ((e = e.next) == null) {                                pred.next = new Node&lt;K,V&gt;(hash, key, value);                                break;                            }                        }                    }                    else if (f instanceof TreeBin) {                    	// 如果是红黑树节点，用红黑树节点的putVal方法                        Node&lt;K,V&gt; p;                        binCount = 2;                        if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,                                                       value)) != null) {                            oldVal = p.val;                            if (!onlyIfAbsent)                                p.val = value;                        }                    }                    else if (f instanceof ReservationNode)                    	// 保留节点一般是预留的节点,一般不会出现这种情况。                        throw new IllegalStateException("Recursive update");                }            }            if (binCount != 0) {            	// 判断是否需要扩容,这里可能转换为红黑树                if (binCount &gt;= TREEIFY_THRESHOLD)                    treeifyBin(tab, i);                if (oldVal != null)                    return oldVal;                break;            }        }    }    addCount(1L, binCount);    return null;}在put时发现该table还没有初始化则初始化/** * 这里使用sizeCtl也就是构造函数时计算的值进行初始化。 * Initializes table, using the size recorded in sizeCtl. */private final Node&lt;K,V&gt;[] initTable() {    Node&lt;K,V&gt;[] tab; int sc;    while ((tab = table) == null || tab.length == 0) {        if ((sc = sizeCtl) &lt; 0) {            Thread.yield(); // lost initialization race; just spin        } else if (U.compareAndSetInt(this, SIZECTL, sc, -1)) {            // cas设置sizeCtl,成功返回-1，对table进行初始化            try {                if ((tab = table) == null || tab.length == 0) {                    int n = (sc &gt; 0) ? sc : DEFAULT_CAPACITY;                    @SuppressWarnings("unchecked")                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n];                    table = tab = nt;                    sc = n - (n &gt;&gt;&gt; 2);                }            } finally {                sizeCtl = sc;            }            break;        }    }    return tab;}扩容扩容发生在put阶段，将新put的节点加入后，去判断是否需要扩容，如果大于值则会将链表转换为红黑树/** * The smallest table capacity for which bins may be treeified. * (Otherwise the table is resized if too many nodes in a bin.) * The value should be at least 4 * TREEIFY_THRESHOLD to avoid * conflicts between resizing and treeification thresholds. */static final int MIN_TREEIFY_CAPACITY = 64; /** * Replaces all linked nodes in bin at given index unless table is * too small, in which case resizes instead. */private final void treeifyBin(Node&lt;K,V&gt;[] tab, int index) {    Node&lt;K,V&gt; b; int n;    if (tab != null) {        if ((n = tab.length) &lt; MIN_TREEIFY_CAPACITY){            // 小于最小的转换为树的值，则只是扩容，2倍            tryPresize(n &lt;&lt; 1);        } else if ((b = tabAt(tab, index)) != null &amp;&amp; b.hash &gt;= 0) {            synchronized (b) {                if (tabAt(tab, index) == b) {                    TreeNode&lt;K,V&gt; hd = null, tl = null;                    // 遍历原来的链表，生成一棵红黑树。                    for (Node&lt;K,V&gt; e = b; e != null; e = e.next) {                        TreeNode&lt;K,V&gt; p =                            new TreeNode&lt;K,V&gt;(e.hash, e.key, e.val,                                              null, null);                        if ((p.prev = tl) == null)                            hd = p;                        else                            tl.next = p;                        tl = p;                    }                    // 将生成的红黑树放入原链表位置                    setTabAt(tab, index, new TreeBin&lt;K,V&gt;(hd));                }            }        }    }} /** * 重新调整容量 * Tries to presize table to accommodate the given number of elements. * * @param size number of elements (doesn't need to be perfectly accurate) */private final void tryPresize(int size) {	// 计算最终扩容的目标容量    int c = (size &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; 1)) ? MAXIMUM_CAPACITY :        tableSizeFor(size + (size &gt;&gt;&gt; 1) + 1);    int sc;    while ((sc = sizeCtl) &gt;= 0) {        Node&lt;K,V&gt;[] tab = table; int n;        if (tab == null || (n = tab.length) == 0) {            n = (sc &gt; c) ? sc : c;            // CAS设置SIZECTL为-1,时表示抢到锁，初始化新table替换旧table            if (U.compareAndSetInt(this, SIZECTL, sc, -1)) {                try {                    if (table == tab) {                        @SuppressWarnings("unchecked")                        Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n];                        table = nt;                        sc = n - (n &gt;&gt;&gt; 2);                    }                } finally {                    sizeCtl = sc;                }            }        }        else if (c &lt;= sc || n &gt;= MAXIMUM_CAPACITY) {            // 扩容目标值比目前值小或已经到最大了则直接中断循环            break;        } else if (tab == table) {            int rs = resizeStamp(n);            // 将旧的数据转移到新的table中            if (U.compareAndSetInt(this, SIZECTL, sc,                                    (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2))                transfer(tab, null);        }    }}transfer方法 转移旧table的节点到新的table中/** * Moves and/or copies the nodes in each bin to new table. See * above for explanation. */private final void transfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab) {    int n = tab.length, stride;    // 根据CPU数量决定stride的值，多核为n&gt;&gt;&gt;3/NCPU，单核为n，最小值为16    // stride为每个核分到的需要迁移的任务。    if ((stride = (NCPU &gt; 1) ? (n &gt;&gt;&gt; 3) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)        stride = MIN_TRANSFER_STRIDE; // subdivide range    // 如果迁移目标为空，则初始化    if (nextTab == null) {            // initiating        try {            @SuppressWarnings("unchecked")            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n &lt;&lt; 1];            nextTab = nt;        } catch (Throwable ex) {      // try to cope with OOME            sizeCtl = Integer.MAX_VALUE;            return;        }        nextTable = nextTab;        transferIndex = n;    }    int nextn = nextTab.length;    ForwardingNode&lt;K,V&gt; fwd = new ForwardingNode&lt;K,V&gt;(nextTab);    boolean advance = true;    boolean finishing = false; // to ensure sweep before committing nextTab    for (int i = 0, bound = 0;;) {        Node&lt;K,V&gt; f; int fh;        // 这里主要是为了循环遍历原数组        while (advance) {            int nextIndex, nextBound;            if (--i &gt;= bound || finishing)                advance = false;            else if ((nextIndex = transferIndex) &lt;= 0) {                i = -1;                advance = false;            }            else if (U.compareAndSetInt                     (this, TRANSFERINDEX, nextIndex,                      nextBound = (nextIndex &gt; stride ?                                   nextIndex - stride : 0))) {                bound = nextBound;                i = nextIndex - 1;                advance = false;            }        }        if (i &lt; 0 || i &gt;= n || i + n &gt;= nextn) {            int sc;            if (finishing) {                nextTable = null;                table = nextTab;                sizeCtl = (n &lt;&lt; 1) - (n &gt;&gt;&gt; 1);                return;            }            if (U.compareAndSetInt(this, SIZECTL, sc = sizeCtl, sc - 1)) {                if ((sc - 2) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)                    return;                finishing = advance = true;                i = n; // recheck before commit            }        }        else if ((f = tabAt(tab, i)) == null) {            // 放入fwd表示该位置已经被处理了            advance = casTabAt(tab, i, null, fwd);        } else if ((fh = f.hash) == MOVED)            advance = true; // already processed        else {            synchronized (f) {                if (tabAt(tab, i) == f) {                    Node&lt;K,V&gt; ln, hn;                    if (fh &gt;= 0) {                        int runBit = fh &amp; n;                        Node&lt;K,V&gt; lastRun = f;                        for (Node&lt;K,V&gt; p = f.next; p != null; p = p.next) {                            int b = p.hash &amp; n;                            if (b != runBit) {                                runBit = b;                                lastRun = p;                            }                        }                        if (runBit == 0) {                            ln = lastRun;                            hn = null;                        }                        else {                            hn = lastRun;                            ln = null;                        }                        // 拆分原链表                        for (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) {                            int ph = p.hash; K pk = p.key; V pv = p.val;                            if ((ph &amp; n) == 0)                                ln = new Node&lt;K,V&gt;(ph, pk, pv, ln);                            else                                hn = new Node&lt;K,V&gt;(ph, pk, pv, hn);                        }                        // 放入数组新位置                        setTabAt(nextTab, i, ln);                        setTabAt(nextTab, i + n, hn);                        setTabAt(tab, i, fwd);                        advance = true;                    }                    else if (f instanceof TreeBin) {                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;                        TreeNode&lt;K,V&gt; lo = null, loTail = null;                        TreeNode&lt;K,V&gt; hi = null, hiTail = null;                        int lc = 0, hc = 0;                        // 拆分红黑树                        for (Node&lt;K,V&gt; e = t.first; e != null; e = e.next) {                            int h = e.hash;                            TreeNode&lt;K,V&gt; p = new TreeNode&lt;K,V&gt;                                (h, e.key, e.val, null, null);                            if ((h &amp; n) == 0) {                                if ((p.prev = loTail) == null)                                    lo = p;                                else                                    loTail.next = p;                                loTail = p;                                ++lc;                            }                            else {                                if ((p.prev = hiTail) == null)                                    hi = p;                                else                                    hiTail.next = p;                                hiTail = p;                                ++hc;                            }                        }                        // 如果拆分出来小于转化为红黑数的阈值则转换为普通链表                        ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :                            (hc != 0) ? new TreeBin&lt;K,V&gt;(lo) : t;                        hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :                            (lc != 0) ? new TreeBin&lt;K,V&gt;(hi) : t;                        setTabAt(nextTab, i, ln);                        setTabAt(nextTab, i + n, hn);                        setTabAt(tab, i, fwd);                        advance = true;                    }                }            }        }    }]]></content>
      <categories>
        
      </categories>
      <tags>
        
          <tag> JDK源码 </tag>
        
          <tag> java </tag>
        
          <tag> 集合 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[JDK1.7中的 ConcurrentHashMap]]></title>
      <url>/2018/08/24/ConcurrentHashMapSourceCodeV1_7/</url>
      <content type="text"><![CDATA[JDK1.7中的ConcurrentHashMapConcurrentHashMap是HashMap的考虑并发的版本，他支持并发的操作。ConcurrentHashMap的结构是最外层是一个Segment数组，每个Segment中保存着之前我们熟悉的HashMap中的链表数组table，table数组中存放的是Entry链表。Segment对象通过继承ReentrantLock来实现加锁操作。每次的加锁操作就是锁住整个Segment，保证每个Segment的线程安全就保证了全局的线程安全。Segment初始化之后不能再扩容，而内部的table是可以扩容的，Segement的数量即为并发数，默认为16。构造时初始化方法初始化主要是对于ConcurrentHashMap的第一个Segment进行初始化，计算和设定一些初始值。大致流程为：  判断传入参数（初始容量，loadFactor,concurrentLevel）是否在合理范围内，超出则设置为容许的最大值。  计算并行级别(Segment的数量)循环左移1位，直到不小于初始化给的参数值，初始为1，这期间顺便记录下左移的位数用以计算segementShift。  计算segmentShift和segmentMask，segmentShift=32-并行级别左移位数，segmentMask=并行级别-1。 这两个值后续操作有用。  从最小容量循环左移1位直到满足不小于整体容量除以segment数量。计算每个Segement中的容量大小。  用上述步骤计算出的每个容量初始化第一个Segement，并初始化Segment数组，将第一个Segment放入数组。public ConcurrentHashMap(int initialCapacity, float loadFactor, int concurrencyLevel) {    // 判断传入参数是否合法    if (!(loadFactor &gt; 0) || initialCapacity &lt; 0 || concurrencyLevel &lt;= 0)        throw new IllegalArgumentException();    if (concurrencyLevel &gt; MAX_SEGMENTS)        concurrencyLevel = MAX_SEGMENTS;    // 计算出2的幂次方不小于传入参数的容量(capacity)和并行级别（concurrencyLevel）    int sshift = 0;    int ssize = 1;    // 计算并行级别 ssize    while (ssize &lt; concurrencyLevel) {        ++sshift;        ssize &lt;&lt;= 1;    }    // 计算segmentShift和segementMask, 这两个值是后续要用计算Segment的下标。    this.segmentShift = 32 - sshift;    this.segmentMask = ssize - 1; 	    if (initialCapacity &gt; MAXIMUM_CAPACITY)        initialCapacity = MAXIMUM_CAPACITY;    // 计算每个Segment中的Map的容量，保持2的幂次方并不小于给定初始化值    int c = initialCapacity / ssize;    if (c * ssize &lt; initialCapacity)        ++c;    // 默认 MIN_SEGMENT_TABLE_CAPACITY 是 2    int cap = MIN_SEGMENT_TABLE_CAPACITY;     while (cap &lt; c)        cap &lt;&lt;= 1;    // 创建 Segment 数组，并创建数组的第一个元素 segment[0]    Segment&lt;K,V&gt; s0 =        new Segment&lt;K,V&gt;(loadFactor, (int)(cap * loadFactor),                         (HashEntry&lt;K,V&gt;[])new HashEntry[cap]);    Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])new Segment[ssize];    // 将初始化后的第一个Segment放入创建的数组中    UNSAFE.putOrderedObject(ss, SBASE, s0);     this.segments = ss;}初始化完后除了Segement[0]不为null其他位置都还是null。调用默认构造函数后初始Segement数组长度为16。segementShift=32-4=8,segmentMask=16-1=15,初始每个Segment中map容量为2,阈值为2×0.75,所以put第二个值时会进行扩容操作。put方法put方法的大致步骤如下:  先根据key和初始化时计算出的segmentShift和segmentMask来计算出需要put的Segment在Segment数组中的下标，并获取。  获取到Segment对象后，获取Segment的独占锁，之后的操作基本和HashMap差不多了。  根据key的hash值，获取HashEntry链表，然后遍历判断就行了。  最后解锁，如果有旧值则返回旧值。public V put(K key, V value) {    Segment&lt;K,V&gt; s;    if (value == null)        throw new NullPointerException();    /** 计算 key 的 hash 值，以初始化时计算的segmentShift和segmentMask进行计算Segement所在数组的下标。     * 根据计算方式：     * segmentShift=32-sgement数组长度2的几次方,所以hash右移，获得hash开头几位。     * segmentMask=segement数组长度-1。     * 最终计算得的j就是所需segement在数组中的下标     */    int hash = hash(key);    int j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;    // 如果该位置还是null，则调用ensureSegment(index)方法对该segment进行初始化。    if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject         (segments, (j &lt;&lt; SSHIFT) + SBASE)) == null)        s = ensureSegment(j);    // 获取到需要操作的segment后，就可以进行put操作了    return s.put(key, hash, value, false);}final V put(K key, int hash, V value, boolean onlyIfAbsent) {    // 先获取segment的独占锁，获取锁后，接下来流程基本和HashMap中一样。    HashEntry&lt;K,V&gt; node = tryLock() ? null :        scanAndLockForPut(key, hash, value);    V oldValue;    try {    	// 根据key的table的length计算出需操作的Entry链表的表头索引位置。        HashEntry&lt;K,V&gt;[] tab = table;        int index = (tab.length - 1) &amp; hash;        HashEntry&lt;K,V&gt; first = entryAt(tab, index); 		// 根据获取的链表表头，遍历链表判断操作        for (HashEntry&lt;K,V&gt; e = first;;) {            if (e != null) {                K k;                // 在已经有旧值的情况下替换旧值，结束遍历                if ((k = e.key) == key || (e.hash == hash &amp;&amp; key.equals(k))) {                    oldValue = e.value;                    if (!onlyIfAbsent) {                        e.value = value;                        ++modCount;                    }                    break;                }                e = e.next;            } else {                // 如果获取到的entry的表头为空情况下，如果在获取独占锁操作时获取的node不为空，                //则直接将改节点的node设置为该位置表头。否则直接初始化一个节点。                if (node != null)                    node.setNext(first);                else                    node = new HashEntry&lt;K,V&gt;(hash, key, value, first);                int c = count + 1;                // 这里判断是否超过了阈值，超过则扩容，否则将操作完的链表放入原位置。                if (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)                    rehash(node);                else                    setEntryAt(tab, index, node);                ++modCount;                count = c;                oldValue = null;                break;            }        }    } finally {        // 解锁        unlock();    }    return oldValue;}在put方法中如果获取的segement没有初始化，则需要先初始化，也就是上面put方法中的ensureSegment方法。初始化Segement主要是要判断是否已经被其他线程初始化了，这里使用的是CAS来解决这个问题。private Segment&lt;K,V&gt; ensureSegment(int k) {    final Segment&lt;K,V&gt;[] ss = this.segments;    long u = (k &lt;&lt; SSHIFT) + SBASE; // raw offset    Segment&lt;K,V&gt; seg;    if ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) == null) {        // 根据第一个已经初始化后的segment的的loadFacotry和table的length进行初始化。        Segment&lt;K,V&gt; proto = ss[0];        int cap = proto.table.length;        float lf = proto.loadFactor;        int threshold = (int)(cap * lf);        // 初始化新segment中的table        HashEntry&lt;K,V&gt;[] tab = (HashEntry&lt;K,V&gt;[])new HashEntry[cap];        // 再判断一次该位置segment有没有被其他线程初始化，没有则new一个。        if ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) == null) {            Segment&lt;K,V&gt; s = new Segment&lt;K,V&gt;(lf, threshold, tab);            // 这里使用CAS来将新的Segment来放入Segment数组。            while ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) == null) {                if (UNSAFE.compareAndSwapObject(ss, u, null, seg = s))                    break;            }        }    }    return seg;}获取写入锁方法scanAndLockForPut获取写入锁是在putVal方法的开始,这里已经获取到了对于的Segment了。这个方法主要是为了获得segment的独占锁，附带如果获取锁失败时还查找了一遍key对应的节点。private HashEntry&lt;K,V&gt; scanAndLockForPut(K key, int hash, V value) {    // 获取key对应的entry链表    HashEntry&lt;K,V&gt; first = entryForHash(this, hash);    HashEntry&lt;K,V&gt; e = first;    HashEntry&lt;K,V&gt; node = null;    // retries初始化为负数，表示正在查找key值对应节点。    int retries = -1; 	// 循环获取锁，在获取锁失败时先对链表进行查找。    while (!tryLock()) {        HashEntry&lt;K,V&gt; f;        if (retries &lt; 0) {    		// 当retries值为负数时,表示正在查找key值对应节点。            if (e == null) {                if (node == null)                	// 到这里表示该位置链表为空，没有元素，创建节点。另一个原因是该槽存在并发，不一定是该位置。                    node = new HashEntry&lt;K,V&gt;(hash, key, value, null);                retries = 0;            } else if (key.equals(e.key)){            	// 如果找了对于节点，则查找结束，retries标记为0                retries = 0;            } else {                e = e.next;            }        } else if (++retries &gt; MAX_SCAN_RETRIES) {        	// 当重试次数超出了规定的最大值时，进入阻塞队列等待锁，lock方法获取锁后返回。            lock();            break;        } else if ((retries &amp; 1) == 0 &amp;&amp; (f = entryForHash(this, hash)) != first) {        	// 如果retries为0了，但是再次获取对于entry数组位置的表头已经和进入方法时不一致了，            // 说明已经有新元素进入链表了，所以需要再重走一遍这个方法的流程。            e = first = f; // re-traverse if entry changed            retries = -1;        }    }    return node;}扩容方法rehash扩容是在put方法最后收尾阶段，如果判断加入新节点后长度大于阈值后发生。private void rehash(HashEntry&lt;K,V&gt; node) {	// 这个参数node即是本次put的新节点    HashEntry&lt;K,V&gt;[] oldTable = table;    int oldCapacity = oldTable.length;    // 扩容大小为原先的两倍    int newCapacity = oldCapacity &lt;&lt; 1;    threshold = (int)(newCapacity * loadFactor);    HashEntry&lt;K,V&gt;[] newTable = (HashEntry&lt;K,V&gt;[]) new HashEntry[newCapacity];    int sizeMask = newCapacity - 1;     // 遍历原数组，将原先的链表拆分成两个链表，之间下标相差oldCap的值。比如i和i+oldCap,i为原位置    for (int i = 0; i &lt; oldCapacity ; i++) {        // e 是链表的第一个元素        HashEntry&lt;K,V&gt; e = oldTable[i];        if (e != null) {            HashEntry&lt;K,V&gt; next = e.next;            // 计算应该放置在新数组中的位置            int idx = e.hash &amp; sizeMask;            if (next == null) {                // 如果原链表只有一个元素，则直接放进新的table中                newTable[idx] = e;            } else {                HashEntry&lt;K,V&gt; lastRun = e;                int lastIdx = idx;                 // 循环该链表节点，找到需要拆分的链表节点。                for (HashEntry&lt;K,V&gt; last = next;                     last != null;                     last = last.next) {                    int k = last.hash &amp; sizeMask;                    if (k != lastIdx) {                        lastIdx = k;                        lastRun = last;                    }                }                // 将这个节点放入新的table数组的新位置。                newTable[lastIdx] = lastRun;                // 将这个节点之前的节点都放到数组上对应的另一个位置。完成拆分链表。                for (HashEntry&lt;K,V&gt; p = e; p != lastRun; p = p.next) {                    V v = p.value;                    int h = p.hash;                    int k = h &amp; sizeMask;                    HashEntry&lt;K,V&gt; n = newTable[k];                    newTable[k] = new HashEntry&lt;K,V&gt;(h, p.key, v, n);                }            }        }    }    // 将新节点放到新数组中    int nodeIndex = node.hash &amp; sizeMask;    node.setNext(newTable[nodeIndex]);    newTable[nodeIndex] = node;    table = newTable;}get方法get方法比较简单。  计算出segment的位置，获取segment。  计算出entry在segment中的位置，并获取链表。  遍历链表查询。    public V get(Object key) { Segment&lt;K,V&gt; s;  HashEntry&lt;K,V&gt;[] tab; int h = hash(key); long u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE; // 计算segment下标，并获取 if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != null &amp;&amp;     (tab = s.table) != null) {     // 找到entry链表位置，遍历链表查询。     for (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile              (tab, ((long)(((tab.length - 1) &amp; h)) &lt;&lt; TSHIFT) + TBASE);          e != null; e = e.next) {         K k;         if ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k)))             return e.value;     } } return null;}      ]]></content>
      <categories>
        
      </categories>
      <tags>
        
          <tag> JDK源码 </tag>
        
          <tag> java </tag>
        
          <tag> 集合 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[JDK1.8中的 HashMap]]></title>
      <url>/2018/08/22/HashMapSourceCodeV1_8/</url>
      <content type="text"><![CDATA[Jdk1.8中的HashMaphashMap在jdk1.8中有一次比较大的更新，相对之前的数据结构来讲引入了红黑树来提高查询效率。在1.8之前的get方法，获取entry的下标索引很快，但是查找到entry之后，是需要遍历链表entry来查找对于的key，之后返回需要的值。这样查找时间复杂度取决与链表的长度。所以在1.8中优化成当链表长度大于8之后，会将链表转换为红黑树，这样可以降低时间复杂度。存储数据的单元也改名字改为了Node，而红黑树的节点是TreeNode。TreeNode继承自LinkedHashMap的Entry，而Entry继承自HashMap的Node对象。put方法其实逻辑和jdk1.7差不多。  判断table是否已经初始化了，如果没有则进行初始化。  将(length-1)&amp;hash来计算数组下标，获取具体的Node。  如果Node为空则直接初始化一个链表，存入值。  如果获取的Node不为空，则先看该节点地一个值是否就是匹配key的值，如果不是则判断是Node是红黑树的对象，还是正常链表的对象。  如果是红黑书的对象，则调用红黑数的putTreeVal方法进行存值。  如果是普通链表的对象则遍历，判断是新增的key还是已经存在，如果有旧值则覆盖，返回旧值，如果是新值则增加到链表的表尾，如果大于8,即此次加入的是第9个节点则转换为红黑树。  最后modCount++后判断size是否超过了阈值，是否要进行扩容。final V putVal(int hash, K key, V value, boolean onlyIfAbsent,                   boolean evict) {    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;	// 判断是否需要初始化    if ((tab = table) == null || (n = tab.length) == 0)        n = (tab = resize()).length;	// 判断table数组对于位置是否有Node，无则直接插入新节点，否则再判断    if ((p = tab[i = (n - 1) &amp; hash]) == null)        tab[i] = newNode(hash, key, value, null);    else {        Node&lt;K,V&gt; e; K k;        if (p.hash == hash &amp;&amp;            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))            e = p;        else if (p instanceof TreeNode)    	// 判断是否是红黑树的节点对象，是则调用红黑树的putTreeVal            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);        else {    		// 普通链表则遍历链表查找判断            for (int binCount = 0; ; ++binCount) {        		// 最多遍历到末尾为止，如果还没有则将新节点放到表尾                if ((e = p.next) == null) {                    p.next = newNode(hash, key, value, null);        			// 这里如果插入后链表长度大于8了则转换为红黑树                    if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st                        treeifyBin(tab, hash);                    break;                }        		// 这里判断是否已经有旧值，如果有则中断便利，这样var10就是遍历到的节点                if (e.hash == hash &amp;&amp;                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))                    break;                p = e;            }        }    	// 如果var10不为空则说明有旧值，则进行替换旧值，返回旧值        if (e != null) { // existing mapping for key            V oldValue = e.value;            if (!onlyIfAbsent || oldValue == null)                e.value = value;            afterNodeAccess(e);            return oldValue;        }    }	// 判断是否需要进行扩容操作    ++modCount;    if (++size &gt; threshold)        resize();    afterNodeInsertion(evict);    return null;}resize 扩容方法大致步骤：  根据是否已经初始化进行判断，如果已经扩容过，则判断是否还可以扩容。再操作。  根据初始化Map的构造函数来初始化容量和阈值。  创建新的table，如果是初始化扩容，则直接返回新table，如果是已经有值的扩容，则根据节点类型进行迁移。    /** * Initializes or doubles table size.  If null, allocates in * accord with initial capacity target held in field threshold. * Otherwise, because we are using power-of-two expansion, the * elements from each bin must either stay at same index, or move * with a power of two offset in the new table. * * @return the table */final Node&lt;K,V&gt;[] resize() { Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap &gt; 0) { 	// 如果到到最大容量则不在扩容了，如果容量在允许范围内，则扩容两倍     if (oldCap &gt;= MAXIMUM_CAPACITY) {         threshold = Integer.MAX_VALUE;         return oldTab;     } else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;              oldCap &gt;= DEFAULT_INITIAL_CAPACITY){         // if中扩大数组大小，这里扩大阈值         newThr = oldThr &lt;&lt; 1; // double threshold     } } else if (oldThr &gt; 0) { 	// 这里的情况是在第一次给了初始化容量时第一次调用put时     newCap = oldThr; }else {                	// 这个情况在于调用默认构造函数时的逻辑，使用默认容量大小进行初始化     newCap = DEFAULT_INITIAL_CAPACITY;     newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); } // 如果到这阈值还是0,则用容量和loadFactor进行计算。 if (newThr == 0) {     float ft = (float)newCap * loadFactor;     newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?               (int)ft : Integer.MAX_VALUE); } threshold = newThr; // 初始化新的table @SuppressWarnings({"rawtypes","unchecked"}) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; // 在旧table有值情况下迁移数据，否则直接返回新的table if (oldTab != null) {     for (int j = 0; j &lt; oldCap; ++j) {         Node&lt;K,V&gt; e;         if ((e = oldTab[j]) != null) {             oldTab[j] = null;             if (e.next == null){                 // 该位置只有一个节点的情况下直接转移                 newTab[e.hash &amp; (newCap - 1)] = e;             }else if (e instanceof TreeNode)             	// 判断是否是红黑树的节点，如果是调用红黑树的迁移方式                 ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);             else {             	// 将原先的一条链表拆分为两条链表放到新的数组中                 Node&lt;K,V&gt; loHead = null, loTail = null;                 Node&lt;K,V&gt; hiHead = null, hiTail = null;                 Node&lt;K,V&gt; next;                 do {                     next = e.next;                     if ((e.hash &amp; oldCap) == 0) {                         if (loTail == null)                             loHead = e;                         else                             loTail.next = e;                         loTail = e;                     }else {                         if (hiTail == null)                             hiHead = e;                         else                             hiTail.next = e;                         hiTail = e;                     }                 } while ((e = next) != null);                 // 将拆分后的链表存入新table，两个链表索引位置相差oldCap                 if (loTail != null) {                     loTail.next = null;                     newTab[j] = loHead;                 }                 if (hiTail != null) {                     hiTail.next = null;                     newTab[j + oldCap] = hiHead;                 }             }         }     } } return newTab;}      get方法get方法还是比较简单：  根据key值计算hash  根据hash和length-1进行与操作计算出，该节点在table中存放的位置。  获得该位置的节点后对节点进行判断，分红黑树节点和普通链表进行查找。最终返回。    public V get(Object key) { Node&lt;K,V&gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value;}final Node&lt;K,V&gt; getNode(int hash, Object key) { // 这里的hash是上面根据key计算得到的hash Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; // 这里通过(n - 1) &amp; hash 来获取对于节点在table中的下标，first就是获取到的该位置的第一个节点 if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;     (first = tab[(n - 1) &amp; hash]) != null) {     // 先判断看看是不是一个节点就是需要的值，是的话直接返回     if (first.hash == hash &amp;&amp; // always check first node         ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))         return first;     if ((e = first.next) != null) {     	// 判断是否是红黑树节点，是的话通过红黑树的getTreeNode进行查找,返回值         if (first instanceof TreeNode)             return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);         // 如果普通链表则遍历查找，和1.7没什么区别         do {             if (e.hash == hash &amp;&amp;                 ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))                 return e;         } while ((e = e.next) != null);     } } return null;}      ]]></content>
      <categories>
        
      </categories>
      <tags>
        
          <tag> JDK源码 </tag>
        
          <tag> java </tag>
        
          <tag> 集合 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[JDK1.7中的 HashMap]]></title>
      <url>/2018/08/20/HashMapSourceCodeV1_7/</url>
      <content type="text"><![CDATA[JDK1.7中的 HashMap  参考 Java7/8 中的 HashMap 和 ConcurrentHashMap 全解析http://www.importnew.com/28263.html1.7中的hashMap主要是由链表来实现的，在hashMap中实际进行存储的是一个叫table的数组，数组每个元素是Entry对象，每个Entry是一个链表。而数组的下标则是又key值的hash值和table的长度来决定的。put方法1.首先判断是否是插入的第一个元素，如果是第一个元素，首先对存储的数组进行初始化，容量为2的n次方。2.判断key是否为null，如果为null则将这个entry放在table[0]位置。3.对key计算hash值，调用indexFor方法计算出key对应的table数组下标。4.根据计算出的下标，获取Entry，进行遍历，查找是否已经存在key，如果存在替换旧值，返回旧值，如果不存在将此数据加入该链表中。pulic V put(K key,V value){	if(table == EMPTY_TABLE){    	// 如果map还没有初始化则进行初始化    	inflateTable(threhold);    }    if(key == null){    	// key值为空时处理，最终将数据放入table[0]    	return putForNullKey(value);    }    // 计算hash以获取entry的下标。    int hash=hash(key);    int i=indexFor(hash,table.length);    for(Entry&lt;K,V&gt; e=table[i] ; e != null ; e=e.next()){    	// 判断是否有旧值需要替换，如果有就替换后返回旧值        if(e.hash == hash &amp;&amp; ((k=e.key)== key || key.equals(k))){        	V oldValue=e.value;            e.value=value;            e.recordAccess(this);            return oldValue;        }    }    modCount++;    // 走到这就是新的值了，加入获取到entry的链表节点中    addEntry(hash,key,value,i);}inflateTable方法是map的初始化方法，当map初始化时调用private void inflateTable(int toSize){	//这里容量为了保证是2的n次方	int capacity=roundUpToPowerOf2(toSize);	//计算扩容的阈值，等于 capacity * loadFactor	threshold=(int)Math.min(capicity*loaderFactory,MAXIMUM_CAPACITY+1);    table=new Entry[capicity];    initHashSeedAsNeeded(capacity);}这里为什么要保证容量是2的n次方？因为indexFor方法是 key的hash值与容量减一进行与操作，即(hash&amp;(table.length-1))。如果非2的n次方，可能length-1就是的二进制最后一位为0,那么与任何值进行与操作后最后一位都为0,也就是最终得到的值为偶数，所以put的时候只会将entry存放进偶数的下标内，奇数下标的位置永远不会被存入值，等于浪费了另一半的容量。而如果是2的n次方就可以保证length-1为奇数，也就是最终得到的下标为奇数和偶数。就会相对均匀分布一些。扩容：  超出容量会扩容，而HashMap的扩容比较消耗性能，默认容量为16,一般建议值为数量*loadFactor+1扩容发生在put方法时，上面的put方法最后一步中，addEntry方法中首先就是判断是否已经达到阈值，并且新插入的数组位置有值则需要进行扩容了。void addEntry(int hash,K key,V value,int bucketIndex){	if(size&gt;=threhold &amp;&amp; null != table[buketIndex]){    	// 扩容方法        resize(2*table.length);        hash=(null != key) ? hash(key) : 0;        // 重新计算下标        buketIndex=indexFor(hash,table.length);    }    // 链表中加入新值    createEntry(hash,key,value,buketIndex);}// 将新值放在链表的表头void createEntry(int hash,K key,V value,int buketIndex){	Entry&lt;K,V&gt; e=table[buketIndex];    table[buketIndex]=new Entry&lt;&gt;(hash,key,value,e);    size++;}接下来是具体的扩容方法void resize(int newCapacity){	Entry[] oldTable=table;    int oldCapacity=oldTable.length;    if(oldCapacity == MAXIMUM_CAPACITY){    	threhold=Integer.MAX_VALUE;        return;    }    Entry[] newTable=new Entry[newCapacity];    //讲旧数组中的值转移到新数组。    transfer(newTable,initHashSeedAsNeeded(newCapacity));    table=newTable;    threhold=(int)Math.min(newCapacity * loadFactory,MAXIMUM_CAPACITY +1);}由于是双倍扩容，所以原先table[i]中的节点会分拆到newTable[i]和newTable[i+oldLength]位置上。get方法get方法比较简单，流程如下:1.根据key值计算hash值2.根据hash值和length调用indexFor方法计算出table的下标。3.根据下标获得Entry链表后遍历根据key值比较获取value值。public V get(K key){	if(null==key){    	return getForNullKey();    }    Entry&lt;K,V&gt; entry=getEntry(key);    return null == entry ? null : entry.getValue();}final Entry&lt;K,V&gt; getEntry(Object key){	if(size == 0){    	return null;    }    int hash=(key == null)?0:hash(key);    // 根据hash值获取链表后遍历链表，查找对于的值    for(Entry&lt;K,V&gt; e=table[indexFor(hash,table.length)];e!=null;e=e.next){    	Object k;        if((k=e.key) == key || (key != null &amp;&amp; key.equals(e.key))){        	return e;        }    }}]]></content>
      <categories>
        
      </categories>
      <tags>
        
          <tag> JDK源码 </tag>
        
          <tag> java </tag>
        
          <tag> 集合 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Dubbo Start]]></title>
      <url>/2018/07/24/Dubbo-start/</url>
      <content type="text"><![CDATA[Dubbo Start  官网 http://dubbo.apache.org/Dubbo是是一款高性能Java RPC框架。 开始由阿里开源，后来捐献给了apache基金会。Dubbo既然定义就是RPC框架，主要功能也是实现服务的远程调用，remote procedure call即远程服务调用。其中几部分是：服务提供者，服务消费者，注册中心。服务提供者将开放的服务注册到注册中心，服务消费者通过注册中心查询所需要的服务，再根据查询到的信息到服务提供者处调取服务。 图中还多了一个Monitor用来监视调用情况。Dubbo Maven坐标为&lt;dependency&gt;    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;    &lt;artifactId&gt;dubbo&lt;/artifactId&gt;    &lt;version&gt;2.6.2&lt;/version&gt;&lt;/dependency&gt;注册中心可以是zookeeper或者redis。dubbo推荐zookeeper。这里使用zookeeper，Curator框架的使用是为了更方便的操作zookeeper，其中提供了丰富的操作。  Apache Curator is a Java/JVM client library for Apache ZooKeeper, a distributed coordination service. It includes a highlevel API framework and utilities to make using Apache ZooKeeper much easier and more reliable. It also includes recipes for common use cases and extensions such as service discovery and a Java 8 asynchronous DSL.&lt;dependency&gt;    &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt;    &lt;artifactId&gt;zookeeper&lt;/artifactId&gt;    &lt;version&gt;3.4.11&lt;/version&gt;    &lt;type&gt;pom&lt;/type&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;com.101tec&lt;/groupId&gt;    &lt;artifactId&gt;zkclient&lt;/artifactId&gt;    &lt;version&gt;0.10&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;    &lt;artifactId&gt;curator-framework&lt;/artifactId&gt;    &lt;version&gt;2.8.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;    &lt;artifactId&gt;curator-recipes&lt;/artifactId&gt;    &lt;version&gt;2.8.0&lt;/version&gt;&lt;/dependency&gt;基于XML配置方式这里的项目结构采用maven的多模块结构demo-parent				父模块，打包方式为pom            ​      ——demo-api			api定义模块，实体类的定义，以及服务接口方法定义。                  ​      ——demo-provider		服务提供方，依赖于demo-api，对demo-api中接口方法进行实现，提供服务                  ​      ——demo-consumer		服务消费放，依赖于demo-api, 调用demo-provider提供的服务。      服务方法定义demo-api中进行服务方法的定义，如这里定义一个DemoService@org.padcn.dubbo.demo.service.DemoServicepackage org.padcn.dubbo.demo.service;import java.util.List;public interface DemoService {    List&lt;String&gt; getPermissions(Long id);}对服务方法的实现demo-provider中对demo-api中定义的方法进行实现,并注册到注册中心。@org.padcn.dubbo.demo.service.implpackage org.padcn.dubbo.demo.service.impl;import org.pad.dubbo.demo.service.DemoService;import java.util.ArrayList;import java.util.List;public class DemoServiceImpl implements DemoService {    @Override    public List&lt;String&gt; getPermissions(Long id) {        List&lt;String&gt; list=new ArrayList&lt;&gt;(10);        list.add("demo1");        list.add("demo2");        list.add("demo3");        list.add("demo4");        list.add("demo5");        return list;    }}注册服务到注册中心&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans"       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:dubbo="http://code.alibabatech.com/schema/dubbo"       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd"&gt;	&lt;!--声明本应用一些信息--&gt;    &lt;dubbo:application name="demotest-provider" owner="programer" organization="dubbox"/&gt;	&lt;!--注册中心配置--&gt;    &lt;dubbo:registry address="zookeeper://localhost:2181"/&gt;	&lt;!--开放调用端口--&gt;    &lt;dubbo:protocol name="dubbo" port="20880"/&gt;	&lt;!--spring的bean配置--&gt;    &lt;bean id="demoService" class="org.pad.dubbo.demo.service.impl.DemoServiceImpl"/&gt;    &lt;!--服务注册--&gt;    &lt;dubbo:service interface="org.pad.dubbo.demo.service.DemoService" ref="demoService" protocol="dubbo"/&gt;&lt;/beans&gt;消费者对服务调用demo-consumer 调用服务，这里就直接使用main方法调用了，主要还是配置文件的定义，其他都和普通程序一样使用。package org.padcn.dubbo.consumer;import org.pad.dubbo.demo.service.DemoService;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Consumer {    public static void main(String[] args) {        ClassPathXmlApplicationContext context=new ClassPathXmlApplicationContext("consumer.xml");        context.start();        System.out.println("consumer start");        DemoService demoService=context.getBean(DemoService.class);        System.out.println("consumer");        System.out.println(demoService.getPermissions(1L));    }}配置文件&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans"       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:dubbo="http://code.alibabatech.com/schema/dubbo"       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd"&gt;    &lt;!--声明应用信息--&gt;    &lt;dubbo:application name="demotest-consumer" owner="programer" organization="dubbox"/&gt;    &lt;!--配置注册中心--&gt;    &lt;dubbo:registry address="zookeeper://localhost:2181"/&gt;    &lt;!--声明服务--&gt;    &lt;dubbo:reference id="permissionService" interface="org.pad.dubbo.demo.DemoService"/&gt;&lt;/beans&gt;到此就完成了一个示例demo基于注解方式配置注解方式需要dubbo版本 2.5.7 及以上版本支持 。注解相比xml配置方式更简洁清晰。  官方文档: http://dubbo.apache.org/#!/docs/user/configuration/annotation.md?lang=zh-cn这里使用了SpringBoot+dubbo的形式，项目结构和基于xml没有变化。服务提供方配置beanpackage org.padcn.demo.provider.config;import com.alibaba.dubbo.config.ApplicationConfig;import com.alibaba.dubbo.config.ProtocolConfig;import com.alibaba.dubbo.config.RegistryConfig;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configurationpublic class DubboConfiguration {    @Bean    public ApplicationConfig applicationConfig(){        ApplicationConfig config=new ApplicationConfig();        config.setName("demo-provider");        return config;    }    @Bean    public RegistryConfig registryConfig(){        RegistryConfig config=new RegistryConfig();        config.setAddress("zookeeper://127.0.0.1:2181");        //config.setAddress("redis://127.0.0.1:6379");        config.setClient("curator");        config.setPort(12349);        return config;    }    @Bean    public ProtocolConfig protocolConfig(){        ProtocolConfig protocolConfig=new ProtocolConfig();        protocolConfig.setPort(12345);        return protocolConfig;    }}服务实现package org.padcn.demo.provider.service.impl;import com.alibaba.dubbo.config.annotation.Service;import org.padcn.demo.api.DemoService;// 这里的Service注解不是Spring的注解，是dubbo的服务暴露注解@Service(version = "2.0")public class DemoServiceImpl implements DemoService {    @Override    public String sayHi(String name) {        return "hello?"+name;    }}在springboot启动类上配置注解扫描package org.padcn.demo.provider;import com.alibaba.dubbo.config.spring.context.annotation.DubboComponentScan;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplication@DubboComponentScan(basePackages = "org.padcn.demo.provider.service.impl")public class DemoProviderApplication {	public static void main(String[] args) {		SpringApplication.run(DemoProviderApplication.class, args);	}}服务消费方配置配置类package org.padcn.demo.consumer.config;import com.alibaba.dubbo.config.ApplicationConfig;import com.alibaba.dubbo.config.ConsumerConfig;import com.alibaba.dubbo.config.ProtocolConfig;import com.alibaba.dubbo.config.RegistryConfig;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configurationpublic class DubboConfiguration {    @Bean    public ApplicationConfig applicationConfig(){        ApplicationConfig config=new ApplicationConfig();        config.setName("demo-consumer");        return config;    }    @Bean    public RegistryConfig registryConfig(){        RegistryConfig registryConfig=new RegistryConfig();        registryConfig.setAddress("zookeeper://127.0.0.1:2181");        //registryConfig.setAddress("redis://127.0.0.1:6379");        registryConfig.setClient("curator");        return registryConfig;    }        @Bean    public ConsumerConfig consumerConfig(){        ConsumerConfig consumerConfig=new ConsumerConfig();        consumerConfig.setTimeout(3000);        return consumerConfig;    }}服务调用package org.padcn.demo.consumer;import com.alibaba.dubbo.config.annotation.Reference;import org.padcn.demo.api.DemoService;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class DemoController {	//这里用dubbo的reference替换了注入的注解    // 确定一个服务主要是3个要素： 版本号，以及接口，服务分组。不过这里没有写分组，属性是group    @Reference(version = "2.0",application = "demo-consumer",url="dubbo://localhost:12345")    private DemoService demoService;    @RequestMapping("/test")    public String test(String name){        return demoService.sayHi(name);    }}同样在springboot启动类上配置注解扫描package org.padcn.demo.consumer;import com.alibaba.dubbo.config.spring.context.annotation.DubboComponentScan;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplication@DubboComponentScan(basePackages = "org.padcn.demo.api")public class DemoConsumerApplication {	public static void main(String[] args) {		SpringApplication.run(DemoConsumerApplication.class, args);	}}完事，之后启动zookeeper/redis后启动provider和consumer就可以了。  如果需要更加深入可以看这里 http://ifeve.com/dubbo-learn-book/]]></content>
      <categories>
        
      </categories>
      <tags>
        
          <tag> RPC </tag>
        
          <tag> Dubbo </tag>
        
          <tag> 分布式 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[wildfly部署war包]]></title>
      <url>/2018/04/18/wildfly-deploy/</url>
      <content type="text"><![CDATA[wildfly-12.0.0.Final 部署war包  下面${wildfly_home}代表wildfly解压的目录添加管理用户windows下 运行 ${wildfly_home}/bin/add-user.bat，根据提示添加或者修改用户，这个用户是进入wildfly控制台的用户。部署放置war包到 ${wildfly_home}/standalone/deployments目录下启动windows下${wildfly_home}/bin/standalone.bat启动后可以通过localhost:9990进入服务控制台localhost:8080/项目名 进入部署的系统。控制台在控制台中也可以进行部署端口以及其他一些常见配置在${wildfly_home}/standalone/configuration/standalone.xml中进行配置。]]></content>
      <categories>
        
      </categories>
      <tags>
        
          <tag> 服务器 </tag>
        
          <tag> 部署 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[maven打包jar配置]]></title>
      <url>/2018/03/29/mavenPackage/</url>
      <content type="text"><![CDATA[maven打包成jar，指定主类@pom.xml&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;	&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;	&lt;parent&gt;		&lt;groupId&gt;org.padcn&lt;/groupId&gt;		&lt;artifactId&gt;mall&lt;/artifactId&gt;		&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;	&lt;/parent&gt;	&lt;artifactId&gt;mall-util&lt;/artifactId&gt;	&lt;build&gt;		&lt;pluginManagement&gt;			&lt;plugins&gt;				&lt;plugin&gt;					&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;					&lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt;					&lt;configuration&gt;						&lt;source&gt;1.8&lt;/source&gt;						&lt;target&gt;1.8&lt;/target&gt;						&lt;archive&gt;							&lt;manifest&gt;								&lt;mainClass&gt;org.padcn.utils.TestUtils&lt;/mainClass&gt;								&lt;addClasspath&gt;true&lt;/addClasspath&gt;								&lt;classpathPrefix&gt;lib/&lt;/classpathPrefix&gt;							&lt;/manifest&gt;						&lt;/archive&gt;						&lt;classesDirectory&gt;						&lt;/classesDirectory&gt;					&lt;/configuration&gt;				&lt;/plugin&gt;			&lt;/plugins&gt;		&lt;/pluginManagement&gt;	&lt;/build&gt;&lt;/project&gt;  标签不整齐有可能在打包时出现pom.xml: expected START_TAG or END_TAG not TEXT  所以pom.xml的文本还是需要对齐才行。让jar在后台运行运行：java -jar server.jar &amp;后面加个&amp;就可以 （使用的是linux的nohup命令）  Linux Shell nohup命令用法 https://www.cnblogs.com/gotodsp/p/6390023.html关闭：列出java后台进程ps -ef | grep java查看后用kill -9 加pid，直接关闭kill -9 [pid]]]></content>
      <categories>
        
      </categories>
      <tags>
        
          <tag> maven </tag>
        
          <tag> 构建工具 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[JAXB 进行java对象和xml的转换]]></title>
      <url>/2018/03/29/JAXB-parse-object-to-xml/</url>
      <content type="text"><![CDATA[JAXB 进行java对象和xml的转换  百度百科：JAXB能够使用Jackson对JAXB注解的支持实现(jackson-module-jaxb-annotations)，既方便生成XML，也方便生成JSON，这样一来可以更好的标志可以转换为JSON对象的JAVA类。JAXB允许JAVA人员将JAVA类映射为XML表示方式，常用的注解包括：@XmlRootElement,@XmlElement等等。实体类注解package app.lkx.xml.jaxb.bean;import javax.xml.bind.annotation.XmlElement;import javax.xml.bind.annotation.XmlRootElement;@XmlRootElement(name="RECORD")public class Record {	private String id;	private String name;		@XmlElement(name="ID")	public String getId() {		return id;	}	public void setId(String id) {		this.id = id;	}	@XmlElement(name="NAME")	public String getName() {		return name;	}	public void setName(String name) {		this.name = name;	}	@Override	public String toString() {		return "Record [id=" + id + ", name=" + name + "]";	}	}将xml转换为实体类package app.lkx.xml.jaxb;import java.io.StringReader;import javax.xml.bind.JAXBContext;import javax.xml.bind.JAXBException;import javax.xml.bind.Unmarshaller;import org.junit.Test;import app.lkx.xml.jaxb.bean.Record;public class JaxbMainTest {	@Test	public  void strToBeanTest() {		Object obj=null;		String record="&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;"				+ "&lt;RECORD&gt;"				+"&lt;ID&gt;00101&lt;/ID&gt;"				+ "&lt;NAME&gt;URPWWW&lt;/NAME&gt;"				+ "&lt;/RECORD&gt;";		try {			JAXBContext content=JAXBContext.newInstance(Record.class);			Unmarshaller unmarshaller=content.createUnmarshaller();			StringReader sr=new StringReader(record);			obj=unmarshaller.unmarshal(sr);		} catch (JAXBException e) {			e.printStackTrace();		}		System.out.println((Record)obj);	}}]]></content>
      <categories>
        
      </categories>
      <tags>
        
          <tag> DTO </tag>
        
          <tag> xml </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[shiro]]></title>
      <url>/2018/03/21/shiro/</url>
      <content type="text"><![CDATA[Shiro的使用Spring整合Shiro  在springmvc整合的前提下的后续操作  参考 https://www.cnblogs.com/dreamowneryong/p/5610748.html  http://jinnianshilongnian.iteye.com/blog/2018936/《跟我学shiro》导入maven依赖&lt;dependency&gt;  &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;  &lt;artifactId&gt;shiro-all&lt;/artifactId&gt;  &lt;version&gt;1.3.2&lt;/version&gt;&lt;/dependency&gt;实现Rleam继承AuthorizingRealm实现我们自己的rleampackage com.pad.util;import com.pad.entity.User;import org.apache.shiro.authc.*;import org.apache.shiro.authz.AuthorizationInfo;import org.apache.shiro.authz.SimpleAuthorizationInfo;import org.apache.shiro.realm.AuthorizingRealm;import org.apache.shiro.subject.PrincipalCollection;/** * @author padcn */public class MyShrio extends AuthorizingRealm{    /**     * 用于已登录用户权限认证     * @param principalCollection     * @return     */    @Override    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection){        String loginName=(String) principalCollection.fromRealm(getName()).iterator().next();        return new SimpleAuthorizationInfo();    }    /**     * 登录认证     * @param authenticationToken     * @return     * @throws AuthenticationException     */    @Override    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException {        UsernamePasswordToken token=(UsernamePasswordToken)authenticationToken;      	// 这里正式开发数据库中查询，如匹配到则返回，否则返回null,这里为了精简，没有去查询数据库      	User user=new User(1,"admin","123");        if(null != user){            return new SimpleAuthenticationInfo(user.getName(),user.getPassword(),getName());        }        return null;    }}Shiro配置文件配置配置shiro的配置文件，这里单独新建一个，也可以写在总的spring配置中@shiro.xml&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans"       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt;    &lt;bean id="myShiro" class="com.pad.util.MyShrio"&gt;&lt;/bean&gt;    &lt;bean id="securityManager" class="org.apache.shiro.web.mgt.DefaultWebSecurityManager"&gt;        &lt;!--自定义rleam--&gt;        &lt;property name="realm" ref="myShiro"/&gt;        &lt;!--缓存管理器--&gt;        &lt;property name="cacheManager" ref="cacheManager"/&gt;    &lt;/bean&gt;    &lt;!--过滤规则--&gt;    &lt;bean id="shiroFilter" class="org.apache.shiro.spring.web.ShiroFilterFactoryBean"&gt;        &lt;property name="securityManager" ref="securityManager"/&gt;        &lt;property name="loginUrl" value="/login"/&gt;        &lt;property name="successUrl" value="/index"/&gt;        &lt;property name="unauthorizedUrl" value="/login"/&gt;        &lt;property name="filterChainDefinitions"&gt;            &lt;value&gt;                &lt;!-- annon无权限访问要求 --&gt;                /=anon                /doLogin=anon                /static/**=anon                &lt;!--需权限为add的用户才可访问--&gt;                /user=perms[user:add]                &lt;!--需拥有角色为admin的用户才可访问--&gt;                /user/add=roles[admin]                &lt;!--拦截非静态资源的所有请求--&gt;                /**=authc            &lt;/value&gt;        &lt;/property&gt;    &lt;/bean&gt;    &lt;!--缓存管理器--&gt;    &lt;bean id="cacheManager" class="org.apache.shiro.cache.MemoryConstrainedCacheManager"/&gt;    &lt;bean id="lifecycleBeanPostProcessor" class="org.apache.shiro.spring.LifecycleBeanPostProcessor"/&gt;&lt;/beans&gt;拦截器配置在web.xml中加入shiro的拦截器配置&lt;filter&gt;    &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt;    &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt;    &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt;    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;同时别忘了把shiro的spring配置文件配置下。例如:&lt;servlet&gt;  &lt;servlet-name&gt;seckill-dispatcher&lt;/servlet-name&gt;  &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;  &lt;init-param&gt;    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;    &lt;param-value&gt;classpath:spring-*.xml,classpath:shiro.xml&lt;/param-value&gt;  &lt;/init-param&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt;  &lt;servlet-name&gt;seckill-dispatcher&lt;/servlet-name&gt;  &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;登录方法spring-mvc的controller@TestCtrl.java@Controllerpublic class TestCtrl {    @Resource    TestService testService;  	@ResponseBody    @RequestMapping("/doLogin")    public String doLogin(User user){        Subject subject= SecurityUtils.getSubject();      	//登录操作        subject.login(new UsernamePasswordToken(user.getName(),user.getPassword()));        System.out.printf(user.toString());        return user.toString();    }    @ResponseBody    @RequestMapping("/logout")    public String logout(User user){        Subject subject= SecurityUtils.getSubject();      	//登出操作        subject.logout();        return "logout";    }}完成。非Spring下使用结合《跟我学shiro》中的第二章中的代码public class App {    public static void main( String[] args ) throws IOException {      //产生一个SecurityManager的工厂类，获取SecurityManager对象最终获取Subject      Factory&lt;org.apache.shiro.mgt.SecurityManager&gt; factory=new  IniSecurityManagerFactory("classpath:shiro.ini");      org.apache.shiro.mgt.SecurityManager manager=factory.getInstance();      SecurityUtils.setSecurityManager(manager);      Subject subject=SecurityUtils.getSubject();            UsernamePasswordToken token=new UsernamePasswordToken("zhang","123");      System.out.println(subject.isAuthenticated());      //用户使用都是调用subject对象，但真正的逻辑都是由SecurityManager完成      subject.login(token);      System.out.println(subject.isAuthenticated());      subject.logout();    }}流程如下：  首先调用Subject.login(token)进行登录，其会自动委托给Security Manager，调用之前必须通过SecurityUtils. setSecurityManager()设置；      SecurityManager负责真正的身份验证逻辑；它会委托给Authenticator进行身份验证；        Authenticator才是真正的身份验证者，Shiro API中核心的身份认证入口点，此处可以自定义插入自己的实现；        Authenticator可能会委托给相应的AuthenticationStrategy进行多Realm身份验证，默认ModularRealmAuthenticator会调用AuthenticationStrategy进行多Realm身份验证；    Authenticator会把相应的token传入Realm，从Realm获取身份验证信息，如果没有返回/抛出异常表示身份验证失败了。此处可以配置多个Realm，将按照相应的顺序及策略进行访问。自定义Realm，实现Realm接口（也可继承AuthorizingRealm，这样只需要实现验证方法就可以了）public class MyRealm implements Realm{  public String getName() {    return "myRealm";  }  public boolean supports(AuthenticationToken token) {    return token instanceof UsernamePasswordToken;  }  /**    *验证账号    */  public AuthenticationInfo getAuthenticationInfo(AuthenticationToken token)      throws AuthenticationException {    String name=(String)token.getPrincipal();    String pwd=new String((char[])token.getCredentials());    if(!"张三".equals(name)){      throw new UnknownAccountException();    }    if(!"123".equals(pwd)){      throw new IncorrectCredentialsException();    }    return new SimpleAuthenticationInfo(name, pwd, getName());  }}在配置文件中指定RealmmyRealm=org.pad.shiro_test.realm.MyRealmsecurityManager.realms=$myRealm在有多个Realm的情况下，配置中realm已逗号分隔如：securityManager.realms=$myRealm1,$myRealm2,$myRealm3验证时也会根据配置顺序进行验证，所有都会执行一遍授权：check方法，反正boolean值subject.checkRole(“rolename”);方法注解@RequiresRoles(“zzz”)public class MyRealm extends AuthorizingRealm{  /**   * 登录验证   */  @Override  protected AuthenticationInfo doGetAuthenticationInfo(      AuthenticationToken token) throws AuthenticationException {    String name=(String)token.getPrincipal();    String pwd=new String((char[])token.getCredentials());    if(!"zhang".equals(name)){      throw new UnknownAccountException();    }    if(!"123".equals(pwd)){      throw new IncorrectCredentialsException();    }    AuthenticationInfo info = new SimpleAuthenticationInfo(name,pwd,getName());    return info;  }  /**   * 权限验证   */  @Override  protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) {    Object obj=super.getAvailablePrincipal(principals);    System.out.println(obj);    SimpleAuthorizationInfo info = new SimpleAuthorizationInfo();    info.addRole("zzz");    info.addStringPermission("111");    return info;  }}]]></content>
      <categories>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> web </tag>
        
          <tag> 权限 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[RabbitMQ Start]]></title>
      <url>/2018/03/14/RabbitMQ-01/</url>
      <content type="text"><![CDATA[RabbitMQ Start  http://www.rabbitmq.com/getstarted.html 官方示例RabbitMQ是一款比较受欢迎的消息中间件@Send.javapublic class Send {		public static void main(String[] args) throws IOException, TimeoutException {		ConnectionFactory cf=new ConnectionFactory();		cf.setHost("localhost");		Connection conn=cf.newConnection();		Channel ch=conn.createChannel();		ch.queueDeclare("queue_name",false,false,false,null);		String msg="hello world rabbitmq";		ch.basicPublish("", "queue_name", null, msg.getBytes());		System.out.println(msg);		ch.close();		conn.close();	}}@Recv.javapublic class Recv {		public static void main(String[] args) throws IOException, TimeoutException {		ConnectionFactory cf=new ConnectionFactory();		cf.setHost("localhost");		Connection conn=cf.newConnection();		Channel ch=conn.createChannel();		ch.queueDeclare("queue_name",false,false,false,null);				Consumer consumer = new DefaultConsumer(ch) {			  @Override			  public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body)				  throws IOException {				String message = new String(body, "UTF-8");				System.out.println(" [x] Received '" + message + "'");			  }			};			ch.basicConsume("queue_name", true, consumer);	}}]]></content>
      <categories>
        
      </categories>
      <tags>
        
          <tag> 消息中间件 </tag>
        
          <tag> MQ </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Java8 stream]]></title>
      <url>/2018/02/28/Java8-stream/</url>
      <content type="text"><![CDATA[Java8 stream  http://ifeve.com/stream/Java8 初体验（二）Stream语法详解这篇只是笔记，具体还是看上面链接中的比较好A sequence of elements supporting sequential and parallel aggregate operations.使用上类似于原先的iterator使用上的例子为List&lt;Integer&gt; listArrays.asList(1,null,null,2,3);long count=list.stream().filter(num-&gt;num!=null).count();System.out.print(count);这里是一个计算list中不为空元素的数量的代码。list.stream()为获取stream，filter()函数为过滤掉匹配规则的元素，count()函数则是聚合结果。创建Stream：//of方法Stream&lt;Integer&gt; intStream=Stream.of(1,2,5,4,3);//generator方法 ,这里生成的Stream是无限长的，懒加载的，//一般配合limit(int)方法使用Stream.generate(()-&gt;Math.random());Stream.generate(Math::random);Stream.generate(new Supplier&lt;Double&gt;(){    @Override    public Double get(){        return Math.random();    }});//iterate方法，直接使用iterate方法以获取的也是无限长的Stream.iterate(1, item -&gt; item + 1).limit(10).forEach(System.out::println);对于原先有的容器在Collection接口中有定义default Stream&lt;E&gt; parallelStream() {        return StreamSupport.stream(spliterator(), true);    }可以直接使用接口的这个方法获取如：List list=new ArrayList&lt;String&gt;();Stream&lt;String&gt; stream=list.stream();转换  distinct：去重  filter:过滤  map:转换  flatMap:与map类似  peek：生成包含原Stream的新Stream，同时产生一个消费函数  limit:截断操作，获取前n各元素  skip:返回丢弃前n个元素后的stream。实例：List&lt;Integer&gt; nums = Lists.newArrayList(1,1,null,2,3,4,null,5,6,7,8,9,10);System.out.println(“sum is:”+nums.stream().filter(num -&gt; num != null).   			distinct().mapToInt(num -&gt; num * 2).               peek(System.out::println).skip(2).limit(4).sum());   值得注意的是这里转换看似经历了很多次，其实只会在最终聚合时一起进行。并不是一次一次分开转换的。Reduce聚合：在对Stream进行转换后得到的还是Stream(),而最终进行聚合才输出有意义的结果，如上面例子中的count()统计，sum()求和。//聚合为容器 //第一个参数为生成结果的工厂类//第二个参数为处理函数 list为第一个参数的返回结果，这里结果为一个ArrayList//第三个参数为并发时使用Stream&lt;String&gt; strStream=Stream.of("a",null,"b","d",null,"c");		List result=strStream.filter(str-&gt;str!=null).collect(				()-&gt;new ArrayList&lt;String&gt;(),				(list,item)-&gt;list.add(item),				(list1,list2)-&gt;list1.addAll(list2));//这里还有一种更加简便的方式//传入Collector&lt;? super T, A, R&gt; collectorList result=strStream.filter(str-&gt;str!=null).collect(Collectors.toList());Stream&lt;String&gt; strStream=Stream.of("a",null,"b","d",null,"c");//reduce有两种实现，一种是直接提供BinaryOperator 前一个参数为返回参数，后一个参数为遍历Stream中的元素。//这里reduce函数是第二种，接受两个参数，的第一个参数是可选的，为返回值的初始值。System.out.println(strStream.reduce("rua",(sum,item)-&gt;sum+item));]]></content>
      <categories>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Gradle使用]]></title>
      <url>/2018/02/27/Druid-connector/</url>
      <content type="text"><![CDATA[Druid 数据库连接池使用  https://www.cnblogs.com/longshiyVip/p/5117441.html@DruidTest.javaimport java.sql.Connection;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;import com.alibaba.druid.pool.DruidDataSource;public class DruidTest {	public static void main(String[] args) {		DruidDataSource dataSource=new DruidDataSource();		dataSource.setDriverClassName("com.mysql.jdbc.Driver");		dataSource.setUrl("jdbc:mysql://127.0.0.1:3306/com");		dataSource.setUsername("root");		dataSource.setPassword("pwd123");		dataSource.setInitialSize(5); 		dataSource.setMinIdle(1); 		dataSource.setMaxActive(10);		try {			Connection conn=dataSource.getConnection();			Statement st=conn.createStatement();			String sql="select * from person";			ResultSet rs=st.executeQuery(sql);			while(rs.next()){				for(int i=1;i&lt;=2;i++){                    System.out.println(rs.getObject(i));                }			}		} catch (SQLException e) {			e.printStackTrace();		}	}}maven依赖&lt;dependency&gt;  &lt;groupId&gt;com.alibaba&lt;/groupId&gt;  &lt;artifactId&gt;druid&lt;/artifactId&gt;  &lt;version&gt;1.0.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;  &lt;groupId&gt;mysql&lt;/groupId&gt;  &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;  &lt;version&gt;5.1.27&lt;/version&gt;&lt;/dependency&gt;另web项目中启用监控,在web.xml中配置，访问监控页面为 {ip}:{port}/{applicationName}/druid&lt;servlet&gt;      &lt;servlet-name&gt;DruidStatView&lt;/servlet-name&gt;      &lt;servlet-class&gt;com.alibaba.druid.support.http.StatViewServlet&lt;/servlet-class&gt;  &lt;/servlet&gt;  &lt;servlet-mapping&gt;      &lt;servlet-name&gt;DruidStatView&lt;/servlet-name&gt;      &lt;url-pattern&gt;/druid/*&lt;/url-pattern&gt;  &lt;servlet-mapping&gt;]]></content>
      <categories>
        
      </categories>
      <tags>
        
          <tag> java </tag>
        
          <tag> DB </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Gradle使用]]></title>
      <url>/2018/02/25/Gradle-Helloworld/</url>
      <content type="text"><![CDATA[Gradle使用  http://www.importnew.com/15881.html无依赖构建​	在项目文件夹下创建’src/main/java/hello’这样的目录结构，mkdir -p src/main/java/hello进入目录后终端中执行，#查看可用命令gradle tasks gradle的配置文件为build.gradle,位置放在项目根路径，与src文件夹同级。创建build.gradleapply plugin: 'java'这里配置了插件启用了java的构建功能。再次使用gradle tasks命令后会发现多出了一些可用功能。在hello文件夹下创建HelloWorld.java文件@HelloWorld.javapackage hello;public class HelloWorld{  public static void main(String[] args){    System.out.println("hello");  }}执行gradle build进行构建执行后会发现项目下生成了一个build目录，下面就是构建后的结果。  classes：编译后的class文件  lib:组装好的项目包目前直接使用java -jar运行打包后的jar还是不能运行项目的，因为没有指定运行的类会提示 ‘没有主清单属性’。需要在build.gradle进行配置apply plugin:'application'mainClassName='hello.HelloWorld'保存后再次构建回多出几个目录，scipts和distributions，通过scrpts文件夹中的批处理文件可以运行项目。导入第三方依赖//对于第三方库来源的配置，告诉构建系统通过maven中央仓库来检索项目所需依赖repositories{	mavenLocal()	mavenCentral()}//外部依赖，相当于maven坐标dependencies{	compile "joda-time:joda-time:2.2"}//对生成的jar包命名，版本号 最终生成为baseName-version.jarjar{	baseName='gs-gradle'	version='0.1.0'}gradle clean 清理项目gralde run 直接运行项目]]></content>
      <categories>
        
      </categories>
      <tags>
        
          <tag> 构建工具 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Netty-example-echo]]></title>
      <url>/2018/02/16/Netty-example-echo/</url>
      <content type="text"><![CDATA[Netty-example-echo  https://github.com/netty/netty/tree/4.1/example/src/main/java/io/netty/example netty例子代码  https://mp.weixin.qq.com/s/APJBmqakodF7r0KTZwrkhw 匠心零度的Netty（一）：入门篇先创建maven或者Gradle项目，导入依赖&lt;dependency&gt;  &lt;groupId&gt;io.netty&lt;/groupId&gt;  &lt;artifactId&gt;netty-all&lt;/artifactId&gt;  &lt;version&gt;4.1.19.Final&lt;/version&gt;&lt;/dependency&gt;服务端服务端主要是绑定端口后监听，并且做出相应的响应。首先创建Handler，具体的响应操作都在这实现。ChannelHandler which adds callbacks for state changes. This allows the user to hook in to state changes easily.继承ChannelInboundHandlerAdapter并重写其中三个方法channelRead(ChannelHandlerContext ctx,Object msg)和channelReadComplete(ChannelHandlerContext ctx)以及exceptionCaught(ChannelHandlerContext ctx,Throwable cause)方法。@NettyServerHandler.javaimport io.netty.buffer.ByteBuf;import io.netty.buffer.Unpooled;import io.netty.channel.ChannelHandlerContext;import io.netty.channel.ChannelInboundHandlerAdapter;public class NettyServerHandler extends ChannelInboundHandlerAdapter{	/**	 * 当服务端接受消息时调用	 */	@Override	public void channelRead(ChannelHandlerContext ctx,Object msg){		//打印出接受到的消息		String body=(String) msg;		System.out.println(body);		//返回消息		String res="感谢关注！"+System.getProperty("line.separator");		ByteBuf resp=Unpooled.copiedBuffer(res.getBytes());		ctx.writeAndFlush(resp);	}	/**	 * 消息读取完毕时调用	 */	@Override	public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {		ctx.flush();	};	/**	 * 捕获到异常时执行	 */	@Override	public void exceptionCaught(ChannelHandlerContext ctx,Throwable cause)throws Exception{		cause.printStackTrace();		ctx.close();	}}使用ServerHandler@NettyServer.javaimport io.netty.bootstrap.ServerBootstrap;import io.netty.channel.Channel;import io.netty.channel.ChannelFuture;import io.netty.channel.ChannelInitializer;import io.netty.channel.ChannelOption;import io.netty.channel.ChannelPipeline;import io.netty.channel.EventLoopGroup;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.nio.NioServerSocketChannel;import io.netty.handler.codec.LineBasedFrameDecoder;import io.netty.handler.codec.string.StringDecoder;import io.netty.handler.logging.LogLevel;import io.netty.handler.logging.LoggingHandler;public final class NettyServer {	static final int PORT=8007;		public static void main(String[] args) throws InterruptedException {		//用以处理nio的accept		EventLoopGroup bossGroup=new NioEventLoopGroup();		//用以处理nio的Read和Write事件		EventLoopGroup workerGroup=new NioEventLoopGroup();		try{			ServerBootstrap b=new ServerBootstrap();			//channel传入构造Channel的类 ，option设置创建Channel时的设置，handler设置用来响应请求的handler			b.group(bossGroup,workerGroup).channel(NioServerSocketChannel.class)				.option(ChannelOption.SO_BACKLOG, 1024).handler(new LoggingHandler(LogLevel.INFO))				.childHandler(new ChannelInitializer&lt;Channel&gt;() {					@Override					protected void initChannel(Channel ch) throws Exception {						//Inserts ChannelHandlers at the last position of this pipeline.						ChannelPipeline p=ch.pipeline();						p.addLast(new LineBasedFrameDecoder(1024));						p.addLast(new StringDecoder());						p.addLast(new NettyServerHandler());					}				});			//创建通道绑定端口,sync方法等待future执行完毕			ChannelFuture f=b.bind(PORT).sync();			//等待connection关闭			f.channel().closeFuture().sync();		}finally{			bossGroup.shutdownGracefully();			workerGroup.shutdownGracefully();		}	}}至此服务端以及开发完毕，运行后可以使用telnet进行测试了客户端客户端的开发其实与服务端类似，也需要继承实现ChannelInboundHandlerAdapter并重写其中的方法@NettyClientHandler.javaimport io.netty.buffer.ByteBuf;import io.netty.buffer.Unpooled;import io.netty.channel.ChannelHandlerContext;import io.netty.channel.ChannelInboundHandlerAdapter;public class NettyClientHandler extends ChannelInboundHandlerAdapter{	private byte[] req;	public NettyClientHandler() {		super();		req=("你好零度。"+System.getProperty("line.separator")).getBytes();	}	/**	 * 与服务端建立连接时调用	 */	@Override	public void channelActive(ChannelHandlerContext ctx){		ByteBuf message=null;		message=Unpooled.buffer(req.length);		message.writeBytes(req);		ctx.writeAndFlush(message);	}	/**	 * 通道接受信息时调用	 */	@Override	public void channelRead(ChannelHandlerContext ctx,Object msg){		String body=(String)msg;		System.out.println(body);	}	/**	 * 通道读取完毕时调用	 */	@Override	public void channelReadComplete(ChannelHandlerContext ctx){		ctx.flush();	}		@Override    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {        // Close the connection when an exception is raised.        cause.printStackTrace();        ctx.close();    }}@NettyClient.javaimport io.netty.bootstrap.Bootstrap;import io.netty.channel.Channel;import io.netty.channel.ChannelFuture;import io.netty.channel.ChannelInitializer;import io.netty.channel.ChannelOption;import io.netty.channel.ChannelPipeline;import io.netty.channel.EventLoopGroup;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.nio.NioSocketChannel;import io.netty.handler.codec.LineBasedFrameDecoder;import io.netty.handler.codec.string.StringDecoder;public class NettyClient {	public static void main(String[] args) throws InterruptedException {		EventLoopGroup group=new NioEventLoopGroup();		try{			Bootstrap b=new Bootstrap();			b.group(group).channel(NioSocketChannel.class)				.option(ChannelOption.TCP_NODELAY, true)				.handler(new ChannelInitializer&lt;Channel&gt;() {					@Override					protected void initChannel(Channel ch) throws Exception {						ChannelPipeline p=ch.pipeline();						p.addLast(new LineBasedFrameDecoder(1024));						p.addLast(new StringDecoder());						p.addLast(new NettyClientHandler());					}				});			//连接到netty服务端			ChannelFuture f=b.connect("localhost",8007).sync();			f.channel().closeFuture().sync();		}finally{			group.shutdownGracefully();		}	}}]]></content>
      <categories>
        
      </categories>
      <tags>
        
          <tag> web </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Reduexnotes]]></title>
      <url>/2018/01/16/ReduexNotes/</url>
      <content type="text"><![CDATA[Redux  https://www.imooc.com/video/13207 教程视频http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_one_basic_usages.html 阮一锋flux:reducer:  是响应的抽象  是纯方法，根据输入返回输出，方法中不依赖比如时间之类  传入旧的状态state和action  返回新的状态Store一个保存数据的地方，整个应用只有一个Storeredux提供createStore这个函数来生成Store  action作用在store上  reducer根据store响应  store是唯一的  store包含了完整的state  state完全可以预测import {createStore} from 'redux';const store=createStore(fn);State一个State对应以额View。只要State相同，view就相同，反之亦然。 某个时间点Store的快照，的数据集合叫做stateimport {createStore} from 'redux';const store=createStore(fn);const state=store.getState();ActionAction就是View发出的通知，通知State发生变化const action={	type:'ADD_TODO',    payload:'Learn Redux'}Action描述当前发生的事情，改变State的唯一办法，就是使用Action.他会运送数据到Store。container和componenet                   container      component                  目的      如何工作(数据获取,状态更新)      如何显示(样式，布局)              是否在redux数据流中      是      否              读取数据      从redux获取state      从props获取数据              修改数据      向redux派发actions      从props调用回调函数              实现方式      由react-redux生成      手写      ]]></content>
      <categories>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Reactnotes]]></title>
      <url>/2018/01/14/ReactNotes/</url>
      <content type="text"><![CDATA[React学习笔记  官方入门中文小案例:https://doc.react-china.org/tutorial/tutorial.html#%E6%95%99%E7%A8%8B%E7%AE%80%E4%BB%8B父组件传递给子组件变量是通过this.props.value获取:class Child extends React.Component{	render(){    	return (        	&lt;button             onClick={()=&gt;this.props.onClick()}            &gt;            {this.props.value}            &gt;&lt;/button&gt;        );    }}class Parent extends React.Component{	handleClick(i){    	console.log(i);    }	renderChild(i){    	return (        	&lt;Child value={i} onClick={()=&gt;this.handleClick(i)}/&gt;        );    }}如果该组件只有一个render方法，那么可以考虑使用函数式定义function Square(props){	return (    	&lt;button onClick={props.onClick}&gt;{props.value}&lt;/button&gt;    );}  这里onClick={proprs.onClick}不能写成onClick={proprs.onClick()}因为这种写法会在页面渲染时触发。声明函数需要在组件类外声明，否则会报错]]></content>
      <categories>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[WebSocket]]></title>
      <url>/2017/10/16/WebSocket/</url>
      <content type="text"><![CDATA[WebSocket  https://www.cnblogs.com/fuqiang88/p/5956363.html  http://www.runoob.com/html/html5-websocket.html概述WebSocket是HTML5开始提供的一种在单个 TCP 连接上进行全双工通讯的协议。在WebSocket API中，浏览器和服务器只需要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送。浏览器通过 JavaScript 向服务器发出建立 WebSocket 连接的请求，连接建立以后，客户端和服务器端就可以通过 TCP 连接直接交换数据。当你获取 Web Socket 连接后，你可以通过 send() 方法来向服务器发送数据，并通过 onmessage 事件来接收服务器返回的数据。使用场景多用于需要服务端需要主动通知用户时，比如聊天系统，消息推送等。在日常业务开发时有时候会遇到一些需求，比如系统中有新消息产生的时候需要通知到用户，这时候有个选择就是使用ajax进行轮询，但是大部分时候是没有新消息的，所以很浪费资源，效率还低。但是再有了webSocket之后，就可以做到让服务端有新消息时主动通知用户。服务端代码@WebSocketTest.javaimport java.io.IOException;import java.util.HashSet;import java.util.Set;import javax.websocket.OnClose;import javax.websocket.OnMessage;import javax.websocket.OnOpen;import javax.websocket.Session;import javax.websocket.server.ServerEndpoint;@ServerEndpoint("/websocketTest")public class WebSocketTest {    /**     * 用于存放用户对象     */	public static Set&lt;Object&gt; userSet=new HashSet&lt;Object&gt;();	private Session session;	/**     * 接收消息时调用方法     */	@OnMessage	public void onMessage(String message)throws IOException,InterruptedException{		System.out.println("receive msg "+message);		distributeMsg(message);	}	/**     * 初始化连接websocket时方法     */	@OnOpen	public void onOpen(Session session){		this.session=session;		userSet.add(this);		System.out.print("socket open."+this+" connnected.");		System.out.println(userSet.size());	}	/**     * client端中断连接时调用方法,这里是移除client连接对象     */	@OnClose	public void onClose(){		System.out.println("socket close"+this+" disconnnected.");		userSet.remove(this);	}	/**     * 消息分发给set中的所有连接client     */	public void distributeMsg(String msg){		System.out.println("dis size"+userSet.size());		for(Object wst:userSet){			try{                // 发送消息				((WebSocketTest)wst).session.getBasicRemote().sendText(msg);			}catch(IOException e){				e.printStackTrace();			}		}	}}Client端js代码@TestWebSocket.html&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;	&lt;title&gt;TestWebSocket&lt;/title&gt;	&lt;meta charset="utf-8"&gt;	&lt;script src="https://cdn.bootcss.com/jquery/3.2.1/jquery.slim.min.js"&gt;&lt;/script&gt;	&lt;script type="text/javascript"&gt;		var ws;		var openflag=false;		function openWs(){			ws=new WebSocket("ws://127.0.0.1:8080/client/websocketTest");			if(!openflag){;				ws.onopen=function(){					alert("open");					$("#ctlBtn").prop('value','close');				}			}else{				ws.onclose=function(){					alert("close");					$("#ctlBtn").prop('value','open');				}			}			openflag=!openflag;		}		function sendMsg(){			var sendText=$("#nickName").val()+":"+$("#context").val();			ws.send(sendText);						ws.onmessage=function(evt){				var msg=evt.data;				$("#container").append(msg+"&lt;br/&gt;");				$("#context").empty();			}		}		$(document).ready(function(){			//openWs();		});	&lt;/script&gt;&lt;/head&gt;&lt;body&gt;	&lt;div style="text-align: center;"&gt;		&lt;a href="#"&gt;WS run&lt;/a&gt;				&lt;input type="text" id="nickName" name="nickName" placeholder="昵称:"/&gt;		&lt;input type="text" id="context" name="context" placeholder="发送内容"/&gt;		&lt;input type="button" id="ctlBtn" onclick="openWs()" value="Open"/&gt;		&lt;input type="button" id="sendBtn" onclick="sendMsg()" value="Send"/&gt;		&lt;hr/&gt;		&lt;div id="container"&gt;&lt;/div&gt;	&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;maven依赖坐标		&lt;dependency&gt;		    &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt;		    &lt;artifactId&gt;tomcat-coyote&lt;/artifactId&gt;		    &lt;version&gt;7.0.27&lt;/version&gt;		&lt;/dependency&gt;		&lt;dependency&gt;            &lt;groupId&gt;javax.websocket&lt;/groupId&gt;            &lt;artifactId&gt;javax.websocket-api&lt;/artifactId&gt;            &lt;version&gt;1.0-rc5&lt;/version&gt;            &lt;scope&gt;provided&lt;/scope&gt;        &lt;/dependency&gt;]]></content>
      <categories>
        
      </categories>
      <tags>
        
          <tag> web </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Unix网络编程卷一笔记（一）]]></title>
      <url>/2017/10/15/UnixNetNote1/</url>
      <content type="text"><![CDATA[Unix网络编程卷一笔记（一）准备工作：  在官网下载make所需要的库文件http://www.unpbook.com/下载后解压unpv13e.tar.gz文件    tar -zxvf unpv13e.tar.gz        进入解压出的unpv13e目录根据README文件提示，进行make    ./configurecd libmake        在unp13e目录下生成了libunp.a文件复制到/usr/lib和/usr/lib32目录下  将unpv13e目录下的unp.h的    #include "../config.h"        更改为    #include "config.h"        然后将修改后的unp.h以及 unpv13e目录下的config.h复制进/usr/include目录中。    测试编译：之后的编译中需要加上静态连接库，解压后的unpv13e/intro中有第一章的获取时间程序可以编译试试。-l参数链接静态连接库。    cd .introgcc daytimetcpcli.c -o daytimetcpcli -lunp        编译通过则表示配置成功。          参考 http://blog.csdn.net/chenhanzhun/article/details/41827241      获取时间的客户端/intro/daytimetcpcli.c#include "unp.h"int main(int argc,char **argv){            int sockfd,n;    char recvline[MAXLINE+1];    struct sockaddr_in servaddr;    if(argc!=2)        err_quit("usage:a.out &lt;IPAddress&gt;");        //sokect函数创建一个网际字节流套接字，    //函数返回一个小整数描述符，以后所有函数调用都使用该描述符标识这个套接字。    if( (sockfd=socket(AF_INET,SOCK_STREAM,0)) &lt; 0 )        err_sys("socket error");    //清零结构后设置端口号    bzero(&amp;servaddr,sizeof(servaddr));    servaddr.sin_family=AF_INET;    servaddr.sin_port=htons(13);    //inet_pton将命令行参数（这里是输入的ip）转换成合适的格式    if(inet_pton(AF_INET,argv[1],&amp;servaddr.sin_addr) &lt; 0)        err_quit("inet_pton error for %s",argv[1]);    //与服务器建立连接，SA是书作者定义的为 struct sockaddr,是通用套接字地址结构。    if(connect(sockfd,(SA *)&amp;servaddr,sizeof(servaddr)) &lt; 0)        err_quit("connect error");    //读取服务器应答    while( (n=read(sockfd,recvline,MAXLINE)) &gt; 0){        recvline[n]=0;        if(fputs(recvline,stdout) == EOF)            err_sys("fputs error");    }    if(n&lt;0)        err_sys("read error");    exit(0);}下面的Sokect函数以及Listen函数这些以大写字母开头的函数为作者自己封装进行处理的函数只是原函数进行了错误处理，如 if( (sockfd=socket(AF_INET,SOCK_STREAM,0)) &lt; 0 )        err_sys("socket error");直接被定义成了int Socket(int family,int type,int protocol){	int n;	if( (n=socket(AF_INET,SOCK_STREAM,0)) &lt; 0 )        err_sys("socket error");    return n;}书中称为包裹函数。/intro/daytimetcpsrv.c#include "unp.h"#include &lt;time.h&gt;int main(int argc,char** argv){    int listenfd,connfd;    struct sockaddr_in servaddr;    char buff[MAXLINE];    time_t ticks;	//创建套接字    listenfd=Socket(AF_INET,SOCK_STREAM,0);	//初始化    bzero(&amp;servaddr,sizeof(servaddr));    servaddr.sin_family=AF_INET;    servaddr.sin_addr.s_addr=htonl(INADDR_ANY);    servaddr.sin_port=htons(13);	//绑定端口    Bind(listenfd,(SA*)&amp;servaddr,sizeof(servaddr));	//将套接字转换为一个监听套接字    Listen(listenfd,LISTENQ);    for(;;){        connfd=Accept(listenfd,(SA*)NULL,NULL);        ticks=time(NULL);        snprintf(buff,sizeof(buff),"%.24s\r\n",ctime(&amp;ticks));        //返回时间        Write(connfd,buff,strlen(buff));        Close(connfd);    }}查看网络接口信息netstat -ni 显示网络接口的信息，-n标志以输出数值地址，而不是反向解析成名字。 lo为loopback环回接口，以太网接口称为eth0,netstat -nr 展示路由表，其中n也是和上面相同作用。ifconfig eth0显示接口详细信息。找出本地网络中众多主机的ip地址方法之一是ping从ifconfig命令找出的广播地址。  单一UNIX规范第三版POSIX 标准为 Portable Operating System Interface的首字母的缩写，可移植操作系统接口]]></content>
      <categories>
        
      </categories>
      <tags>
        
          <tag> 网络编程 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Spring Boot - HelloWorld]]></title>
      <url>/2017/09/03/SpringBoot/</url>
      <content type="text"><![CDATA[Spring Boot  官网 http://projects.spring.io/spring-boot/环境需求：java8，spring framework5.0以上https://start.spring.io/ 官网提供了一个简单demo的生成，可以选择maven或者gradle当然使用idea更加简洁新建项目 选择Spring Initializr下一步填写相关maven的配置，下一步勾选web之后就可以得到一个初始的spring boot项目下面一个类就是核心的类，通过运行这个类的main方法启动整个项目。@SpringBootApplicationpublic class BootstartApplication implements EmbeddedServletContainerCustomizer{	public static void main(String[] args) {		SpringApplication.run(BootstartApplication.class, args);	}	//这个方式是修改内置tomcat的端口号，如果没有这个方法默认就是8080	@Override	public void customize(ConfigurableEmbeddedServletContainer container){		container.setPort(80);	}}下面新建一个controller@RestController //该注解表明返回的是json字符串类型@RequestMapping("/Test")public class TestCtl {    @RequestMapping("/test")    public String test(){        return "helloworld";    }    @RequestMapping("/hello")    public String hello(){        return "In hello";    }    @RequestMapping("/hi")    public String hi(){        return "In hi";    }}接着运行上面类的main方法就可以在浏览器中访问localhost/Test/test了。接着使用mvn package可以进行打包，打包后产生的jar可以使用java -jar xxxxxx.jar进行运行，启动项目。完全不需要进行配置。当然如果感觉默认配置不适合可以在默认生成的resources目录下的application.properties文件里进行配置，如上面代码中进行的端口配置也可以在这个文件中配置。  http://blog.csdn.net/catoop/article/details/50588851 spring boot可用配置  https://spring.io/guides/ 各种Spring boot入门例子]]></content>
      <categories>
        
      </categories>
      <tags>
        
          <tag> Spring </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[使用POI读取Excel]]></title>
      <url>/2017/08/28/POI%E8%AF%BB%E5%8F%96Excel/</url>
      <content type="text"><![CDATA[使用POI读取Excel  /** * 读取表格头 * @param is * @return titles 表格表头内容数组 */public String[] readTitle(InputStream is){    HSSFWorkbook wb;        try {        POIFSFileSystem fs=new POIFSFileSystem(is);        wb=new HSSFWorkbook(fs);    } catch (IOException e) {        e.printStackTrace();    }    //获取表格    HSSFSheet sheet=wb.getSheetAt(0);    //获取表格第二行，初始0开始    HSSFRow row=sheet.getRow(1);    int colNum=row.getPhysicalNumberOfCells();    System.out.println("total count:"+colNum);    String[] titles =new String[colNum];    for(int i=0;i&lt;colNum;i++){        titles[i]=row.getCell(i).getStringCellValue();    }    return titles;}总体流程是：  使用InputStream初始化POIFSFileSystem对象，用来构造HSSFWorkbook对象。  使用HSSFWorkbook对象的getSheet(int index)方法来获取表格(HSSFSheet对象)。  HSSFSheet对象有getRow(int index)来获取单行对象(HSSFRow)，也可以使用getLastRowNum()来获得该表格总共行数。  HSSFRow对象可以使用getPhysicalNumberOfCells()来获取总的存在值的列数。也可以使用getCell(int index)来获取单元格对象(HSSFCell)。  HSSFCell对象可以使用getStringCellValue()方法来获取单元格内文本的String类型的值，getNumericCellValue()获取单元格内数值信息，等等。  以上对象中也可以获取单元格的样式，getCellStyle()返回HSSFCellStyle对象。当然以上是针对于文件是.xls来说的，如果使用的是新的.xlsx则会报错，提示使用另外一个对象。  使用HSSF读取xlsx文件提示:Exception in thread “main” org.apache.poi.poifs.filesystem.OfficeXmlFileException: The supplied data appears to be in the Office 2007+ XML. You are calling the part of POI that deals with OLE2 Office Documents. You need to call a different part of POI to process this data (eg XSSF instead of HSSF)其他方法HSSFCell对象的getCellTypeEnum可以获取单元格内容数据类型，可以根据数据类型来进行相应的处理。常用的是对日期的处理。  原来是getCellType但是已经被废弃。如果使用不匹配的方法读取内容会报错：Exception in thread “main” java.lang.IllegalStateException: Cannot get a STRING value from a NUMERIC cell。这里是使用getStringCellValue来接收数字类型后的异常信息。]]></content>
      <categories>
        
      </categories>
      <tags>
        
          <tag> 文件 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[React]]></title>
      <url>/2017/08/18/React/</url>
      <content type="text"><![CDATA[Reacthttps://github.com/react-webpack-generators/generator-react-webpack# 安装yomannpm install -g yo# 安装webpack-generatornpm install -g generator-react-webpack# 生成项目yo react-webpack projectName# auoprefix loadernpm install autoprefix-loader --save-dev# jsonloadernpm install json-loader --save-devder  如果出现ERROR in Cannot find module ‘node-sass’ 类似错误可以使用 npm install node-sass –save-dev进行解决]]></content>
      <categories>
        
      </categories>
      <tags>
        
          <tag> React </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[OkHttp]]></title>
      <url>/2017/07/29/okhttp/</url>
      <content type="text"><![CDATA[OkHttp  官网 http://square.github.io/okhttp/OKHttp是一款优秀的HTTP框架，一个处理网络请求的开源项目,是安卓端最火热的轻量级框架,由移动支付Square公司贡献(该公司还贡献了Picasso)。他支持get和post请求，支持基于Http的文件上传和下载，支持加载图片，支持下载文件透明的GZIP压缩，支持响应缓存避免重复的网络请求，支持使用连接池来降低响应延迟的问题。看了看官网，很简洁，开头一小段介绍之后就是2个例子，使用起来也感觉很简洁。对于java最小要求是1.7,对于android则要求2.3+版本。首先第一步当然是引入相应的jar包，okhttp的自然官网就有，但是他还需要Okio的jar包的支持，所以要去下载Okio的jar包。引入后就可以使用了OkHttpClient client=new OkHttpClient();public String run(String url){	//其中url为请求的地址，这里如果需要在Header中放入一些信息的话，    //可以在Builder()后使用方法addHeader(String name,String value)增加请求头信息	Request request=new Request.Builder()    							.url(url)                                .build();    //response中是这次发送请求后的返回值，里面包含很多信息，如状态码code,协议protocol和body    Response response =client.newcall(rquest).execute();    return response.body().string();}response.body()返回的是响应体，一般我们需要的信息都在这里。string()方法则会把响应体内文本返回，如上面的run方法会把url指向的网页内容返回。上面第一个例子采用的是get方式，下面是第二个例子，post了json字符串到服务端。//这边要先设置request的数据格式public static final MediaType JSON    = MediaType.parse("application/json; charset=utf-8");OkHttpClient client = new OkHttpClient();String post(String url, String json) throws IOException {  //RequestBody就是准备post的数据  RequestBody body = RequestBody.create(JSON, json);  Request request = new Request.Builder()      .url(url)      .post(body)      .build();  Response response = client.newCall(request).execute();  return response.body().string();}其他基本没变化，只是多了一个post方法和一个RequestBody对象。这边可以post数据到另一个系统的某接口然后获取响应的内容信息，还是很有用的。基本使用就结束了，当然还有很多没写出来。  具体更加详细完整可以看 http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0106/2275.html]]></content>
      <categories>
        
      </categories>
      <tags>
        
          <tag> 网络 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[JQuery validate]]></title>
      <url>/2017/07/21/js-validate/</url>
      <content type="text"><![CDATA[JQuery validate  http://www.runoob.com/jquery/jquery-plugin-validate.htmlhttp://blog.csdn.net/xh16319/article/details/9987847引入validate文件&lt;script src="http://static.runoob.com/assets/jquery-validation-1.14.0/lib/jquery.js"&gt;&lt;/script&gt;&lt;script src="http://static.runoob.com/assets/jquery-validation-1.14.0/dist/jquery.validate.min.js"&gt;&lt;/script&gt;需要注意的是引入文件时如果有其他jquery文件可能会有冲突，导致不起效，报的错为validate不能被识别。$().ready(function() {// 在键盘按下并释放及提交后验证提交表单  $("#signupForm").validate({    rules: {      firstname: "required",      lastname: "required",      username: {        required: true,        minlength: 2      },      password: {        required: true,        minlength: 5      },      confirm_password: {        required: true,        minlength: 5,        equalTo: "#password"      },      email: {        required: true,        email: true      },      topic: {        required: "#newsletter:checked",        minlength: 2      },      agree: "required"    },    messages: {      firstname: "请输入您的名字",      lastname: "请输入您的姓氏",      username: {        required: "请输入用户名",        minlength: "用户名必需由两个字母组成"      },      password: {        required: "请输入密码",        minlength: "密码长度不能小于 5 个字母"      },      confirm_password: {        required: "请输入密码",        minlength: "密码长度不能小于 5 个字母",        equalTo: "两次密码输入不一致"      },      email: "请输入一个正确的邮箱",      agree: "请接受我们的声明",      topic: "请选择两个主题"    }});远程验证在一些情况下需要将数据与服务器端进行对比验证，比如注册用户时一些信息不能为系统中已经存在的数据，这个时候就需要将数据发送到服务器进行验证，服务器再返回验证结果。remote:{	url:"&lt;IPAddress:Port&gt;/isExists",    type:"post",    dataType:"json",    data:{    	username:function(){        	return $("#username").val();        }    }}服务器端只能返回true或者false。使用方式与required等一样。自定义验证规则格式为：addMethod(name,method,message)虽然默认提供了许多种情况的验证，但是有的时候还是不能满足我们的需求，这个时候就需要我们自己进行自定义验证JQuery.validator.addMethod("myValidate",function(value,element,param){	//验证是否中文	var pattern=/[^\u4e00-\u9fa5]/;	return pattern.test(value);},$.validator.format("error messages here..."));在使用的时候就可以和系统默认的规则required,digits等一样使用。在这里function中参数只用到了value就是组件的值，element为组件本身，param是使用规则时可以传入的参数值。如 myValidate:[“1”,”2”]，则param[0]为1,param[1]为2  常用正则 http://www.cnblogs.com/zxin/archive/2013/01/26/2877765.html]]></content>
      <categories>
        
      </categories>
      <tags>
        
          <tag> js </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Spark基础学习笔记]]></title>
      <url>/2017/07/01/Spark/</url>
      <content type="text"><![CDATA[Spark基础学习笔记  http://www.imooc.com/learn/814Spark组件图：Spark Core包含基本功能：任务调度，内存管理，容错机制等。内部定义了RDDs（弹性分布式数据库集）提供了很多APIs来创建和操作这些RDDs。作用：为其他组件提供底层的服务。SparkSQL是Spark处理结构化数据的库，像Hive SQL,Mysql一样。作用：企业中用来做报表统计。Spark Streaming是实时数据流处理组件，类似Storm。提供了API来操作实时流数据。作用：企业中用来从Kafka或者其他消息队列接受数据做实时统计。Mlib一个包含通用机器学习功能的功能，Machine learning lib。包含分类，聚类，回归等，还包括模型评估，和数据导入。Mlib提供的这些方法，都支持集群上的横向扩展。机器学习Graphx是处理图的库(例如，社交网络图)，并进行图的并行计算。像Spark Streaming，Spark SQL一样，继承了RDD API。提供了各种图的操作和常用图算法，例如PangeRank算法。作用：图计算Cluster Managers集群管理，Spark自带一个集群管理是单独调度器。常见的集群管理包括Hadoop YARN，Apache Mesos紧密集成：Spark底层优化了，基于Spark组件的组件也会得到优化。 紧密集成，节省了各个组件组合使用时的部署，测试等时间。 向Spark增加新的组件时，其他组件，可立即享用新组件的功能。## 与Hadoop比较 hadoop： 离线处理，对时效性要求不高。 Spark：对时效性要求高（因为是基于内存的），机器学习等领域。Spark不具有HDFS的存储能力，要借助HDFS等持久化数据。## Spark目录文件夹 bin：包含Spark交互的可执行文件如Spark shell. core,streaming,python,…包含主要组件的源代码。 examples包含单机Spark job，例子Spark的shell 使得可以处理分布在集群上的数据。 Spark巴蜀局加载到节点的内存中，因此分布式处理可在秒级完成。 快速使迭代式计算，实时查询，分析一般在shells中完成。提供了Python Shell和Scala修改日志级别 conf下的 log4j。properties。template log4j.rootCategory=WARN,console  更改级别可以控制日志的显示。 val rdd=sc.parallelize(Array(1,2,3,4),4) rdd.count() rdd.foreach(print)//遍历打印内容 每次打印顺序随机因为，是分了4个片## Scala基础 变量申明 val或者var val 变量值不可修改，一旦分配不能重新指向别的值。 var 分配后可以指向类型相同的值匿名函数和类型推断： lines.filter(line=&gt;line.contains(“world”)) 定义一个匿名函数，接受参数line 使用line这个String类型变量的contains方法，返回结果 line类型不需要指定，能够推断出来。## Transformation 	从之前的RDD构建一个新的RDD，像map()和filter()都是。逐元素：map()接受函数，把函数应用到RDD的每一个元素，返回新RDD。```  //使用数组生成lines的rdd  val lines=sc.parallelize(Array("hell","ssps","hello","sss"));  val lines2=lines.map(word=&gt;(word,1))```filter接受一个函数，返回满足函数要求的val liens3=lines.filter(word=&gt;word.contains("hello"));lines3.foreach(println);flatMap()对每个输入元素，输出多个输出元素。将RDD中元素压扁后返回一个新的RDD。 val input=sc.textFIle("/home/xxx.txt"); val lines=input.flatMap(line=&gt;line.split(" ")); lines.foreach(println)集合运算 （并集交集）  val rdd1=sc.paralelize(Array("coffe","coffe","panda","monkey","tea"))  val rdd2=sc.paralelize(Array("coffe","kitty","monkey"))  val rdd_distinct=rdd1.distinct() //去除重复。 val rdd_union=rdd1.union(rdd2) //并集 val rdd_inter=rdd1.intersection(rdd2)//交集 val rdd_sub=rdd1.subtract(rdd2)//差集## Action 在RDD上计算出一个结果。 把结果返回给driver program或者保存在文件系统上，比如：count()，save            函数名      功能      例子      结果                  collect()      返回RDD的所有元素      rdd.collect()      {1,2,3,3}              count()      计数      rdd.count()      4              countByValue()      返回一个map表示唯一元素出现的个数      rdd.countByValue()      {(1,1),(2,1),(3,2)}              take(num)      返回几个元素      rdd.take(2)      {1,2}              top(num)      返回前几个元素      rdd.top(2)      {3,3}              takeOrdered(num)(ordering)      返回基于提供的排序算法的前几个元素      rdd.takeOrderd(2)(myOrdering)      {3,3}              takeSample(withReplacement,num,[sedd])      取样例      rdd.takeSample(false,1)      不确定              reduce(func)      合并RDD中元素      rdd.reduce((x,y)=&gt;x+y)      9              fold(zero)(func)      与reduce()相似提供zero value      rdd.fold(0)((x,y)=&gt;x+y)      9              aggregate(zeroValue)(seqOp,combOp)      与fold()相似,返回不同类型      rdd.aggregate((0,0))(x,y)=&gt;(x._1+y,x._2+1),(x,y)=&gt;(x._1+y._1,x_2+y._2)      (9,4)              foreach(func)      对每个RDD的元素作用函数      rdd.foreach      无      常用：  reduce():可以实现RDD中元素的累加，计数，和其他类型的聚集操作。  val rdd=sc.parallelize(Array(1,2,3,3))  rdd.collect()  rdd.reduce((x,y)=&gt;x+y) //得出结果9 1+2+3+3Collect()遍历整个RDD，向driver program返回RDD的内容。  需要单机内存能够容纳下(因为数据要靠被给driver，一般情况下测试的时候使用)数据大的时候一般使用saveAsTextFile()take(n)返回RDD的n个元素（同时尝试访问最少的partitions）返回的结果是无序的，测试的时候使用。top()rdd.top(1)foreach()计算RDD中每个元素，但不返回到本地。可以配合println()友好的打印数据。## RDDs的特性 ### 血统关系图 Spark维护者RDDs之间的以来关系和创建关系，叫做血统关系图。 Spark使用血统关系图来计算每个RDD的需求和恢复丢失的数据。### 延迟计算（Lazy Evaluation） Spark对RDDs的计算是第一次使用action操作的时候。这种方式可以减少数据的传输，Spark内部记录metadata表名transformations操作已经被响应。数据加载也是延迟计算，数据只有在必要的时候才会被加载。### RDD.persists() 默认每次在RDDs上面进行action操作时，Spark都重新计算RDDs如果想要重复利用一个RDD，可以使用RDD.persist(). unpersist()从缓存中移除。 可以加入参数            级别      空间占用      cpu消耗      是否在内存中      是否在硬盘上      备注                  MEMORY_ONLY      High      Low      Y      N                     MEMORY_ONLY_SER      Low      High      Y      N                     DISK_ONLY      Low      High      N      Y                     MEMORY_AND_DISK      High      Medium      Some      Some      内存放不下时，往硬盘上放              MEMORY_AND_DISK_SER      Low      High      Some      Some      内存放不下时往硬盘上放，内存中数据时序列化      ## KeyValue对RDDs 创建： map函数 val rdd=sc.textFile("/home/xxx.txt"); //以第一个元素作为key，整行为value val rdd2=rdd.map(line=&gt;(line.split(" ")(0),line))常见操作|函数名|作用|例子|结果| |—|—|—|—| |reduceByKey(func)|把相同key结合|rdd.reduceByKey(x,y)=&gt;x+y|{(1,2),(3,10)}| |groupByKey()|把相同key的values分组|rdd.groupByKey()|{(1,[2]),(3,[4,6])}|  |combineByKey(createCOmbiner,mergeValue,mergeCombiners,partitioner)|把相同key的结合，使用不同的返回类型|||sc.parallelize(Array((1,2),(3,4),(3,6)))  val rdd3=sc.parallelize(Array((1,2),(3,4),(3,6)))  val rdd4=rdd3.reduceByKey((x,y)=&gt;x+y)//按key相同则相加结果为（1,2）（3,10）  val rdd5=rdd3.groupByKey()//根据key分组结果为(1,[2]),(3,[4,6])            函数名      作用      例子      结果                  mapValues(func)      函数作用于pairRDD的每个元素，key不变      rdd.mapValues(x=&gt;x+1)      {(1,3),(3,5),(3,7)}              flatMapValues(func)      符号化的时候使用      rdd.flatMapValues(x=&gt;(xto 5))      {(1,2),(1,3),(1,4),(1,5),(3,4),(3,5)}              keys      仅返回keys      rdd.keys      {1,3,3}              values      仅返回value      rdd.values      {2,4,6}              sortByKey()      按照key排序      rdd.sortByKey()      {(1,2),(3,4),(3,6)}      ## combineByKey(): 参数列表（createCombiner,mergeValue,mergeCombiners,partitioner） 最常用的基于key的聚合函数，返回类型可以与输入类型不一样。 许多基于key的聚合函数都用到了它，如groupByKey().遍历partition中元素，元素的key，要么见过，要么不是。 新元素使用createCombiner()函数， 如果是已经存在的key则使用mergeValue()函数 合计每个partition的结果时，使用mergeCOmbiners()函数 //求平均值 val scores=sc.parallelize(Array(("na",111),("na",101),("na",110),("ml",81),("ml",97),("ml",90))) //score代表值分数 val score2=scores.combineByKey( score=&gt;(1,score),(c1:(Int,Double), newScore)=&gt;(c1._1+1,c1._2+newScore), (c1:(Int,Double),c2:(Int,Double)=&gt;(c1._1+c2._1,c1._2+c2._2)))  val average=score2.map{case(name,(num,score))=&gt;(name,score/num)}  http://www.cnblogs.com/rigid/p/5563205.html]]></content>
      <categories>
        
      </categories>
      <tags>
        
          <tag> Spark </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[ECharts]]></title>
      <url>/2017/06/30/Echarts/</url>
      <content type="text"><![CDATA[EChartsEcharts 官网：http://echarts.baidu.com/index.htmlAPI文档 ： http://echarts.baidu.com/api.html#echartsECharts，一个纯 Javascript 的图表库，可以流畅的运行在 PC 和移动设备上，兼容当前绝大部分浏览器（IE8/9/10/11，Chrome，Firefox，Safari等），底层依赖轻量级的 Canvas 类库 ZRender，提供直观，生动，可交互，可高度个性化定制的数据可视化图表。ECharts 3 中更是加入了更多丰富的交互功能以及更多的可视化效果，并且对移动端做了深度的优化。使用Echart需要从官网下载js文件或者引入cdn，这个官网就有介绍4种方法，这里就不多做介绍。柱状图demo以下是官方文档中给出的小例子：	&lt;div id="main" style="width: 600px;height: 400px"&gt;&lt;/div&gt;	&lt;script type="text/javascript"&gt;		var mEchart = echarts.init(document.getElementById("main"));		var option = {			title : {				text : "primer"			},			tooltip : {},			legend : {				data : ['sale']			},			xAxis : {				data: ['shirt','t-shrit','pants','food']			},			yAxis :{},			series:[{				name : 'sale',				type : 'bar',				data :[1,2,3,4]			}]		};		mEchart.setOption(option);	&lt;/script&gt;首先可以看到需要提供一个具有宽高的容器，这里是id为main的div，提供容器后就使用echarts的init对象进行初始化，并且使用对象的setOption方法进行设置参数。就显示出了柱状图。  title ： 属性为图表标题  legend ： 图例  xAxis，yAxis ： x轴，y轴  series ： 系列，其中type 表示图的类型：bar是柱状图，pie饼图 ，line线性图  ，radius表示半径为百分数。 roseType: ‘angle’显示成南丁格尔图。itemStyle可是设置阴影，color设置组件颜色。Loading动画//表示显示加载动画mChart.showLoading()//在数据接受完毕时,隐藏动画mchart.hideLoading()交互组件图例组件 legend、标题组件 title、视觉映射组件 visualMap、数据区域缩放组件 dataZoom、时间线组件 timeline]]></content>
      <categories>
        
      </categories>
      <tags>
        
          <tag> javascript </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[数据分析基础知识]]></title>
      <url>/2017/06/29/AnalysisData1/</url>
      <content type="text"><![CDATA[数据分析基础知识  参考《谁说菜鸟不会数据分析》数据分析一般氛围六个步骤：  分析目的和思路 ：不要以为追求高级分析方法，目的明确，以解决问题为中心。 以营销、管理等理论为指导，结合实际业务情况，搭建分析框架。  收集数据 ： 来源 数据库、公开出版物、互联网、市场调查  处理数据 ： 主要包括 数据清理、数据转化、数据提取、数据计算等处理方法。是数据分析的前提  分析数据 ： 指的是用适当的分析方法及工具，对处理过的数据进行分析，提取有价值的信息，形成有效结论的过程。 一般数据可以通过Excel完成，高级数据分析采用分析软件如SPSS Statistics等          数据挖掘是一种高级的数据分析方法。指的是从大量数据中根据用户特定要求，找出所需信息，以满足用户需求。侧重于解决：分类，聚类，关联和预测 这4中问题。        数据展现常用的数据图表包括饼图、柱形图、条形图、折线图、散点图、雷达图等  报告撰写一份好的数据分析报告,首先需要有一个好的分析框架,并且图文并茂,层次明晰,能够让阅读者一目了然。结构清晰、主次分明可以使阅读者正确理解报告内容;图文并茂,可以令数据更加生动活泼,提高视觉冲击力,有助于阅读者更形象、直观地看清楚问题和结论,从而产生思考。另外,数据分析报告需要有明确的结论,没有明确结论的分析称不上分析,同时也失去了报告的意义,因为我们最初就是为寻找或者求证一个结论才进行分析的,所以千万不要舍本求末。常用指标和术语平均数一般指代算数平均数，另外还有调和平均数和几何平均数。绝对数和相对数绝对数是反映客观现象总体在一定时间、地点下的总规模、总水平的综合性指标，是数据分析中常用指标，如gdp，总人口等。此外，也可以表现为在一定时间、地点下数量增减变化的绝对数。相对数是指由两个有联系的指标对比计算得到的数值，用于反映客观现象之间数量联系程度的综合指标。一般以倍数、成数、百分比等表示相对数=比较数值（比数）/基础数值（基数）从业务角度：绝对数就是数量（Quantity）相对数（Quality），进行数据分析时都可以从这两个角度分析，简称QQ模型。百分比和百分点百分比是相对数中的一种,它表示一个数是另一个数的百分之几,也称百分率或百分数。百分点指不同时期以百分数表示的相对指标的变动幅度，1百分点=1%。例子：今年利润45%比去年的28%提高了17个百分点。频数和频率频数指一组数据中重复出现次数，频率指出现次数与总数比值。比例和比率比例指在总体中个部分的数值占全部数值的比重，通常反映总体的构成和结构。比率指不同类别数值的对比，反映的不是部分和整体的关系，而是一个整体中各部分的关系  例子：男生比例=n男/(n男+n女)   男女比率=n男：n女都是相对数。倍数和番数倍数是一个数初一另一个数所得的商，番数是指原来数量的2的N次方倍。  例：公司产品销量翻一番(6.4 = 3.2×2 1 ),从去年的3.2万件提高到今年的6.4万件。此外,我们成本控制也很好,由20万元下降了50%,今年成本为10万元”。同比和环比同比指历史同时期进行比较得到的数值，反映事物发展的相对情况。环比指与前一个统计期进行比较得到的数值，反映的是事物逐期发展的情况。  例：同比 2017-12：2016-12  环比: 2017-12：2017-11]]></content>
      <categories>
        
      </categories>
      <tags>
        
          <tag> 数据分析 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[JAVA IO]]></title>
      <url>/2017/06/19/IO/</url>
      <content type="text"><![CDATA[JAVA IOFile类File类可以代表一个特定文件的名称，又能代表一个目录下的一组文件的名称（使用list方法返回String数组）list 方法可以接受一个FilenameFilter的实现类作为参数，用于过滤匹配特定正则的文件名。class DirFilter implements FilenameFilter{	private Pattern pattern;	public DirFilter(String regex){		pattern=Pattern.compile(regex);	}	@Override	public boolean accept(File pathname,String name) {		return pattern.matcher(name).matches();	}}常用方法：String getName()//获取文件名字String getParent() //获取上一级文件名.要注意的是获取是根据new 文件时传入的文件路径字符串，如"./test.txt" 返回值为"."File getParentFile()//获取上一级文件对象。如果没有返回null。实现是通过getParent()实现的。boolean isAbsolute() //判断是否是绝对路径String getAbsolutePath() //获取文件所在的绝对路径File getAbsoluteFile() //等同于new File(this.getAbsolutePath()) // Constructs a &lt;tt&gt;file:&lt;/tt&gt; URI that represents this abstract pathname.boolean canWrite()boolean canRead()boolean exists()boolean isDirectory() boolean isFile() long length() //返回路径指向文件长度，如果是目录则返回长度不确定。boolean createNewFile() throws IOException //创建新文件/目录boolean delete() //删除文件void deleteOnExit() //当jvm退出时删除文件，删除顺序为注册顺序相反。删除只会在正常退出时调用。String[] list(FilenameFilter filter)//可以无参，传入FilenameFilter的实现类，作为过滤。返回目录下的文件名字符串数组。File[] listFiles(FilenameFilter filter)//功能同上，但是返回的是File数组。boolean mkdir()boolean mkdirs()//与mkdir相比，他会创建必要的父目录。boolean renameTo(File dest)public static File createTempFile(String prefix, String suffix,File directory)		throws IOException//使用给定前缀和后缀创建空的临时文件。输入输出FilterInputStream和FilterOutputStream是用来提供装饰器类接口以控制特定输入流和输出流的两个类。分别由InputStream和OutputStream派生而来，是装饰器的必要条件（以便能为所有正在被修饰的对象提供通用接口）。InputStreamInputStream的作用是用来表示那些从不同数据源产生输入的类。数据源包括：  字节数组  String对象  文件  管道，工作方式与实际管道相似，从一端输入，另一端输出。  一个由其他种类的流组成的序列，以便我们可以将他们收集合并到一个流内。  其他数据源，如Internate连接等每一种数据源都有对应的继承自InputStream的类            类      功能      构造参数/使用                  ByteArrayInputStream      允许将内存的缓冲区当作InputStream使用      缓冲区，字节从中取出， 作为数据源：将其与FilterInputSTream对象相连以提供有用接口              StringBufferInputStream      将STring转换成InputStream      字符串。底层实现实际使用StringBuffer作为一种数据源：将其与FilterInputStream对象相连以提供有用接口              FileInputStream      用于从文件中读取信息      字符串，表示文件名、文件或者FileDescriptor对象。作为一种数据源：将其与FilterInputStream对象相连以提供有用接口              PipedInputStream      产生用于写入相关PipedOutputStream的数据。实现管道化概念      PipedOutputStream 作为多线程中数据源：将其与FilterInputStream对象相连以提供有用接口              SequenceInputStream      将两个或者多个InputStream对象转换成单一InputStream      两个InputStream对象或者一个容纳InputSTream对象的容器Enumeration。 作为一种数据源：将其与FilterInputStream对象相连以提供有用接口              FilterInputStream      抽象类，作为”装饰器”的接口。其中”装饰器”为其他的InputStream类提供有用的功能      —      OutputStream该类别决定了输出所要去往的目标：字节数组（但不是String，不过可以用字节数组自己创建）、文件或管道。另外FilterOutputStream为“装饰器”类提供了一个基类，“装饰器”类把属性或者有用的接口与输出流连接了起来。类|功能|构造参数/使用–|–|—ByteArrayOutputStream|在内存中创建缓冲区。所有送往“流”的数据都要放置在此缓冲区|缓冲区初始化尺寸(可选)。用于指定数据的目的地：将其与FilterOutputSTream对象相连以提供有用接口FileOutputStream|将信息写至文件|字符串，表示文件名、文件或FileDescriptor对象。用于指定数据的目的地：将其与FilterOutputSTream对象相连以提供有用接口PipedOutputStream|任何写入其中的信息都会自动作为相关PipedInputStream的输出。实现“管道化”概念|PipedInputStream指定用于多线程的数据的目的地：将其与FilterOutputSTream对象相连以提供有用接口FilterOutputStream|抽象类，作为“装饰器”的接口，其中，“装饰器”为其他OutputStream提供有用功能|–FilterInputStreamDataInputStream允许我们读取不同基本数据类型以及String对象（所有方法都以“read”开头，如readByte(),readFloat()…）            类      功能      构造参数/使用                  DataInputStream      与DataOutputStream搭配使用，可以按照可移植方式从流读取基本数据类型（int，char，long等）      InputStream包含用于读取基本类型数据的全部接口              BufferdInputStream      使用它可以防止每次读取时都得进行实际的写操作。代表“使用缓冲区”      InputStream，可以指定缓冲区大小（可选） 本质上不提供接口，只不过是向进程中添加缓冲区所必需的。与接口对象搭配              LineNumberInputStream      跟踪输入流中的行号，可以调用getLineNumber()和setLineNumber(int)      InputStream仅增加了行号，因此可能要与接口对象搭配使用              PushbackInputStream      具有“能弹出一个字节的缓冲区”，因此可以将读到的最后一个字符回退      InputStream通常作为编译器的扫描器，之所以包含在内是因为java编译器的需要，一般可能永远不会用到。      FilterOutputStreamDataOutputStream：可以将各种基本数据类型，以及String对象格式化输出到“流”中;这样，任何机器的仍和DataInputStream都能够读取他们。所有方法都以“write”开头，如writeByte(),writeFloat()等。PrintStream最初目的为了可以可视化格式打印所有的基本数据类型以及String对象。与DataOutputStream不同，后者是将数据源素置于“流”中，使DataInputStream能可移植地重构他们。PrintStream中有print()和println()方法，对他重载可以打印出各种数据类型。 参数OutputStream，可以用boolean值指示是否在每次换行时清空缓冲区(可选)应该是对OutputStream对象的final封装。  平时用的System.out.print（）是System中有一个静态PrintStream对象。BufferedOutStream是一个修改过的OutputStream，对数据流使用缓冲技术；因此当每次向流写入时，不必每次都进行实际的物理写动作。所以在进行输出时，经常使用。 参数：OutputStream，用于指定缓冲区的大小(可选)，本质上不提供接口，只不过是向进程中添加缓冲区所必需的，与接口对象搭配。Reader和WriterReader和Writer并非是用来代替InputStream和OutputStream的类，InputStream和OutputStream在以面向字节形式的I/O中有极有价值的功能，而Reader和Writer则提供兼容Unicode与面向字符的I/O功能。            来源与去处 java1.0      java1.1                  InputStream      Reader 适配器InputStreamReader              OutputStream      Writer 适配器：OutputStreamWriter              FileInputStream      FileReader              FileOutputStream      FileWriter              StringBufferInputStream(已弃用)      StringReader              —      StringWriter              ByteArrayInputStream      CharArrayReader              ByteArrayOutputStream      CharArrayWriter              PipedInputStream      PipedReader              PipedOutputStream      PipedWriter      有一点很清楚，无论何时使用readLine()，都不应该使用DataInputStream，而应该使用BufferedReader。除了这一点，DataInputStream仍是I/O类库中的首选成员。  java1.0到java1.1未改变的类：DataOutputStream,File,RandomAccessFile,SequenceInputStreamRandomAccessFile适用于由大小已知的记录组成的文件。seek()方法将记录从一处转移到另一出，读取修改记录。RandomAccessFile不是InputStream或者OutputStream继承层次结构的一部分。除了实现了DataInput和DataOutput接口外，不使用InputStream和OutputStream类的任何已有功能，是一个完全独立的类，直接从Object派生而来的。常用方法  public RandomAccessFile(File file, String mode)        throws FileNotFoundException//构造方法，mode为“r”/“rw”/“rws”/“rwd”，不支持只写模式  getFilePointer() //查找当前所处文件位置  seek() //在文件内移至新位置  length() //判断文件最大尺寸jdk1.4中大多数功能由nio存储映射文件所取代。I/O 流常用方式import java.io.*;import java.util.*;public class BufferedInputFile{    public static List&lt;String&gt; read(String filename) throws IOException{        List&lt;String&gt; list=new LinkedList&lt;String&gt;();        BufferedReader in=new BufferedReader(new FileReader(filename));                String s;        while((s=in.readLine())!=null){                list.add(s.toUpperCase());        }        in.close();        return list;    }            public static void main(String[] args)throws IOException{        List&lt;String&gt; result=read("BufferedInputFile.java");        ListIterator i=result.listIterator();        while(i.hasNext())        	i.next();        while(i.hasPrevious()){        	System.out.println(i.previous());               }    }}import java.io.*;public class TestEOF{	public static void main()throws IOException{    	DataInputStream in=new DataInputStream(new BufferedInputStream(new FileInputStream("TestEOF.java")));        while(in.available()!=0){        	System.out.println((char)in.readByte());        }    }}标准IO重定向System.setIn(new BufferedInputStream(new FileInputStream("name.txt")));System.setOut(new PrintStream(new FileOutputStream("test.out")));System.setErr(new PrintStream(new FileOutputStream("test.out")));运行系统命令public class Test {	 public static void main(String[] args) throws IOException {		 Process process=new ProcessBuilder("screenfetch").start();		 BufferedReader result=new BufferedReader(new InputStreamReader(process.getInputStream()));		 String s;		 while((s=result.readLine())!=null)		 	System.out.println(s);		 		 BufferedReader err=new BufferedReader(new InputStreamReader(process.getErrorStream()));		 while((s=err.readLine())!=null)		 	System.out.println(s);	}}NIOJDK 1.4的java.nio.* 包中引入了新的java io类库，目的在于提高速度，实际上，旧的I/O包已经使用nio重新实现过了，以便充分利用这种速度提高。速度的提高是因为nio采用的结构更加接近操作系统执行IO的方式，即通道和缓冲器。thingking in java中的比喻是把整个想成一个煤矿，通道是矿藏，缓冲器则想象成矿车。通过矿车去取矿，再从矿车上取得矿藏。所以我们并不直接与通道进行接触，唯一与通道交互的缓冲器是ByteBuffer]]></content>
      <categories>
        
      </categories>
      <tags>
        
          <tag> JavaSE </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Swap]]></title>
      <url>/2017/06/16/swap/</url>
      <content type="text"><![CDATA[Swap通常分为值传递和引用传递。thinking in java中认为java中只有值传递。  http://guhanjie.iteye.com/blog/1683637反射通过反射不能直接修改类中的私有变量，如果要修改则需要使用setAccessible()方法。绕过了验证。field.setAccessible(true);装箱拆箱Integer a=2,b=2;这个时候a==b 为true 因为指向的时同一个cache地址，在-127～128之间会指向缓存，超过返回则去new。]]></content>
      <categories>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[JavaSE集合]]></title>
      <url>/2017/06/14/Containers/</url>
      <content type="text"><![CDATA[JavaSE集合  http://blog.csdn.net/zsw101259/article/details/7570033http://blog.csdn.net/u014136713/article/details/52089156java中集合的关系大致上就是图中所示。List和Set实现了Colection接口，CollectionCollection接口继承了Iterable接口，因此可以使用迭代器进行遍历，是List和Set的上层。其中规定了一些常用的集合需要的方法，：  boolean add（object o）  boolean remove（object o）  int size()  boolean isEmpty()  boolean contains(Object o)  Iterator iterator()  boolean containsAll(Collection c)  boolean addAll(Collection c)  void clear()  void removeAll(Collection c) 去除集合c中包含的元素  void retainAll(Collection c) 去除集合c中不包含的元素  Object[] toArray() 将集合转换为arrayCollection中不提供get方法，如果要遍历Collection中的元素则需要使用iterator。Collection的Iterator方法返回一个Iterator，Iterator接口以迭代的方式逐一的访问元素，与c++中的iterator不同的时这里的iterator并不是指向元素的，而是类似于处在两个元素之间的位置，调用next()方法越过下一个元素，并且返回那个元素。hasNext()返回是否存在下一个元素，remove()方法删除上一次访问的元素。  迭代器是 故障快速修复（fail-fast）的。这意味着，当另一个线程修改底层集合的时候，如果正在用 Iterator 遍历集合，那么，Iterator就会抛出 ConcurrentModificationException （另一种 RuntimeException异常）异常并立刻失败## List List接口继承自Collection接口，允许重复元素并且有序。 void add(int index,Object element) boolean addAll(int index,Collection c) //将c中元素加入到index位置 Object get(int index) int indexOf(Object o) int lastIndexOf(Object o) Object remove(int index) Object set(int index,Object element) //设置指定位置，返回旧元素 ListIterator listIterator() ListIterator listIterator(int index) 返回列表迭代器，从index位置开始访问 List subList(int form Index,int toIndex)以及一些从Collection中继承的方法。其中listIterator()方法返回的是ListIterator，继承自Iterator，对比Iterator不同在于可以双向移动，Iterator只能使用next()进行向后遍历，ListIterator中可以使用perivious()方法进行向前遍历。相应的hasPervious()判断是否到达头部，previousIndex()返回下次调用previous()的索引。add(Object o)添加元素和set(Object o)设置元素。  add元素后使用元素会被增加到隐式光标前。对于LinkedList和ArrayList来说，如果需要随机访问，而不需要在尾部以外的地方插入数据的话，使用ArrayList比较好，而如果只需要按照顺序进行访问数据，并且需要在中间灵活的插入数据，则使用LinkedList比较好。两者都实现了Cloneable接口。LinkedList链表常用方法： void addFirst(Object o) void addLast(Object o) Object getFirst() Object getLast() Object removeFirst() Object removeLast()ArrayList动态数组ArrayList类封装了一个动态分配的Object[]数组，每个ArrayList对象有一个capacity。这个capacity表示存储列表中元素的容器打容量。当元素添加到ArrayList时，其capacity在常量时间内自动增加。void ensureCapacity(int minCapacity) 将ArrayList对象容量增加minCapacityvoid trimToSize()整理ArrayList对象容量为当前列表大小，减少对象存储空间。VectorVector是一种老的动态数组，是线程同步的，效率很低，一般不赞成使用。对比ArrayList来讲，区别在于他是线程安全的，看源码中可以知道，他每个方法都加类synchronized，但是就是因为这样所以对比ArrayList在非多线程中他的效率是比较低的，而由于只是方法加了锁，并不能保证复合操作的线程安全性，所以应该尽量少用。  10、为什么Vector类认为是废弃的或者是非官方地不推荐使用？或者说为什么我们应该一直使用ArrayList而不是Vector  　你应该使用ArrayList而不是Vector是因为默认情况下你是非同步访问的，Vector同步了每个方法，你几乎从不要那样做，通常有想要同步的是整个操作序列。同步单个的操作也不安全（如果你迭代一个Vector，你还是要加锁，以避免其它线程在同一时刻改变集合）.而且效率更慢。当然同样有锁的开销即使你不需要，这是个很糟糕的方法在默认情况下同步访问。你可以一直使用Collections.sychronizedList来装饰一个集合。  　　事实上Vector结合了“可变数组”的集合和同步每个操作的实现。这是另外一个设计上的缺陷。Vector还有些遗留的方法在枚举和元素获取的方法，这些方法不同于List接口，如果这些方法在代码中程序员更趋向于想用它。尽管枚举速度更快，但是他们不能检查如果集合在迭代的时候修改了，这样将导致问题。尽管以上诸多原因，Oracle也从没宣称过要废弃Vector。http://blog.csdn.net/u014136713/article/details/52089156## Set Set接口继承自Coolection，常见的实现有HashSet和TreeSet,set集合中不允许出现重复。 ### HashSet HashSet是无序的 ### TreeSet TreeSet是有序的。### LinkedHashSet LinkedHashSet扩展了HashSet，如果想跟踪添加给HashSet的元素的顺序，LinkedHashSet实现会有帮助。 LinkedHashSet的迭代器按照元素的插入顺序来访问各个元素。它提供了一个可以快速访问各个元素的有序集合。同时，它也增加了实现的代价，因为 哈希表元中的各个元素是通过双重链接式列表链接在一起的。## Queue 队列尊需FIFO先进先出，LinkedList实现类Queue接口，所以LinkedList也可以被作为Queue来使用 boolean add(E e); boolean offer(E e); //功能同add，但是在受限制容量的情况下offer比较好。  E remove();//检索并且删除队列头部，如果队列是空抛出异常  E poll();//检索并且删除队列头部，如果队列是空返回null  E element();//检索但不删除队列头部，如果队列是空抛出异常  E peek(); //检索但不删除队列头部，如果队列是空返回null### PriorityQueue  http://blog.csdn.net/hiphopmattshi/article/details/7334487java5中加入。 通过Comparator进行排序，默认按自然顺序排列,也就是数字默认是小的在队列头，字符串则按字典序排列。如果需要自定义，则需要自己实现Comparator接口，作为参数传入PriorityQueue的构造器中。 # Map Map接口用于维护键值对，描述了从不重复的键到值的映射。常用方法： Object put(Object key, Object value)  Object remove(Object key) void putAll(Map t)  // 将来自特定映像的所有元素添加给该映像  void clear() //从映像中删除所有映射 Object get(Object key) //获得与关键字key相关的值，并且返回与关键字key相关的对象，如果没有在该映像中找到该关键字，则返回null  boolean containsKey(Object key)//判断映像中是否存在关键字key  boolean containsValue(Object value)//判断映像中是否存在值value  int size()//返回当前映像中映射的数量  boolean isEmpty() Set keySet() // 返回映像中所有关键字的视图集   Collection values()//返回映像中所有值的视图集  Set entrySet() //返回Map.Entry对象的视图集，即映像中的关键字/值对   键和值都可以是null，但是不能把map作为键或者值添加给自身。EntryMap的entrySet()方法返回一个实现了Map.Entry接口的对象集合，集合中每个对象都是底层Map中一个特定的键值对。 Object getKey() //返回条目的关键字   Object getValue() //返回条目的值   Object setValue(Object value) //将相关映像中的值改为value，并且返回旧值 ## HashMap构造函数如下：HashMap() //构建一个空的哈希映像  HashMap(Map m)//构建一个哈希映像，并且添加映像m的所有映射   HashMap(int initialCapacity)//构建一个拥有特定容量的空的哈希映像   HashMap(int initialCapacity, float loadFactor)//构建一个拥有特定容量和加载因子的空的哈希映像   HashMap和Hashtable的区别：Hashtable是个过时的集合类，在java4中被重写，实现类Map接口。      HashMap和Hashtable几乎等价，除了HashMap可以接受null值和键值，而Hashtable不行。    HashMap是非synchronized，而Hashtable是synchronized，所以多个线程可以共享一个Hashtable,如果没有进行同步处理HashMap不能安全打在多线程环境下使用，所以java5提供了ConcurrentHashMap，时HashTable的替代，比Hashtable扩展性好。 所以在非多线程环境下HashMap会比HashTable效率高。    HashMap不能保证随着时间的推移Map中打元素次序是不变的。http://www.importnew.com/7010.html  如果需要让HashMap同步可以使用Map m=Collections.synchronizeMap(hashMap);## TreeMap 对比HashMap，TreeMap是有序的，实现了SortedMap接口。在Map 中插入、删除和定位元素，HashMap 是最好的选择。但如果您要按自然顺序或自定义顺序遍历键，那么TreeMap会更好。使用HashMap要求添加的键类明确定义了hashCode()和 equals()的实现。TreeMap构造函数如下：//TreeMap没有类似HashMap的调优选项，因为该树总处于平衡状态。  TreeMap() TreeMap(Map m)//构建一个映像树，并且添加映像m中所有元素  TreeMap(Comparator c) //构建一个映像树，并且使用特定的比较器对关键字进行排序  TreeMap(SortedMap s) //构建一个映像树，添加映像树s中所有映射，并且使用与有序映像s相同的比较器排序 # Collections和ArraysCollections和Arrays是提供的工具类 Collections中提供了一系列接受对应的容器返回一个线程安全的容器的方法如下，方法接受原容器也可以传入自定义的锁对象：  synchronizedCollection  synchronizedSet  synchronizedSortedSet  synchronizedNavigableSet  synchronizedList  SynchronizedRandomAccessList  synchronizedMap  synchronizedSortedMap  synchronizedNavigableMapCollections类提供的sort方法可以自定义排序规则。 //方法一：在sort中传入比较器 public static void main( String[] args )    {    	List&lt;ObjForCompare&gt; list=new ArrayList&lt;ObjForCompare&gt;();       	list.add(new ObjForCompare(2,"2"));    	list.add(new ObjForCompare(1,"1"));    	list.add(new ObjForCompare(3,"3"));    	Collections.sort(list,new Comparator&lt;ObjForCompare&gt;(){			@Override			public int compare(ObjForCompare o1, ObjForCompare o2) {				if (o1.i&gt;o2.i){					return 1;				}else if(o1.i&lt;o2.i){						return -1;				}				return 0;			}    	});    	System.out.println(list);    }}class ObjForCompare{	public int i;	public String str;		public ObjForCompare(int i, String str) {		super();		this.i = i;		this.str = str;	}	@Override	public String toString() {		return str;	}        //方法二：直接让比较的类实现Comparator接口    class ObjForCompare implements Comparator&lt;ObjForCompare&gt;{	public int i;	public String str;		public ObjForCompare(int i, String str) {		super();		this.i = i;		this.str = str;	}	@Override	public String toString() {		return str;	}	@Override	public int compare(ObjForCompare o1, ObjForCompare o2) {		if (o1.i&gt;o2.i){			return 1;		}else if(o1.i&lt;o2.i){				return -1;		}		return 0;	}Arrays类主要提供了一些排序，查找，比较的方法，主要针对数组。Arrays.asList()和Collections.toArray()可以互相转换。]]></content>
      <categories>
        
      </categories>
      <tags>
        
          <tag> JavaSE </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Ubuntu增加程序到系统菜单]]></title>
      <url>/2017/06/13/UbuntuAddApplication/</url>
      <content type="text"><![CDATA[Ubuntu增加程序到系统菜单Eclipse装完之后发现在系统菜单中没有找到，每次都要进目录找比较麻烦，所以找了下方法。在/usr/share/applications目录下都是一些程序的.desktop文件，有了这个文件就可以在系统菜单中调用程序了。找了个类似的程序的.desktop来参考如Atom的：@Atom.desktop[Desktop Entry]Name=AtomComment=A hackable text editor for the 21st Century.GenericName=Text EditorExec=/opt/atom/atom %FIcon=atomType=ApplicationStartupNotify=trueCategories=GNOME;GTK;Utility;TextEditor;Development;MimeType=text/plain;X-Desktop-File-Install-Version=0.22可以看到这里定义了名字，描述，执行程序位置，图标以及分类。分类中类似关键字，会在对于系统菜单中显示。所以我们要创建的eclipse.desktop内容为：[Desktop Entry]Name=EclipseComment=c project manage softwareExec=/home/pad/Software/eclipse/java-neon/eclipse/eclipseIcon=/home/pad/Software/eclipse/java-neon/eclipse/icon.xpmTerminal=falseType=ApplicationCategories=GNOME;GTK;Development;Eclipse保存后系统菜单中就有了。]]></content>
      <categories>
        
      </categories>
      <tags>
        
          <tag> linux </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[分布式下共享session]]></title>
      <url>/2017/06/13/ShareSession/</url>
      <content type="text"><![CDATA[解决分布式环境session共享  session replication : 适合小集群。  集中存储 : 适合session数比较多，服务器数量比较大的情况  session维护在客户端 。 access_token/token 缺点安全性]]></content>
      <categories>
        
      </categories>
      <tags>
        
          <tag> 服务器 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Http]]></title>
      <url>/2017/06/13/Http/</url>
      <content type="text"><![CDATA[Http  http://www.cnblogs.com/li0803/archive/2008/11/03/1324746.htmlhttp://www.cnblogs.com/ranyonsue/p/5984001.htmlHttp属于应用层打面向对象的协议特点：  支持c/s模式  简单快速：客户向服务器请求服务时，只需请求方法和路径。  灵活：允许传输任意类型的数据对象。以Content-Type加以标记区分  无连接：每次连接只处理一个请求，处理完客户请求，并收到用户应答即断开连接。可以节省传输时间。  无状态：是无状态协议，对事务处理没有记忆能力，如需要之前的信息则需要重传，导致每次连接的数据量增大。如不需要则应答比较快。]]></content>
      <categories>
        
      </categories>
      <tags>
        
          <tag> http </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Concurrency]]></title>
      <url>/2017/06/05/Concurrency/</url>
      <content type="text"><![CDATA[Concurrency服务器编程的趋势是大容量，多线程。在多核cpu的运行环境下，多线程有效提高程序的运行效率，如果在单核cpu环境下使用多线程，虽然会由于上下文切换拖慢效率，但是可以有效的防止程序阻塞。实现方式  继承Thread    Class MyThread extends Thread{  @Override  public void run(){  	System.out.println("running");  }}        实现RunnableClass MyRunnable implements Runnable{	@Override    public void run(){    	System.out.println("running");    }}public static void main(String[] args) {		new MyThread(new MyRunnable()).start();}  实现Callablepublic class CallableTest implements Callable&lt;Object&gt; {	private String name;		public CallableTest(String name) {		super();		this.name = name;	}	@Override	public Object call() throws Exception {		return name+" return a name.";	}	public static void main(String[] args) throws InterruptedException, ExecutionException {		ExecutorService service=Executors.newFixedThreadPool(2);		Future&lt;?&gt; f1=service.submit(new CallableTest("c1"));		Future&lt;?&gt; f2=service.submit(new CallableTest("c2"));				System.out.println(f1.get().toString());		System.out.println(f2.get().toString());				service.shutdown();	}}生命周期  创建 ：new Thread（）  就绪 ：调用start()方法  运行 ：执行run()方法   sleep()/join()结束     yield()  阻塞 ：sleep()/join()  终止 ：任务执行完毕wait()后进入等待队列， notify/notifyAll()进入锁池状态， 或者运行中synchronized，拿到锁后进入可运行状态  stop方法强制结束，但是不建议用，会出现多个线程间数据不同步，线程没有执行完就被终止。一般在run方法中会有一个boolean值标志线程运行状态。使用线程的start方法使得线程进入可运行状态，当抢到cpu资源后进入运行状态。在运行中如果调用yeild()方法，则会让出cpu让重写抢占，进入可运行状态。如果线程的run方法执行结束，则线程结束。如果在运行状态的时候调用sleep或者另一个线程调用join方法，线程进入阻塞状态，sleep结束/另一个线程结束则进入就绪状态。运行中锁对象调用wait，则进入等待队列，直到调用notify或notifyAll则进入。发现锁被占用synchronized，则就会进入锁池，拿到锁则进入就绪状态。  http://blog.csdn.net/jiafu1115/article/details/6804386// 锁住的是对象的实例，如果有多个实例，则这个锁就无效。public synchronized void do(){}//等效上，对比更加灵活public void do(){	synchronized(this){    }}//多实例下public static Object lock=new Object();public void do(){    synchronized(lock){    }}一个简单的死锁示例  http://blog.csdn.net/zhangliangzi/article/details/52729026class A {	public synchronized void waitB(B b) throws InterruptedException{		System.out.println(Thread.currentThread().getName() + "：正在执行a的等待方法，持有a的对象锁");          Thread.sleep(2000L);          System.out.println(Thread.currentThread().getName() + "：试图调用b的死锁方法，尝试获取b的对象锁");  		b.dlB();	}		public synchronized void dlA(){		System.out.println(Thread.currentThread()+"current");	}}class B {	public synchronized void waitA(A a) throws InterruptedException{		System.out.println(Thread.currentThread().getName() + "：正在执行b的等待方法，持有b的对象锁");          Thread.sleep(2000L);          System.out.println(Thread.currentThread().getName() + "：试图调用a的死锁方法，尝试获取a的对象锁");  		a.dlA();	}		public synchronized void dlB(){		System.out.println(Thread.currentThread()+"current");	}}public class DeadLock implements Runnable{	A a=new A();	B b=new B();		public void init() {		Thread.currentThread().setName("主线程");		try {			a.waitB(b);		} catch (InterruptedException e) {			e.printStackTrace();		}	}		public static void main(String[] args) {		DeadLock dl=new DeadLock();		Thread t=new Thread(dl);		t.start();		dl.init();	}	@Override	public void run() {		Thread.currentThread().setName("副线程");				try {			b.waitA(a);		} catch (InterruptedException e) {			// TODO Auto-generated catch block			e.printStackTrace();		}					}}程序中，来个线程，主线程先执行a对象的waitB方法，进入sleep，副线程以非常小的时间差距进入waitA方法，也进入sleep，这个时候主线程sleep结束之后想要调用B类的加锁方法，但是这个时候副线程正持有b对象，需要等副线程的waitA方法执行完毕释放锁，但是副线程sleep结束后也会去想要获取正在被主线程持有的a对象的锁，所以这个时候两边都在等待对面释放锁，以至于发生了死锁。]]></content>
      <categories>
        
      </categories>
      <tags>
        
          <tag> javase </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Socket编程]]></title>
      <url>/2017/06/02/socket/</url>
      <content type="text"><![CDATA[Socketsocket起源于UNIX，在Unix一切皆文件哲学的思想下，socket是一种”打开—读/写—关闭”模式的实现，服务器和客户端各自维护一个”文件”，在建立连接打开后，可以向自己文件写入内容供对方读取或者读取对方内容，通讯结束时关闭文件。  http://www.cnblogs.com/dolphinX/p/3460545.html使用tcp协议通讯的socket交互流程：从服务端开始首先创建服务端的ServerSocket,构造函数最多可接受3个参数 ServerSocket(int port, int backlog, InetAddress bindAddr)，依次为绑定的端口、对连接的请求队列最大长度、指定服务器绑定打ip地址。默认baklog为50，bindAddr为null。在ServerSocket类中可以看到上图中打一些关键字，在源码中可以看到如果在构造ServerSocket时给定类端口，则会自动绑定并且监听端口。//服务端ServerSocket ss=new ServerSocket(5858);监听之后需要接受来自客户端打请求使用accept()进行接收，accept()函数会阻塞当前线程直到连接建立，返回一个Socket对象。ss.accpet();之后就可以对于这个返回打Socket对象进行读写操作了。//读取客户端发送打数据，这里给定字符编码，防止中文乱码，socket就是之前accept函数返回打socket。BufferedReader br=new BufferedReader(new InputStreamReader(socket.getInputStream(), "UTF-8"));System.out.println(br.readLine());//发送给客户端数据，PrintWriter打boolean值表示是否自动flush。PrintWriter out = new PrintWriter(new OutputStreamWriter(socket.getOutputStream(), "UTF-8"), true);out.println("say something to client.");读写操作完毕后记得关闭相关资源，调用close方法。这里服务端基本完成，这样可以实现单客户端进行交互，如果需要实现多客户端则需要借助线程的知识，可以参考最下面打demo。接下来时客户端部分，客户端部分：客户端部分也是需要先创建Socket//接收两个参数，第一个为服务器ip地址，第二个为相应服务端监听的端口号Socket s=new Socket("127.0.0.1",5858);构造函数的注释表明构造函数会创建Socket并且连接到指定打端口，所以之后可以向服务端发送数据了。 PrintWriter pw=new PrintWriter(new OutputStreamWriter(s.getOutputStream(),"UTF-8"),true); pw.println("hello,I`m client.");如果连接顺利则服务端将会收到数据。结束后使用close()函数进行关闭操作。这样一个简单的socket交互程序，就完成了，但是并没有什么好玩的，很无聊。那我们要实现一个比较有趣的，好用的程序应该怎么改造呢？先从客户端改造起，前面我们的客户端只能发送固定打字符串，写死了在程序中，希望能够自定义想发什么发什么，那就用熟悉的Scanner吧！那么问题来了，输入之后回车发送，只能发送一次？好办，套个循环，ok，现在实现类自定义向服务端发送数据了，但是只有客户端自嗨也不行啊，需要服务端的反馈啊。有道理那么我们套了循环之后一直是输入状态，这样不行吧，所以需要一个线程，专门来听服务端的反馈。这样就比较完善了。服务端需要也可以弄相应的变换。那如果想要实现多客户端群聊那种怎么实现呢？需要进行多次的accept，好办，套个循环就解决了。那accept会阻塞当前线程，也好办把返回打客户端打socket放进线程里去操作，然后把客户端的socket用一个list进行管理，接受到一个就add()关闭就remove()。整体就完成了。以下是详细的代码。简单多人在线聊天程序demo@SimpleServer.javaimport java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.io.OutputStreamWriter;import java.io.PrintWriter;import java.net.ServerSocket;import java.net.Socket;import java.net.SocketException;import java.util.ArrayList;import java.util.List;public class SimpleServer {    //把客户端的socket放入List进行管理    private static List&lt;ServerThread&gt; clients;        public static void main(String[] args) {        clients=new ArrayList&lt;ServerThread&gt;();        new SimpleServer().startService();    }    /**     * 启动监听服务。     */    public void startService() {        ServerSocket ss = null;        Socket s=null;        try {            ss = new ServerSocket(5858);            //持续的接受客户端连接，接收到新的连接后产生新的客户端线程。            while(true){                s = ss.accept();                System.out.println("已建立连接");                ServerThread st=new ServerThread(s);                new Thread(st).start();            }        } catch (IOException e) {            System.out.println("Done.");        } finally {            try {                if (ss != null)                    ss.close();            } catch (IOException e) {                e.printStackTrace();            }        }    }    //客户端的线程    class ServerThread implements Runnable {        private PrintWriter out = null;        private Socket socket = null;        private String name = null;        private boolean flag = true;        private BufferedReader br = null;        public ServerThread(Socket s) {            this.socket = s;            try {                out = new PrintWriter(new OutputStreamWriter(socket.getOutputStream(), "UTF-8"), true);                br = new BufferedReader(new InputStreamReader(socket.getInputStream(), "UTF-8"));                //name = socket.getInetAddress()+":"+socket.getPort();                name=br.readLine(); //初次连接到服务端，客户端发送的数据当作客户端用户名            } catch (IOException e) {                e.printStackTrace();            }            //向已经连接客户端分发信息            send(name + " has connected.");            clients.add(this);        }        /**         * 线程不停的接收客户端发送过来的数据，直到客户端断开连接         */        @Override        public void run() {            try {                while (true) {                    if (!flag)                        break;                    receive();                }            }catch(SocketException e){                stop();            }catch (IOException e) {                e.printStackTrace();            }finally{                try{                    if(socket!=null)                        socket.close();                }catch(IOException ie){                    ie.printStackTrace();                }            }        }        /**         * 向已经连接的客户端分发信息         * @param msg 向客户端发送的信息         */        public void send(String msg) {            boolean isprivate=false;            String deliverTo=null;            //这里实现时私信功能，@+另一个客户端名 可以只向指定客户端发送消息。            if(msg.startsWith("@")){                System.out.println("private");                isprivate=true;                deliverTo=msg.split("@")[1];            }            //遍历所有已连接客户端            for (ServerThread st : clients) {                if(!isprivate){                    st.out.println("["+name+"]:"+msg);                }else{                    //String tmp=st.socket.getInetAddress()+":"+st.socket.getPort();                    System.out.println("N+"+st.name);                    System.out.println("D+"+deliverTo);                    if(deliverTo.equals(st.name))                        st.out.println(msg);                }            }        }        /**         * 接收客户端发送的消息，分发到其他客户端，直到客户端发送quit字符串，则注销掉相应客户端。         * @throws IOException         */        public void receive() throws IOException{            String str = null;            while ((str = br.readLine()) != null) {                System.out.println(str);                send(str);                if (str.equals("quit")) {                    stop();                    break;                }            }        }        /**         * 表示结束当前客户端线程的连接。         */        public void stop() {            clients.remove(this);            flag = false;            send("[" + name + "] has left the chatroom.");        }    }}@SimpleClient.javaimport java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.io.OutputStreamWriter;import java.io.PrintWriter;import java.net.Socket;import java.util.Scanner;public class SimpleClient {    public static void main(String[] args) {        Socket s=null;        PrintWriter pw=null;        try{            //创建socket            s=new Socket("127.0.0.1",5858);            pw=new PrintWriter(new OutputStreamWriter(s.getOutputStream(),"UTF-8"),true);            new Thread(new ClientThread(s)).start();            //如果有程序参数则用来当用户名，也可以在程序中输入实现。            if(args.length&gt;=1)                pw.println(args[0]);            else                pw.println("lin"); //默认用户名            //开始输入，发送信息            while(true){                String str=new Scanner(System.in).nextLine();                pw.println(str);                if(str.equals("quit"))                    break;            }        }catch(IOException e){            System.out.println("disconnected");            //e.printStackTrace();        }finally{            try{                if(s!=null)                    s.close();            }catch(IOException ie){                ie.printStackTrace();            }        }    }}class ClientThread implements Runnable{    private Socket s=null;    ClientThread(Socket s){        this.s=s;    }    /**     * 接收从服务端发送回来的信息。     */    @Override    public void run(){        BufferedReader br=null;        String str=null;        try {            br=new BufferedReader(new InputStreamReader(s.getInputStream(),"UTF-8"));            while((str=br.readLine())!=null){                System.out.println(str);            }        }  catch (IOException e) {            System.out.println("Has left the chatroom.");        }    }}]]></content>
      <categories>
        
      </categories>
      <tags>
        
          <tag> socket </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[JDBC编程]]></title>
      <url>/2017/06/02/jdbc/</url>
      <content type="text"><![CDATA[数据库JDBCjdbc连接数据库主要有4步。      利用反射加载驱动    这一步在一些高版本的jdk中如6.0以上不是必要的，因为mysql的驱动程序jar包中已经包含了java.sql.Driver配置文件，并在文件中添加了com.mysql.jdbc.Driver.但在JDK6之前版本，还是要调用这个方法。          关于Class.forName(“com.mysql.jdbc.Driver”) http://www.cnblogs.com/gaojing/archive/2012/03/23/2413638.html            获取连接    使用     DriverManager.getConnection(JDBC_URL,USER_NAME,USER_PASSWORD);        获取数据库连接，接受的参数分别为相应数据库的jdbc的url，如这里是mysql则为 “jdbc:mysql://localhost:3306/dbname?characterEncoding=utf-8”，oracle和slqserver的可以自行百度。localhost：主机地址 3306为端口，mysql默认是3306，dbname就是数据库的名字，后面为了避免乱码可以加一些参数如这里把字符编码设置成了utf-8.        进行操作    获取连接后就可以进行数据库相关操作了。    首先创建一个Statement对象，通过Connection对象的createStatement()获取Statement。    之后就可以使用Statement对象的executeQuery()或者executeUpdate()方法进行执行sql，这里这2个函数接收一个字符串参数即为要运行的sql。    executeQuery专门用来进行查询操作，接收String类型的参数作为运行的sql语句，返回一个ResultSet对象，用来返回查询结果，executeUpdate专门用来执行更新操作，接收String类型的参数作为运行的sql，返回int类型，值为该操作影响了的数据的行数。    获取的结果可以放入容器中返回。          在下面的util中使用了Statement，另外还可以使用PreparedStatement，PreparedStatement相对于Statement来说更加安全一些，因为使用Statement传入的字符串sql就是我们正常使用的sql，容易在字符串后面拼接上一些条件，造成sql注入，造成数据泄露。而PreparedStatement传入的sql形式是”select u_id,u_name from user where u_id=?”这样的类型，数据位置由’？’来占位，后续使用PreparedStatement对象的setObject（或者对应类型的set方法）进行替换，setObject接收2个参数第一个为占位符的下标（从1开始），第二个为set的对应的值。这样sql的模板就已经基本固定可以操作的空间比较少，可以防sql注入。            关闭相关资源    操作完需要对数据库相关资源进行释放。如果数据量大的情况下，如果不关闭会造成内存溢出。          不关闭相关资源的实验 http://tomenjoy.iteye.com/blog/311350      jdbc工具类Statement版本import java.sql.*;import java.util.*;/** * Created by pad on 17-4-22. * DBUtil provide doQuery(String sql) and doUpdate(String sql) method to manipulate DB operation. */public class DBUtil {    private static final String JDBC_URL="jdbc:mysql://localhost:3306/StudyItMSDB?characterEncoding=utf-8";    private static final String USER_NAME="root";    private static final String USER_PASSWORD="123";    private static final String DRIVER_URL="com.mysql.jdbc.Driver";    /**     * get connection to the database.     */    private static Connection getConnection(){        Connection conn=null;        try{            Class.forName(DRIVER_URL);            conn= DriverManager.getConnection(JDBC_URL,USER_NAME,USER_PASSWORD);        }catch (Exception e){            e.printStackTrace();        }        return conn;    }    /**     * get Result of query.     * @param sql:the sql to execute on db.     * @return:the List of the query result.     */    public static List&lt;Map&lt;String,Object&gt;&gt; doQuery(String sql){        List&lt;Map&lt;String,Object&gt;&gt; result=new ArrayList&lt;Map&lt;String,Object&gt;&gt;();        Connection conn=getConnection();        if (conn==null)        {            return null;        }        //For Debug        System.out.println(sql);                Statement st=null;        ResultSet rs=null;        try {            st=conn.createStatement();            rs=st.executeQuery(sql);            ResultSetMetaData rsmd=rs.getMetaData();            int columnCount=rsmd.getColumnCount();            while(rs.next()){                Map&lt;String,Object&gt; rsTree=new HashMap&lt;String,Object&gt;();                for(int i=1;i&lt;=columnCount;i++){                    rsTree.put(rsmd.getColumnName(i),rs.getObject(i));                }                result.add(rsTree);            }        }catch(SQLException e){            e.printStackTrace();        }finally {            close(conn,st,rs);        }        return result;    }    /**     * do update on db.     * @param sql:the sql to execute on db.     * @return:the number of rows the update affects.     */    public static int doUpdate(String sql){        int affectRows=0;        Connection conn=getConnection();        if (conn==null)        {            return 0;        }        Statement st=null;        try {            //For Debug            System.out.println(sql);            st=conn.createStatement();            affectRows=st.executeUpdate(sql);        }catch(SQLException e){            e.printStackTrace();        }finally {            close(conn,st,null);        }        return affectRows;    }    /**	 * close the db source.	 */    private static void close(Connection conn,Statement st,ResultSet rs){        try{            if(conn!=null)                conn.close();            if(st!=null)                st.close();            if(rs!=null)                rs.close();        }catch(SQLException e){            System.out.println("Error in close resource.");            e.printStackTrace();        }    }}PreparedStatement版本package com.pad.util;import java.sql.*;import java.util.*;/** * Created by pad on 17-6-02. * PREDBUtil provide doQuery(String sql,Object...args) and doUpdate(String sql,Object...args) method to manipulate DB operation. * sql template："select col_name from tablename where col_name=?" */public class PREDBUtil {    private static final String JDBC_URL="jdbc:mysql://localhost:3306/StudyItMSDB?characterEncoding=utf-8";    private static final String USER_NAME="root";    private static final String USER_PASSWORD="123";    private static final String DRIVER_URL="com.mysql.jdbc.Driver";    /**     * get connection to the database.     */    private static Connection getConnection(){        Connection conn=null;        try{            Class.forName(DRIVER_URL);            conn= DriverManager.getConnection(JDBC_URL,USER_NAME,USER_PASSWORD);        }catch (Exception e){            e.printStackTrace();        }        return conn;    }    /**     * get Result of query.     * @param sql:the sql to execute on db.     * @return:the List of the query result.     */    public static List&lt;Map&lt;String,Object&gt;&gt; doQuery(String sql,Object...args ){        List&lt;Map&lt;String,Object&gt;&gt; result=new ArrayList&lt;Map&lt;String,Object&gt;&gt;();        Connection conn=getConnection();        if (conn==null)        {            return null;        }        //For Debug        System.out.println(sql);                PreparedStatement st=null;        ResultSet rs=null;        try {            st=conn.prepareStatement(sql);            int index=1;            //set the sql argument            for(Object obj:args){            	st.setObject(index++, obj);            }            rs=st.executeQuery();                        ResultSetMetaData rsmd=rs.getMetaData();            int columnCount=rsmd.getColumnCount();            while(rs.next()){                Map&lt;String,Object&gt; rsTree=new HashMap&lt;String,Object&gt;();                for(int i=1;i&lt;=columnCount;i++){                    rsTree.put(rsmd.getColumnName(i),rs.getObject(i));                }                result.add(rsTree);            }        }catch(SQLException e){            e.printStackTrace();        }finally {            close(conn,st,rs);        }        return result;    }    /**     * do update on db.     * @param sql:the sql to execute on db.     * @return:the number of rows the update affects.     */    public static int doUpdate(String sql,Object...args){        int affectRows=0;        Connection conn=getConnection();        if (conn==null)        {            return 0;        }        PreparedStatement st=null;        try {            //For Debug            System.out.println(sql);            st=conn.prepareStatement(sql);            int index=1;            //set the sql argument            for(Object obj:args){            	st.setObject(index++, obj);            }                        affectRows=st.executeUpdate();        }catch(SQLException e){            e.printStackTrace();        }finally {            close(conn,st,null);        }        return affectRows;    }    /**	 * close the db source.	 */    private static void close(Connection conn,Statement st,ResultSet rs){        try{            if(conn!=null)                conn.close();            if(st!=null)                st.close();            if(rs!=null)                rs.close();        }catch(SQLException e){            System.out.println("Error in close resource.");            e.printStackTrace();        }    }}]]></content>
      <categories>
        
      </categories>
      <tags>
        
          <tag> 数据库 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[JavaSE-Exception]]></title>
      <url>/2017/06/02/Exception/</url>
      <content type="text"><![CDATA[Exception所有异常的根为java.lang.Throwable。Throwable下分Error和Exception。这里我们讨论是的Exception。Error是当程序发生不可控的错误时，通常通知用户并且中断程序执行。Error是java虚拟机生成并抛出，程序不对其进行处理。Exception总共来说分2种，一种是RuntimeException，其他类型都统称编译时异常。编译时异常编译时异常一般是在编译的时候编译器提示的异常也叫Checked异常。发生了这种异常则编译就不会进行下去。Java的设计哲学：没有完善错误处理的代码根本没有机会被执行。  http://blog.csdn.net/woshixuye/article/details/8230407常见的编译时异常有：  Java.lang.ClassNotFoundException  Java.lang.NoSuchMetodException  java.io.IOExceptionRuntimeException运行时异常为程序运行时发生的异常常见的有：  IndexOutOfBoundsException 数组下标越界异常  ArithmeticException	算数异常比如除零时  NullPointerException 空指针异常  NumberFormatException 数值转换异常  java.io.FileNotFoundException 文件未找到异常的处理对于异常一般来说要么使用try..cathch进行捕获并处理，或者直接使用throws进行抛出到下一层，让下一层的人处理。常见格式:try{	int a=1/0;}catch(Exception e){	e.printStackTrace();}finally{}//catch可以有多个try{	int a=1/0;}catch(ArithmeticException e){	e.printStackTrace();}catch(Exception e){	...}finally{}try和catch必须是一起出现，finally则不是必须的，catch可以有多个，如果有多个catch则其中的异常大小应该是范围比较小的在前面，范围大的在后面，如例子中ArithmeticException是在Exception的范围内，所以这样如果发生算数异常则捕获算数异常，运行第一个catch中的语句块，否则如果范围大的在前面那么总是不会运行到后面范围小的catch，这样不利于精确定位错误。finally语句块主要是为了抛出异常时进行资源的回收和销毁，如数据库操作时，因为某些原因执行到中间发生异常，这个时候会中断程序，也就可能不会运行到关闭数据库连接的语句块。为了避免这种情况就使用finally语句块，finally块中的语句保证会执行。  如果finally中有return值，而catch块中也有return的值，那么最终返回的是finally中return的值。自定义异常如果觉得系统给定的异常不能够满足需求，想要自定义异常，可以继承Exception类，可以定义一个字符串类型的参数，给父类，最终是在Throwable类中的一个属性detailMessage，detailMessage在打印出异常时被打印，起到精确提示作用。class MyException extends Exception{	public MyException(String msg) {		super(msg);	}}]]></content>
      <categories>
        
      </categories>
      <tags>
        
          <tag> JavaSE </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[抽象类和接口]]></title>
      <url>/2017/06/02/AbstractClassAndInterface/</url>
      <content type="text"><![CDATA[抽象类和接口作为实现多态的，抽象类抽象类使用关键字abstract进行修饰abstract class Base{	int num=0;    abstract void absTest();    void normalTest(){    }}抽象方法的修饰符只能是protected及更高开放性的修饰符。抽象类可以有非抽象方法，但是有抽象方法的类必须要是抽象类。接口接口对于对象来说是能力，通过实现接口获取能力。对于方法来说是一种标准，符合标准的对象就可以进入方法。为什么使用接口：  扩展对象的形态，让对象具有更多的能力，加强程序扩展性，实现了一种java的多继承。  对方法接口是一种标准，满足标准的对象可以进入方法（作为参数传入）。例子    interface IA{ int num=0; void say();}class ImpIA1 implements IA{ int num=1; @Override public void say() {     System.out.println("Imp111"); }}public class TestPlantForm { public static void main(String[] args) {     runImp(new ImpIA1()); } public static void runImp(IA ia){     ia.say(); }}        接口中的访问修饰符默认是public的，并且不能修改为其他，接口中属性默认修饰符为public static final.因为接口声明出来就是为了给其他类实现的。方法默认是public abstract的。  与抽象类不同的是接口中不能有普通方法，只能有抽象方法。]]></content>
      <categories>
        
      </categories>
      <tags>
        
          <tag> JavaSE </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[JavaSE面向对象]]></title>
      <url>/2017/06/01/JavaSE%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
      <content type="text"><![CDATA[JavaSE面向对象java之父曾经说过：万物皆对象。java语言就是在这个理念上的语言，所有类默认都是继承自Object。类和对象：高级语言使用类这种单元管理数据面向对象有三种特性：  封装  继承  多态封装用访问修饰符实现访问权限表：|	|本类|同包|继承|所有||–	|–	 |– |–  |– ||public|√|√	 |√	  |√||protected|√|√|√  |×||default|√|√ |×   |×||private|√|× |×   |×|	为什么要封装？    隐藏实现的细节，对外提供公共的方法，优点是增加代码的可维护性，数据的安全性。继承从一个类中派生出新类，子类具有父类的一般特性及自身的特殊特性。java中不允许多继承。但是由于单继承的扩展性较差，所以可以通过实现接口来实现多继承。用处：实现了抽象，增加了代码的可复用性。由于Object是所有对象的最上层父类，所以都拥有它的一些方法  equals() 用来比较对象是否相等，在Object类中是由==实现的，即比较两个对象地址是否相等，在String类中被重写成判断字符串中内容是否相等。一些场合下可以根据需求重写equals方法，但是如果在HashMap中用来作为key则需要更加彻底的重写HashCode()方法。  hashCode() 返回一串hash code代表对象在内存中的地址，用来表示对象的地址看源码的时候发现只有一个方法的声明，没有具体实现，原来是使用native关键字调用的非java代码方法。  notify()和notifyAll() 唤醒等待中的线程，第一个是唤醒单个，第二个是唤醒所有等待这个对象的monitor的线程。  toString() 打印对象名+16进制的代表对象地址的hashCode。可以用 instanceof来判断对象是否是某个类型或者属于他的子类型的对象。如果是则返回true，否则为false。例：if(obj instanceof Object)  注：程序中类关系结构越复杂，性能越低下。  如果在子类的构造函数中显示调用父类的构造函数super()则必须是在子类构造函数的第一行。  super不是一个指向对象的引用，只是一个特殊的关键字，告诉编译器需要调用父类  super和this都不能用在 static块中。原因是类初始化的顺序为: 	 父类&gt;子类&gt;静态属性&gt;静态代码块&gt;静态方法&gt;普通属性&gt;普通方法多态同一个实现接口，使用不同的实例执行不同的操作。多态分为运行时多态（方法的重写）以及编译时多态（方法的重载）。编译时多态指的是在编译时根据参数类型进行调用对应的方法，生成对应代码。运行时多态则在运行时取决于方法的调用对象来进行动态调用方法。表现方式：使用父类的引用，调用子类的对象。或者接口引用实现类的对象体现：父类（接口）统一管理行为，在方法中不注重实例的具体行为，直接调用父类的统一行为，由重写来调用实现对象的多态。  父类中的static修饰的方法不能被覆盖。例：interface IA{	int num=0;	void say();}abstract class Base{	int num=0;	abstract void say();}class A extends Base{	int num=1;	void say(){		System.out.println("in A class");	}}class B extends Base{	int num=2;	void say(){		System.out.println("in B class");	}}class ImpIA1 implements IA{	int num=1;	@Override	public void say() {		System.out.println("Imp111");	}}class ImpIA2 implements IA{	int num=2;	@Override	public void say() {		System.out.println("Imp222");	}}public class TestPlantForm {	public static void main(String[] args) {		//接口方式		runImp(new ImpIA1());		runImp(new ImpIA2());		//继承类方式		runClass(new A());		runClass(new B());	}		public static void runImp(IA ia){		ia.say();		System.out.println(ia.num);	}	public static void runClass(Base base){		base.say();		System.out.println(base.num);	}}动态多态是对于方法的概念，对于属性并不使用，如果运行上面的例子，会发现输出的num值都为父类或者接口中的属性值。  在重写父类方法时需要注意      子类中的访问修饰符权限要大于等于父类中的权限。    重写方法的返回值可以是父类方法返回值的子类（或者实现的接口的实现类）    重写和重载区别：      重载不覆盖重载对象的方法，函数名需要相同，返回值可以不同，参数列表需要不同。调用时根据参数调用相应方法    重写需要方法名相同，参数名和返回值也相同或者关系为父子类或者接口与实现类的关系，会覆盖父类方法。调用时根据调用的对象进行调用。  ]]></content>
      <categories>
        
      </categories>
      <tags>
        
          <tag> JavaSE </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[FreeMarker]]></title>
      <url>/2017/05/25/Freemarker/</url>
      <content type="text"><![CDATA[FreeMarker官网 http://freemarker.org通过模板对java对象数据进行解析，生成html模板 + 数据模型 = 输出freemarker通过一个类似Map的数据结构进行一一对应。maven依赖&lt;dependency&gt;	&lt;groupId&gt;org.freemarker&lt;/groupId&gt;    &lt;artifactId&gt;freemarker&lt;/artifactId&gt;    &lt;version&gt;2.3.20&lt;/version&gt;&lt;/dependency&gt;SpringMVC+freemarker简单应用demospringmvc配置文件中配置FreeMarkerViewResolver	&lt;bean id="viewResolver" class="org.springframework.web.servlet.view.freemarker.FreeMarkerViewResolver"&gt;        &lt;property name="suffix"&gt;            &lt;value&gt;.ftl&lt;/value&gt;        &lt;/property&gt;        &lt;property name="contentType" value="text/html;charset=UTF-8"&gt;&lt;/property&gt;    &lt;/bean&gt;  这里如果使用多种视图混合使用，比如jsp和freemarker混合使用，则需要在bean中设置order属性，用来设置resolver的优先级，否则只有一个视图会生效，默认的优先级为比较大的一个数，数字越小优先级越高。spring中配置FreeMarkerConfigurer	&lt;bean id="freemarkerConfig" class="org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer"&gt;        &lt;property name="templateLoaderPath" value="/WEB-INF/template/"/&gt;        &lt;property name="freemarkerSettings"&gt;            &lt;props&gt;                &lt;prop key="template_update_delay"&gt;0&lt;/prop&gt;                &lt;prop key="default_encoding"&gt;UTF-8&lt;/prop&gt;                &lt;prop key="number_format"&gt;0.##########&lt;/prop&gt;                &lt;prop key="datetime_format"&gt;yyyy-MM-dd HH:mm:ss&lt;/prop&gt;                &lt;prop key="classic_compatible"&gt;true&lt;/prop&gt;                &lt;prop key="template_exception_handler"&gt;ignore&lt;/prop&gt;            &lt;/props&gt;        &lt;/property&gt;    &lt;/bean&gt;测试页面模板@Test.ftl&lt;html&gt;&lt;head&gt;    &lt;title&gt;Welcome!&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Welcome ${name}!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;controll层对应请求	@RequestMapping("/testFM1")    public ModelAndView testFM1(HttpServletRequest request, HttpServletResponse response){        ModelAndView mv=new ModelAndView("test");        mv.addObject("name","pad123");        return mv;    }]]></content>
      <categories>
        
      </categories>
      <tags>
        
          <tag> FreeMarker </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[SSM整合]]></title>
      <url>/2017/05/22/SSM%E6%A1%86%E6%9E%B6%E7%9A%84%E6%95%B4%E5%90%88/</url>
      <content type="text"><![CDATA[SSM整合整合的目的：将Mybatis的SqlSessionFactory，和事务交给Spring管理。	至于spring和springmvc本身就是一体的。  参考 http://blog.csdn.net/qq598535550/article/details/51703190SpringMVC的配置编写spring-mvc.xml&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans"       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"       xmlns:mvc="http://www.springframework.org/schema/mvc"       xmlns:context="http://www.springframework.org/schema/context"       xsi:schemaLocation="http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd       http://www.springframework.org/schema/mvc       http://www.springframework.org/schema/mvc/spring-mvc-3.0.xsd       http://www.springframework.org/schema/context       http://www.springframework.org/schema/context/spring-context.xsd"&gt;    &lt;mvc:annotation-driven/&gt;    &lt;context:component-scan base-package="com.pad.controll"/&gt;    &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt;        &lt;property name="viewClass" value="org.springframework.web.servlet.view.JstlView"/&gt;        &lt;property name="prefix" value="/WEB-INF/jsp/"/&gt;        &lt;property name="suffix" value=".jsp"/&gt;    &lt;/bean&gt;&lt;/beans&gt;在web.xml中配置springmvc的servlet&lt;!DOCTYPE web-app PUBLIC "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN" "http://java.sun.com/dtd/web-app_2_3.dtd" &gt;&lt;web-app&gt;  &lt;servlet&gt;    &lt;servlet-name&gt;seckill-dispatcher&lt;/servlet-name&gt;    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;    &lt;init-param&gt;      &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;      &lt;param-value&gt;classpath:spring-*.xml&lt;/param-value&gt;    &lt;/init-param&gt;    &lt;!--不加也可以运行，但是加了之后第一次访问网站加载会快一些--&gt;    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;    &lt;/servlet&gt;  &lt;servlet-mapping&gt;    &lt;servlet-name&gt;seckill-dispatcher&lt;/servlet-name&gt;    &lt;url-pattern&gt;/&lt;/url-pattern&gt;  &lt;/servlet-mapping&gt;&lt;/web-app&gt;编写controller层代码package com.pad.controll;import com.pad.service.TestService;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import javax.annotation.Resource;/** * Created by pad on 17-5-21. */@Controllerpublic class testCtrl {	//这里service是交给spring自动注入    @Resource    TestService testService;    @RequestMapping("/test")    public String test1(){        System.out.println(testService.test());        return "test";    }}配置Spring和Mybatis这里提取出数据库相关参数@datasource.propertiesjdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/ssm?useUnicode=true&amp;characterEncoding=utf-8jdbc.username=rootjdbc.password=123mybatis相关设置放在mybatis-conf.xml中&lt;?xml version="1.0" encoding="utf-8" ?&gt;&lt;!DOCTYPE configuration        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"        "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt;    &lt;!-- 配置全局属性 --&gt;    &lt;settings&gt;        &lt;!-- 使用jdbc的getGeneratedKeys获取数据库自增主键值 --&gt;        &lt;setting name="useGeneratedKeys" value="true" /&gt;        &lt;!-- 使用列别名替换列名 默认:true --&gt;        &lt;setting name="useColumnLabel" value="true" /&gt;        &lt;!-- 开启驼峰命名转换:Table{create_time} -&gt; Entity{createTime} --&gt;        &lt;!--&lt;setting name="mapUnderscoreToCamelCase" value="true" /&gt;--&gt;        &lt;!--显示sql--&gt;        &lt;setting name="logImpl" value="STDOUT_LOGGING" /&gt;    &lt;/settings&gt;&lt;/configuration&gt;在spring-context.xml中配置sqlSessionFactory的bean，以及配置事务管理器。@spring-context.xml&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans"       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"       xmlns:context="http://www.springframework.org/schema/context"       xmlns:tx="http://www.springframework.org/schema/tx"       xsi:schemaLocation="http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd       http://www.springframework.org/schema/context        http://www.springframework.org/schema/context/spring-context.xsd        http://www.springframework.org/schema/tx        http://www.springframework.org/schema/tx/spring-tx.xsd"&gt;    &lt;!--自动扫描注入--&gt;    &lt;context:annotation-config/&gt;    &lt;context:component-scan base-package="com.pad"/&gt;    &lt;!--引入数据库相关设置参数--&gt;    &lt;context:property-placeholder location="classpath:datasource.properties"/&gt;    &lt;bean name="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt;        &lt;property name="driverClass" value="${jdbc.driver}"/&gt;        &lt;property name="jdbcUrl" value="${jdbc.url}"/&gt;        &lt;property name="user" value="${jdbc.username}"/&gt;        &lt;property name="password" value="${jdbc.password}"/&gt;        &lt;!-- c3p0连接池的私有属性 --&gt;        &lt;property name="maxPoolSize" value="30" /&gt;        &lt;property name="minPoolSize" value="10" /&gt;        &lt;!-- 关闭连接后不自动commit --&gt;        &lt;property name="autoCommitOnClose" value="false" /&gt;        &lt;!-- 获取连接超时时间 --&gt;        &lt;property name="checkoutTimeout" value="10000" /&gt;        &lt;!-- 当获取连接失败重试次数 --&gt;        &lt;property name="acquireRetryAttempts" value="2" /&gt;    &lt;/bean&gt;    &lt;bean name="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt;        &lt;property name="dataSource" ref="dataSource"/&gt;        &lt;property name="configLocation" value="classpath:mybatis-conf.xml"/&gt;        &lt;property name="mapperLocations" value="classpath:mapper/*.xml"/&gt;        &lt;property name="typeAliasesPackage" value="classpath:com.pad.entity"/&gt;    &lt;/bean&gt;    &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt;        &lt;property name="sqlSessionFactoryBeanName" value="sqlSessionFactory"/&gt;        &lt;property name="basePackage" value="com.pad.dao"/&gt;    &lt;/bean&gt;    &lt;!--配置事务--&gt;    &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt;        &lt;property name="dataSource" ref="dataSource"/&gt;    &lt;/bean&gt;    &lt;!--开启事务的注解功能--&gt;    &lt;tx:annotation-driven transaction-manager="transactionManager"/&gt;&lt;/beans&gt;编写实体类@Person.javapackage com.pad.entity;public class Person {    private int p_id;    private String p_name;    public int getP_id() {        return p_id;    }    public void setP_id(int p_id) {        this.p_id = p_id;    }    public String getP_name() {        return p_name;    }    public void setP_name(String p_name) {        this.p_name = p_name;    }}编写对应的映射文件@personMapper.xml&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"        "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;!--命名空间可以自定义，但是习惯上是包名+映射文件名，可以保证唯一--&gt;&lt;mapper namespace="com.pad.dao.TestDao"&gt;    &lt;!--依次为指定id到时候调用，指定参数类型（这里p_id为int所以是int），指定返回类型，这里返回的是User类--&gt;    &lt;select id="queryById" parameterType="int"  resultType="com.pad.entity.Person"&gt;        select p_id,p_name from Person where p_id=#{p_id};    &lt;/select&gt;    &lt;insert id="addPerson" parameterType="com.pad.entity.Person"&gt;        insert into person(p_name) values(#{p_name});    &lt;/insert&gt;    &lt;!--&lt;delete id="deletePerson" parameterType="int"&gt;--&gt;        &lt;!--delete from Person where p_id=#{u_id}--&gt;    &lt;!--&lt;/delete&gt;--&gt;    &lt;!--&lt;update id="updatePerson" parameterType="com.pad.entity.Person"&gt;--&gt;        &lt;!--update user set p_name=#{p_name} where p_id=#{p_id}--&gt;    &lt;!--&lt;/update&gt;--&gt;&lt;/mapper&gt;编写dao层接口@TestDao.javapackage com.pad.dao;import com.pad.entity.Person;import org.apache.ibatis.annotations.Param;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.springframework.stereotype.Repository;import org.springframework.stereotype.Service;import javax.annotation.Resource;@Repositorypublic interface TestDao {    //这里的Param注解在只有一个参数时不需要，但是在多个参数时起到标识的作用    Person queryById(@Param("p_id")int p_id);    int addPerson(@Param("p_name")String p_name);}编写service层调用@TestServicepackage com.pad.service;import com.pad.dao.TestDao;import com.pad.entity.Person;import org.junit.Test;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;import javax.annotation.Resource;@Servicepublic class TestService {    @Resource    private TestDao testDao;	    @Transactional	//事务注解使用后托管事务    public boolean test(){        System.out.println(testDao.addPerson("test"));        Person p=testDao.queryById(2);        System.out.println(p.getP_name());        return true;    }}到此就整合完毕了。完整项目https://github.com/Padcn/SSMIntegrationpom.xml&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;com,pad.ssmIntegration&lt;/groupId&gt;    &lt;artifactId&gt;ssmIntegration-model&lt;/artifactId&gt;    &lt;packaging&gt;war&lt;/packaging&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;name&gt;ssmIntegration-model Maven Webapp&lt;/name&gt;    &lt;url&gt;http://maven.apache.org&lt;/url&gt;    &lt;properties&gt;        &lt;!-- springframe 版本控制 --&gt;        &lt;spring.version&gt;4.2.4.RELEASE&lt;/spring.version&gt;    &lt;/properties&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;junit&lt;/groupId&gt;            &lt;artifactId&gt;junit&lt;/artifactId&gt;            &lt;version&gt;3.8.1&lt;/version&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;        &lt;!-- 3.Servlet web --&gt;        &lt;dependency&gt;            &lt;groupId&gt;taglibs&lt;/groupId&gt;            &lt;artifactId&gt;standard&lt;/artifactId&gt;            &lt;version&gt;1.1.2&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;jstl&lt;/groupId&gt;            &lt;artifactId&gt;jstl&lt;/artifactId&gt;            &lt;version&gt;1.2&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;            &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;            &lt;version&gt;2.5.4&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;            &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;            &lt;version&gt;3.1.0&lt;/version&gt;        &lt;/dependency&gt;        &lt;!--Spring Start--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-core&lt;/artifactId&gt;            &lt;version&gt;${spring.version}&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt;            &lt;version&gt;${spring.version}&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;            &lt;version&gt;${spring.version}&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-aop&lt;/artifactId&gt;            &lt;version&gt;${spring.version}&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt;            &lt;version&gt;${spring.version}&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-beans&lt;/artifactId&gt;            &lt;version&gt;${spring.version}&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-web&lt;/artifactId&gt;            &lt;version&gt;${spring.version}&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;            &lt;version&gt;${spring.version}&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-tx&lt;/artifactId&gt;            &lt;version&gt;${spring.version}&lt;/version&gt;        &lt;/dependency&gt;        &lt;!--spring支持ORM的包--&gt;        &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-orm --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-orm&lt;/artifactId&gt;            &lt;version&gt;${spring.version}&lt;/version&gt;        &lt;/dependency&gt;        &lt;!--Spring end--&gt;        &lt;!-- DAO: MyBatis --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;            &lt;version&gt;3.3.0&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;            &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;            &lt;version&gt;1.2.3&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;mysql&lt;/groupId&gt;            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;            &lt;version&gt;5.1.37&lt;/version&gt;            &lt;scope&gt;runtime&lt;/scope&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.mchange&lt;/groupId&gt;            &lt;artifactId&gt;c3p0&lt;/artifactId&gt;            &lt;version&gt;0.9.5.2&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;junit&lt;/groupId&gt;            &lt;artifactId&gt;junit&lt;/artifactId&gt;            &lt;version&gt;4.12&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;    &lt;build&gt;        &lt;finalName&gt;ssmIntegration-model&lt;/finalName&gt;    &lt;/build&gt;&lt;/project&gt;]]></content>
      <categories>
        
      </categories>
      <tags>
        
          <tag> 整合 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[SSH框架整合]]></title>
      <url>/2017/05/19/SSH%E6%A1%86%E6%9E%B6%E7%9A%84%E6%95%B4%E5%90%88/</url>
      <content type="text"><![CDATA[SSH框架的整合整合的目的是让Spring来控制Hibernate的sessionFactory的创建，以及核心配置文件中数据库配置交给Spring管理。对于struts2来说是把action交给Spring管理。导入需要的依赖包这里使用maven来管理依赖以下是pom.xml文件中的依赖,见文章最下..因为有点长，影响阅读。主要注意的是maven会把资源文件都自动转移到resource文件夹下，导致hibernate映射文件找不到。所以要手动指定转移的文件。还有2个整合需要的jar包 struts-spring-plugin和spring-orm。完整项目:https://github.com/Padcn/SSHIntegration  这里我用的IDE是IDEA，如果是其他IDE请自行转换。搭建S+S+H就不多说 开始整合Struts2和Spring的整合在web.xml中加入spring的listener	&lt;context-param&gt;        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;        &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;    &lt;/context-param&gt;        &lt;listener&gt;        &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;    &lt;/listener&gt;在struts.xml中加入,其实这句好像可以不加，因为如果导入了struts2-spring-plugin的jar包，版本比较高的struts会默认使用。  &lt;constant name="struts.objectFactory" value="spring"&gt;&lt;/constant&gt;在spring中配置用注解的方式自动扫描注入。（扫描注入产生的bean，id为原类首字母小写。如TestAction产生的bean的id为testAction）。	&lt;context:annotation-config/&gt;    &lt;context:component-scan base-package="com.pad"/&gt;以下是action、service和dao@Controllerpublic class TestAction extends ActionSupport {    @Resource    private TestService testService;    public String execute(){        System.out.println(testService.test());        return SUCCESS;    }}@Servicepublic class TestService {    @Resource    private TestDao testDao;    public boolean test(){        System.out.println(testDao);        return testDao.test();    }}@Repositorypublic class TestDao {     public boolean test(){        System.out.println("in test dao");        return true;    }}运行后访问TestAction能看到输出就是配置完毕。spring整合hibernate为了比较好管理数据库的一些参数把相关信息提取出来@datasource.propertiesmysql.driverClassName=com.mysql.jdbc.Drivermysql.url=jdbc:mysql://localhost:3306/testsshmysql.username=rootmysql.password=123hibernate.dialect=org.hibernate.dialect.MySQLDialecthibernate.hbm2ddl.auto=createhibernate.show_sql=truehibernate.format_sql=true在spring的配置文件applicationContext.xml中配置数据源。  这里使用c3p0作为数据源类还可以使用BasicDataSource等,也可以直接使用	&lt;context:property-placeholder location="classpath:datasource.properties" /&gt;    &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt;        &lt;property name="driverClass" value="${mysql.driverClassName}"&gt;&lt;/property&gt;        &lt;property name="jdbcUrl" value="${mysql.url}"&gt;&lt;/property&gt;        &lt;property name="user" value="${mysql.username}"&gt;&lt;/property&gt;        &lt;property name="password" value="${mysql.password}"&gt;&lt;/property&gt;        &lt;property name="maxPoolSize" value="40"&gt;&lt;/property&gt;        &lt;property name="minPoolSize" value="1"&gt;&lt;/property&gt;        &lt;property name="initialPoolSize" value="1"&gt;&lt;/property&gt;        &lt;property name="maxIdleTime" value="20"&gt;&lt;/property&gt;    &lt;/bean&gt;配置sessionFactory的bean    &lt;bean id="sessionFactory"          class="org.springframework.orm.hibernate4.LocalSessionFactoryBean"&gt;        &lt;property name="dataSource"&gt;            &lt;ref bean="dataSource" /&gt;        &lt;/property&gt;        &lt;property name="hibernateProperties"&gt;            &lt;props&gt;                &lt;!--这里要打全，比如show_sql不写成hibernate.show_sql好像并不输出--&gt;                &lt;prop key="hibernate.show_sql"&gt;${hibernate.show_sql}&lt;/prop&gt;                &lt;prop key="hibernate.format_sql"&gt;${hibernate.format_sql}&lt;/prop&gt;                &lt;prop key="hibernate.hbm2ddl.auto"&gt;${hibernate.hbm2ddl.auto}&lt;/prop&gt;                &lt;prop key="hibernate.dialect"&gt;${hibernate.dialect}&lt;/prop&gt;            &lt;/props&gt;        &lt;/property&gt;        &lt;property name="mappingLocations" value="classpath:/com/pad/entity/*.hbm.xml"&gt;&lt;/property&gt;        &lt;!--&lt;property name="mappingResources"&gt;--&gt;            &lt;!--&lt;list&gt;--&gt;                &lt;!--&lt;value&gt;com/pad/entity/user.hbm.xml&lt;/value&gt;--&gt;            &lt;!--&lt;/list&gt;--&gt;        &lt;!--&lt;/property&gt;--&gt;    &lt;/bean&gt;到这里应该已经可以使用openSession获取session了，然后可以手动开启事务提交事务，但是不能使用getCurrentSession因为我们还没有配置事务管理器，调用getCurrentSession的话会报下面【整合中遇到的异常】中第三条。接下来配置事务管理器    &lt;!-- 配置Spring声明式事务 --&gt;    &lt;bean id="transactionManager" class="org.springframework.orm.hibernate4.HibernateTransactionManager"&gt;        &lt;property name="sessionFactory" ref="sessionFactory"&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;!-- 配置事务事务属性 --&gt;    &lt;tx:advice id="txAdvice" transaction-manager="transactionManager"&gt;        &lt;tx:attributes&gt;            &lt;tx:method name="get*" read-only="true"/&gt;            &lt;tx:method name="*"/&gt;        &lt;/tx:attributes&gt;    &lt;/tx:advice&gt;    &lt;!-- 配置事务切点，并把切点和事务属性关联起来 --&gt;    &lt;aop:config&gt;        &lt;aop:pointcut expression="execution(* com.pad.dao.*.*(..))" id="txPointcut"/&gt;        &lt;aop:advisor advice-ref="txAdvice" pointcut-ref="txPointcut"/&gt;    &lt;/aop:config&gt;这样就可以使用让spring管理事务了。测试代码，就是@TestDao@Repositorypublic class TestDao {    @Resource    private SessionFactory sessionFactory;    public boolean test(){        System.out.println(sessionFactory);        Person p=new Person();        p.setName("110");        p.setAge(666);        Session session=sessionFactory.getCurrentSession();        session.save(p);        return true;    }}实体类Person.java@Entity(name = "Person")public class Person implements java.io.Serializable {	private int Age;	private String Name;	public Person() {	}	public Person(int Age) {		this.Age = Age;			}	public Person(int Age, String Name) {		this.Age = Age;		this.Name = Name;	}	public int getAge() {		return this.Age;	}	public void setAge(int Age) {		this.Age = Age;	}	public String getName() {		return this.Name;	}	public void setName(String Name) {		this.Name = Name;	}}映射文件&lt;?xml version="1.0"?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN""http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"&gt;&lt;!-- Generated 2016-7-13 16:07:48 by Hibernate Tools 3.5.0.Final --&gt;&lt;hibernate-mapping&gt;    &lt;class name="com.pad.entity.Person" table="Person"&gt;        &lt;id name="Age" type="int"&gt;            &lt;generator class="increment" /&gt;        &lt;/id&gt;        &lt;property name="Name" type="java.lang.String"&gt;        &lt;/property&gt;    &lt;/class&gt;&lt;/hibernate-mapping&gt;完整的applicationContext.xml&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans"       xmlns:tx="http://www.springframework.org/schema/tx"       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop"       xmlns:context="http://www.springframework.org/schema/context"       xsi:schemaLocation="http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd       http://www.springframework.org/schema/aop       http://www.springframework.org/schema/aop/spring-aop.xsd       http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.1.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt;    &lt;context:annotation-config/&gt;    &lt;context:component-scan base-package="com.pad"/&gt;    &lt;context:property-placeholder location="classpath:datasource.properties" /&gt;    &lt;!-- 此处的数据源类BasicDataSource可以自己选择c3p0等等 --&gt;    &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt;        &lt;property name="driverClass" value="${mysql.driverClassName}"&gt;&lt;/property&gt;        &lt;property name="jdbcUrl" value="${mysql.url}"&gt;&lt;/property&gt;        &lt;property name="user" value="${mysql.username}"&gt;&lt;/property&gt;        &lt;property name="password" value="${mysql.password}"&gt;&lt;/property&gt;        &lt;property name="maxPoolSize" value="40"&gt;&lt;/property&gt;        &lt;property name="minPoolSize" value="1"&gt;&lt;/property&gt;        &lt;property name="initialPoolSize" value="1"&gt;&lt;/property&gt;        &lt;property name="maxIdleTime" value="20"&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;bean id="sessionFactory"          class="org.springframework.orm.hibernate4.LocalSessionFactoryBean"&gt;        &lt;property name="dataSource"&gt;            &lt;ref bean="dataSource" /&gt;        &lt;/property&gt;        &lt;property name="hibernateProperties"&gt;            &lt;props&gt;                &lt;!--这里要打全，比如show_sql不写成hibernate.show_sql好像并不输出--&gt;                &lt;prop key="hibernate.show_sql"&gt;${hibernate.show_sql}&lt;/prop&gt;                &lt;prop key="hibernate.format_sql"&gt;${hibernate.format_sql}&lt;/prop&gt;                &lt;prop key="hibernate.hbm2ddl.auto"&gt;${hibernate.hbm2ddl.auto}&lt;/prop&gt;                &lt;prop key="hibernate.dialect"&gt;${hibernate.dialect}&lt;/prop&gt;            &lt;/props&gt;        &lt;/property&gt;        &lt;property name="mappingLocations" value="classpath:/com/pad/entity/*.hbm.xml"&gt;&lt;/property&gt;        &lt;!--&lt;property name="mappingResources"&gt;--&gt;            &lt;!--&lt;list&gt;--&gt;                &lt;!--&lt;value&gt;com/pad/entity/user.hbm.xml&lt;/value&gt;--&gt;            &lt;!--&lt;/list&gt;--&gt;        &lt;!--&lt;/property&gt;--&gt;    &lt;/bean&gt;    &lt;!-- 配置Spring声明式事务 --&gt;    &lt;bean id="transactionManager" class="org.springframework.orm.hibernate4.HibernateTransactionManager"&gt;        &lt;property name="sessionFactory" ref="sessionFactory"&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;!-- 配置事务事务属性 --&gt;    &lt;tx:advice id="txAdvice" transaction-manager="transactionManager"&gt;        &lt;tx:attributes&gt;            &lt;tx:method name="get*" read-only="true"/&gt;            &lt;tx:method name="*"/&gt;        &lt;/tx:attributes&gt;    &lt;/tx:advice&gt;    &lt;!-- 配置事务切点，并把切点和事务属性关联起来 --&gt;    &lt;aop:config&gt;        &lt;aop:pointcut expression="execution(* com.pad.dao.*.*(..))" id="txPointcut"/&gt;        &lt;aop:advisor advice-ref="txAdvice" pointcut-ref="txPointcut"/&gt;    &lt;/aop:config&gt;    &lt;!--测试aop--&gt;    &lt;!--&lt;aop:config&gt;--&gt;        &lt;!--&lt;aop:aspect id="testAspect" ref="TestAOP"&gt;--&gt;            &lt;!--&lt;aop:pointcut id="testPointcut" expression="execution(* com.pad.entity.*.*(..))"/&gt;--&gt;            &lt;!--&lt;aop:before method="before" pointcut-ref="testPointcut"/&gt;--&gt;        &lt;!--&lt;/aop:aspect&gt;--&gt;    &lt;!--&lt;/aop:config&gt;--&gt;&lt;/beans&gt;整合中遇到的异常Not supported by BasicDataSource原因：在hibernate配置文件中配置之后再spring中又配置数据库发生冲突。  http://sandyxl001.blog.163.com/blog/static/16656410201241851531861/Could not parse mapping document from input stream hibernate查看Caused by:说明 一般是配置文件问题。HibernateException: Could not obtain transaction-synchronized Session for current thread原因没有配置事务Pom.xml&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"&gt;  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;  &lt;groupId&gt;com.pad.sshIntegration&lt;/groupId&gt;  &lt;artifactId&gt;sshIntegration-model&lt;/artifactId&gt;  &lt;packaging&gt;war&lt;/packaging&gt;  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;  &lt;name&gt;sshIntegration-model Maven Webapp&lt;/name&gt;  &lt;url&gt;http://maven.apache.org&lt;/url&gt;  &lt;properties&gt;    &lt;!-- springframe 版本控制 --&gt;    &lt;spring.version&gt;4.2.4.RELEASE&lt;/spring.version&gt;    &lt;struts2.version&gt;2.3.32&lt;/struts2.version&gt;    &lt;hibernate.version&gt;4.1.12.Final&lt;/hibernate.version&gt;  &lt;/properties&gt;  &lt;dependencies&gt;    &lt;dependency&gt;       &lt;groupId&gt;junit&lt;/groupId&gt;       &lt;artifactId&gt;junit&lt;/artifactId&gt;       &lt;version&gt;4.12&lt;/version&gt;      &lt;scope&gt;test&lt;/scope&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;      &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt;      &lt;version&gt;RELEASE&lt;/version&gt;    &lt;/dependency&gt;    &lt;!-- https://mvnrepository.com/artifact/org.apache.struts/struts2-core --&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.apache.struts&lt;/groupId&gt;      &lt;artifactId&gt;struts2-core&lt;/artifactId&gt;      &lt;version&gt;${struts2.version}&lt;/version&gt;    &lt;/dependency&gt;    &lt;!-- 用于整合struts2和spring的依赖 --&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.apache.struts&lt;/groupId&gt;      &lt;artifactId&gt;struts2-spring-plugin&lt;/artifactId&gt;      &lt;version&gt;${struts2.version}&lt;/version&gt;    &lt;/dependency&gt;    &lt;!--Spring Start--&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-core&lt;/artifactId&gt;      &lt;version&gt;${spring.version}&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt;      &lt;version&gt;${spring.version}&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-context&lt;/artifactId&gt;      &lt;version&gt;${spring.version}&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-aop&lt;/artifactId&gt;      &lt;version&gt;${spring.version}&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt;      &lt;version&gt;${spring.version}&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-beans&lt;/artifactId&gt;      &lt;version&gt;${spring.version}&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-web&lt;/artifactId&gt;      &lt;version&gt;${spring.version}&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-tx&lt;/artifactId&gt;      &lt;version&gt;${spring.version}&lt;/version&gt;    &lt;/dependency&gt;    &lt;!--spring支持ORM的包--&gt;    &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-orm --&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-orm&lt;/artifactId&gt;      &lt;version&gt;${spring.version}&lt;/version&gt;    &lt;/dependency&gt;    &lt;!--Spring end--&gt;    &lt;!-- https://mvnrepository.com/artifact/org.hibernate/hibernate-core --&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.hibernate&lt;/groupId&gt;      &lt;artifactId&gt;hibernate-core&lt;/artifactId&gt;     &lt;version&gt;${hibernate.version}&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.hibernate&lt;/groupId&gt;      &lt;artifactId&gt;hibernate-c3p0&lt;/artifactId&gt;      &lt;version&gt;${hibernate.version}&lt;/version&gt;    &lt;/dependency&gt;    &lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;    &lt;dependency&gt;      &lt;groupId&gt;mysql&lt;/groupId&gt;      &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;      &lt;version&gt;5.0.8&lt;/version&gt;    &lt;/dependency&gt;  &lt;/dependencies&gt;  &lt;!--  因为maven会把资源文件自动放到classes文件下，  导致hibernate的映射文件也被转移后找不到，  所以以下可以特别指定哪些文件转移，保证映射文件不被移动--&gt;  &lt;build&gt;    &lt;finalName&gt;sshIntegration-model&lt;/finalName&gt;    &lt;resources&gt;      &lt;resource&gt;        &lt;directory&gt;src/main/java&lt;/directory&gt;        &lt;includes&gt;          &lt;include&gt;**/*.xml&lt;/include&gt;        &lt;/includes&gt;        &lt;filtering&gt;true&lt;/filtering&gt;      &lt;/resource&gt;      &lt;resource&gt;        &lt;directory&gt;src/main/resources&lt;/directory&gt;        &lt;includes&gt;          &lt;include&gt;**/*.xml&lt;/include&gt;          &lt;include&gt;**/*.properties&lt;/include&gt;        &lt;/includes&gt;      &lt;/resource&gt;    &lt;/resources&gt;  &lt;/build&gt;&lt;/project&gt;]]></content>
      <categories>
        
      </categories>
      <tags>
        
          <tag> 整合 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[SpringAOP]]></title>
      <url>/2017/05/16/SpringAOP/</url>
      <content type="text"><![CDATA[AOP主要功能：日志记录，性能统计，安全控制，事务处理，异常处理等实现方式：  预编译 AspcetJ  运行期动态代理（JDK动态代理、CGLib动态代理）  SpringAOP JBossSpring框架中AOP用途  提供了声明式的企业服务，特别是EJB的替代服务的声明  允许用户定制自己的方面，以完成OOP和AOP的互补使用Spring的AOP实现  纯java实现，无序特殊编译过程，不需要控制类加载器  目前只支持方法执行连接点(通知Spring Bean的方法执行)  Spring的AOP不是提供最完整的AOP实现，而是侧重于提供一种AOP实现和SpringIoC容器之间的整合，用于帮助企业应用中的常见问题。  Spring AOP不会与AspectJ（是一个完整的AOP解决方案）竞争，从而提供综合全面的AOP解决方案。有接口和无接口的Spring AOP 实现区别  有接口：Spring AOP默认使用标准的JavaSE动态代理作为AOP代理，这使得任何接口（或者接口集）都可以被代理。  无接口：Spring AOP中也可以使用CGLib代理（如果一个业务对象并没有实现一个接口）Schema-Based AOP基于配置的AOP实现Spring所有切面和通知器都必须放在一个内(可以配置包含多个元素)，每一个可以包含pointcut，advisor和aspect元素。（必须按照相应顺序配置）大量使用了Spring的动态代理机制。声明aspect&lt;aop:config&gt;	&lt;aop:aspect id="moocAspectAo" ref="aspcetBean"&gt;    &lt;/aop:aspect&gt;&lt;/aop:config&gt;&lt;bean id="aspcetBean" class="com.pad.s"&gt;&lt;/bean&gt;pointcutexecution(public * (..)) 切入点为执行所有public方法时execution( set(..)) 切入点为执行所有set开始的方法时execution( com.xyz.service.AccountService.(..)) 切入点为执行AccountService类中所有方法时execution( com.xyz.service..(..)) 切入点为执行com.xyz.service包下所有方法时execution(* com.xyz.service…*(..)) 切入点为执行com.xyz.service包及其子包下所有方法类中所有方法时以上是springAop和AspectJ都支持的 以下只有springAop支持within（com.xyz.service.）within（com.xyz.service..）this（com.xyz.service.AccountService）声明pointcut(切入点)&lt;aop:config&gt;	&lt;!--这里是只执行特定方法--&gt;	&lt;aop:pointcut id="businnessService" expression="com.xyz.myapp.SystemArchitecture.businessService()"/&gt;&lt;/aop:config&gt;advice通知使用切面需要的maven依赖&lt;dependency&gt;   &lt;groupId&gt;org.springframework&lt;/groupId&gt;   &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt;   &lt;version&gt;4.1.1.RELEASE&lt;/version&gt;&lt;/dependency&gt;不然会抛异常org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'org.springframework.aop.aspectj.AspectJPointcutAdvisor#0':Before advice	&lt;aop:before pointcut-ref="dataAccessOperation" method="doAccessCheck"/&gt;    &lt;!--两种方式--&gt;    &lt;aop:before pointcut="execution(* com.pad.service..*(..))" method="doAccessCheck"/&gt;After returning advice	&lt;aop:after-returing pointcut-ref="dataAccessOperation" method="doAccessCheck"/&gt;    &lt;!--或者--&gt;    &lt;aop:after-returing pointcut-ref="dataAccessOperation" returning="retVal" method="doAccessCheck"/&gt;	Around advice 第一个参数必须是ProceedingJoinPoint类型，不调用他的proceed()方法的话原函数就不执行了。配置文件配置：	&lt;bean id="moocAspect" class="com.imooc.advice.MoocAspect"&gt;&lt;/bean&gt;	&lt;bean id="aspectBiz" class="com.imooc.biz.AspectBiz"&gt;&lt;/bean&gt;    &lt;aop:config&gt;		&lt;aop:aspect id="moocAspectAOP" ref="moocAspect"&gt;			&lt;aop:pointcut expression="execution(* com.imooc.biz.AspectBiz.run())" id="moocPointcut"/&gt;			&lt;aop:before method="before" pointcut-ref="moocPointcut"/&gt;			&lt;aop:after method="after" pointcut-ref="moocPointcut"/&gt;			&lt;aop:after-returning method="afterReturn" pointcut-ref="moocPointcut"/&gt;			&lt;aop:after-throwing method="afterThrow" pointcut-ref="moocPointcut"/&gt;			&lt;aop:around method="around" pointcut-ref="moocPointcut"/&gt;			&lt;aop:around method="aroundInit" pointcut="execution(* com.imooc.biz.AspectBiz			.init(String,int)) and args(name,time)"/&gt;		&lt;/aop:aspect&gt;    &lt;/aop:config&gt;切面public class MoocAspect {    public void before(){        System.out.println("before apsect method run.");    }    public void after(){        System.out.println("after apsect method run.");    }    public String afterReturn(){        System.out.println("after Return");        String retVal="sss";        return retVal;    }    public void afterThrow(){        System.out.println("after Throw.");    }    public Object around(ProceedingJoinPoint p) throws Throwable{        System.out.println("around head");        Object obj=p.proceed();        System.out.println("around footer");        return null;    }     public Object aroundInit(ProceedingJoinPoint p,String name,int time) throws Throwable{        System.out.println("around head");         System.out.println(name+time);        Object obj=p.proceed();        System.out.println("around footer");        return null;    }}测试代码：public class AspectBiz {    public void run(){        System.out.println("testtttttttt");//        throw new RuntimeException("ss");    }    public void init(String name,int time){    }    @Test    public void test(){        ApplicationContext context=new ClassPathXmlApplicationContext("applicationContext.xml");        AspectBiz biz=(AspectBiz)context.getBean("aspectBiz");       biz.run();        biz.init("iii",2);    }}Introductions为在types-maching中匹配的类增加新的parent，使得可以getBean后强制转换成父类接口，实现接口实现方式为default-impl中指定的类&lt;aop:declare-parents	types-matching="com.xyz.service.*+"    implement-interface="com.xyz.service.tracking.UsageTracked" default-impl="com.xyz.service.tracking.DefaultUsageTracked"/&gt;&lt;aop:before	pointcut="com.xyz.SystemArchitecture.businessService() and this (usageTracked)" method="recordUsage"/&gt;UsageTracked usageTracked=(UsageTracked)context.getBean(“myService”);所有基于配置文件的aspects只支持单例模式singleton modelAdvisorsadvisor就像一个小的自包含的方面，只有一个advice切面自身通过一个bean表示，并且必须实现某个advice接口，同时，advisor也可以很好的利用AspectJ的切入点表达式Spring通过配置文件中元素支持advisor实际使用中，大多数情况下它会和transactional advice配合使用为了定义一个advisor的优先级以便让advice可以有序，可以使用order属性来定义advisor的顺序。]]></content>
      <categories>
        
      </categories>
      <tags>
        
          <tag> Spring </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Spring搭建]]></title>
      <url>/2017/05/15/Spring/</url>
      <content type="text"><![CDATA[Spring一些关键概念IOC  控制反转：所谓控制反转就是把new的控制权交出去，让spring容器根据配置文件来完成创建实例，某个对象在使用一个对象时不需要自己new，而是通过BeanFactory进行获取。  IOC有两种主要实现方式一种是依赖查找，一种是依赖注入(DI)。  现在最流行的IoC类型时依赖注入,让容器全权负责依赖查询，受管组件只要暴露JavaBean的setter方法和构造函数  Spring入门–控制反转(IOC)与依赖注入(DI) http://blog.csdn.net/hy6688_/article/details/40658835AOP： 在软件业，AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。 AOP主要是使用代理模式进行实现的。  http://www.cnblogs.com/yanbincn/archive/2012/06/01/2530377.html 理解AOP（附代码讲解） https://www.zhihu.com/question/24863332 知乎上的讨论构建一个简单SpringHellowrod  下载相应jar引入工程：地址：https://repo.spring.io/webapp/#/artifacts/browse/tree/General/libs-release-local/org/springframework/spring/4.0.1.RELEASE/spring-framework-4.0.1.RELEASE-dist.zip使用maven添加2个依赖就能运行基本的&lt;properties&gt;    &lt;!-- springframe 版本控制 --&gt;    &lt;spring.version&gt;4.1.1.RELEASE&lt;/spring.version&gt;&lt;/properties&gt;&lt;dependencies&gt;   &lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-core&lt;/artifactId&gt;      &lt;version&gt;${spring.version}&lt;/version&gt;   &lt;/dependency&gt;   &lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt;      &lt;version&gt;${spring.version}&lt;/version&gt;   &lt;/dependency&gt;&lt;/dependencies&gt;  完整web项目版依赖 http://blog.csdn.net/u012706811/article/details/51567129      创建实体类     public class Person {     private String name;     private Pen pen;     public void sayHello(){         System.out.println("Hello,I am "+name+",I have a "+pen.getColor()+" pen");     }     public void setName(String name) {         this.name = name;     }     public Pen getPen() {         return pen;     }     public void setPen(Pen pen) {         this.pen = pen;     } }         public class Pen {     private String color;     public String getColor() {         return color;     }     public void setColor(String color) {         this.color = color;     } }            创建applicationContext.xml    @applicationContext     &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;beans     xmlns="http://www.springframework.org/schema/beans"     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"     xmlns:p="http://www.springframework.org/schema/p"     xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"&gt;     &lt;bean id="pen" class="com.pad.entity.Pen"&gt;         &lt;property name="color" value="black"/&gt;     &lt;/bean&gt;     &lt;bean id="person" class="com.pad.entity.Person"&gt;     	&lt;!--value是属性 ref指向bean的id--&gt;         &lt;property name="name" value="pad"/&gt;         &lt;property name="pen" ref="pen"/&gt;     &lt;/bean&gt; &lt;/beans&gt;            使用bean    @Test.java     public static void main(String[] args) {         //加载配置文件         ApplicationContext context=new ClassPathXmlApplicationContext("applicationContext.xml");         Person p=(Person)context.getBean("person");         p.sayHello();     }      Spring中配置文件的标签init-method和destroy-method(较少使用到)&lt;bean id="loginServBean" init-method="doBefore" destroy-method="doAfter" class="com.pad.service.LoginServ"&gt;		&lt;property name="loginDao" ref="loginFactoryBean" &gt;&lt;/property&gt;	&lt;/bean&gt;其中init-method和destory-method为实例化bean前和销毁bean时执行的方法。  destroy-method触发的条件是容器关闭。//原来使用ApplicationContext但是没有close方法所以换成AbstractApplicationAbstractApplicationContext context=new ClassPathXmlApplicationContext("applicationContext.xml");		LoginServ loginServ=(LoginServ) context.getBean("loginServBean");		loginServ.runLogin();		loginServ.runLogin();		//如果不关闭直接执行并不会触发destroy-method        context.close();]]></content>
      <categories>
        
      </categories>
      <tags>
        
          <tag> Spring </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[阿里云服务器折腾笔记]]></title>
      <url>/2017/05/15/ECS/</url>
      <content type="text"><![CDATA[阿里云服务器周六起床，因为通知想起来实名域名的时候心血来潮想玩一玩云服务器，感谢阿里爸爸，领了6个月的免费套餐来玩，顺便记录一下折腾的记录。  官方帮助文档 https://help.aliyun.com/contact/introduction/ecs.html购买开通后可以在网页的控制台-&gt;选择实例-&gt;远程连接进入，第一次远程链接会管理密码，只提示一次，所以要记住。如果忘记可以在实例右下角的更多中重置。通过SSH远程登陆  一段时间后ssh没有反应问题http://www.cnblogs.com/wanghetao/p/3872919.htmlhttp://blog.sina.com.cn/s/blog_4e056cff0100gfzp.html ssh服务端关闭连接用户http://blog.csdn.net/u010521546/article/details/45623469 解决ssh连接一段时间后光标无响应问题直接使用ssh root@实例公网ip  之后输入该实例root用户密码完成连接（公网ip在实例详情中可以看到）。ssh root@公网ip查看ssh进程ps aux |grep ssh格式化和挂载数据盘 ：https://help.aliyun.com/document_detail/25426.html?spm=5176.doc52806.6.601.XrXtrB未挂载时df -h应该之只能看到到系统盘前Device     Boot Start      End  Sectors Size Id Type/dev/vda1  *     2048 83884031 83881984  40G 83 Linux后多出Device     Boot Start      End  Sectors Size Id Type/dev/vdb1        2048 41943039 41940992  20G 83 Linux格式化分区mkfs.ext3 /dev/vdb1写入新分区信息echo /dev/vdb1/ /mnt ext3 default 0 0 &gt;&gt; /etc/fstab挂在新分区mount /dev/vdb1 /ment这个时候如果挂载成功就可以用df -h查看了分区情况了进行配置jdk和tomcat  参考 https://help.aliyun.com/document_detail/52806.html?spm=5176.doc25426.6.657.OaRFWA下载jdk和tomcat 地址  这里tomcat阿里云的wget不到,就去apache官网下了一个http://mirrors.hust.edu.cn/apache/tomcat/tomcat-8/v8.5.15/bin/apache-tomcat-8.5.15.tar.gzwget https://mirrors.aliyun.com/apache/tomcat/tomcat-8/v8.5.13/bin/apache-tomcat-8.5.13.tar.gzwget http://mirrors.linuxeye.com/jdk/jdk-8u121-linux-x64.tar.gz安装jdkmkdir /usr/javatar xzf jdk-8u121-linux-x64.tar.gz  -C /usr/javavim /etc/profile 编辑/etc/profile增加以下，配置环境变量#set java environmentexport JAVA_HOME=/usr/java/jdk1.8.0_121export CLASSPATH=$JAVA_HOME/lib/tools.jar:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/libexport PATH=$JAVA_HOME/bin:$PATH加载环境变量source /etc/profile查看jdk版本java -version看到版本就配置成功了。安装配置tomcat解压tar xzf apache-tomcat-8.5.15.tar.gz将解压后文件夹移动到/usr/local 并且文件夹名改为tomcatmv apache-tomcat-8.5.15 /usr/local/tomcat分配权限chown -R www.www /usr/local/tomcat备份配置文件mv server.xml server.xml_bk新建server.xml写入以下vim server.xml@server.xml&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;Server port="8006" shutdown="SHUTDOWN"&gt;   &lt;Listener className="org.apache.catalina.core.JreMemoryLeakPreventionListener"/&gt;   &lt;Listener className="org.apache.catalina.mbeans.GlobalResourcesLifecycleListener"/&gt;   &lt;Listener className="org.apache.catalina.core.ThreadLocalLeakPreventionListener"/&gt;   &lt;Listener className="org.apache.catalina.core.AprLifecycleListener"/&gt;   &lt;GlobalNamingResources&gt;     &lt;Resource name="UserDatabase" auth="Container"               type="org.apache.catalina.UserDatabase"               description="User database that can be updated and saved"               factory="org.apache.catalina.users.MemoryUserDatabaseFactory"               pathname="conf/tomcat-users.xml" /&gt;   &lt;/GlobalNamingResources&gt;   &lt;Service name="Catalina"&gt;     &lt;Connector port="8080"               protocol="HTTP/1.1"               connectionTimeout="20000"               redirectPort="8443"               maxThreads="1000"               minSpareThreads="20"               acceptCount="1000"               maxHttpHeaderSize="65536"               debug="0"               disableUploadTimeout="true"               useBodyEncodingForURI="true"               enableLookups="false"               URIEncoding="UTF-8" /&gt;     &lt;Engine name="Catalina" defaultHost="localhost"&gt;       &lt;Realm className="org.apache.catalina.realm.LockOutRealm"&gt;         &lt;Realm className="org.apache.catalina.realm.UserDatabaseRealm"                resourceName="UserDatabase"/&gt;       &lt;/Realm&gt;       &lt;Host name="localhost" appBase="/data/wwwroot/default" unpackWARs="true" autoDeploy="true"&gt;         &lt;Context path="" docBase="/data/wwwroot/default" debug="0" reloadable="false" crossContext="true"/&gt;         &lt;Valve className="org.apache.catalina.valves.AccessLogValve" directory="logs"           prefix="localhost_access_log." suffix=".txt" pattern="%h %l %u %t &amp;quot;%r&amp;quot; %s %b" /&gt;       &lt;/Host&gt;     &lt;/Engine&gt;   &lt;/Service&gt; &lt;/Server&gt;tomcat相关配置就不解读了，appBase是我们要部署的应用存放目录遇到问题在服务端上配置完jdk和tomcat后，发现使用公网ip不能访问服务器的应用，ping能ping通，服务端使用wget localhost 也能正常获取，但是使用公网ip就是不行，以为是服务器配置问题，把防火墙全关了，还是不行。后来逛了下云栖的问答，发现类似问题有几个，之后发现是安全组设置的问题，安全组默认允许的2个tcp端口为是22（ssh端口）3389端口，在安全组新增相应端口允许的规则就行了，终于看到那只汤姆猫了！]]></content>
      <categories>
        
      </categories>
      <tags>
        
          <tag> 服务器 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[maven]]></title>
      <url>/2017/05/14/maven/</url>
      <content type="text"><![CDATA[mavenMaven是基于项目对象模型（POM），可以通过一小段描述信息来管理项目的构建，报告和文档的软件项目的工具下载网站http://maven.apache.org配置环境变量  新建M2_HOME变量  指向maven的安装目录如 目录\apache-maven-3.3.3  加入path最后 %M2_HOME%\bin;  验证 mvn -v查看版本号目录结构项目名    src        -main            -java                -package        -test            -java                -package        -resources pom.xml在struts2-core-*.jar下META_INF\maven中有模板，可以改造，删除中间部分。修改后放入项目中如maven01目录下 ```xml &lt;?xml version="1.0" encoding="UTF-8"?&gt;    4.0.0         com.imooc.maven01     maven01-model     0.0.1SNAPSHOT        	            junit            junit            4.10            进入项目路径运行 mvn complie 进行编译，生成文件在target文件夹下mvn package 生成maven01-model的jar 相当于打包。&gt; 初次使用compile的时候可能会报“Unknown lifecycle phase”的错误，这个时候需要先执行下面命令```bashmvn installmvn compiler:compilemvn org.apache.maven.plugins:maven-compiler-plugin:compilemvn org.apache.maven.plugins:maven-compiler-plugin:2.0.2:compilemvn常用构建命令	mvn -v 查看maven版本    	compile 编译        test 测试        package 打包        clean 删除target        install 安装jar包到本地仓库中（进入相关项目目录使用，之后再pom.xml中还需要配置dependency，先从本地查找，如果找不到会去网上maven的中央仓库中找）mvn archetype:generate使用archetype插件自动产生目录骨架。mvn archetype:generate -DgroupId=com.imooc.maven04 -DatifactId=maven04-demo -Dversion=1.0.0SNAPSHOT -Dpackage=com.imooc.maven04.demo  使用Maven运行Java main的3种方式 http://www.tuicool.com/articles/UJJvim坐标和仓库https://repo.maven.apache.org/maven2 默认全球中央仓库地址，其中可以搜索很多。修改maven镜像方法在conf文件下settings.xml找到mirror标签更改&lt;mirror&gt;&lt;id&gt;maven.net.cn&lt;/id&gt;&lt;mirrorOf&gt;central&lt;/mirrorOf&gt;&lt;name&gt;central mirror in china&lt;/name&gt;&lt;url&gt;http://maven.net.cn/content/groups/public&lt;/url&gt;&lt;/mirror&gt;修改本地仓库路径修改setting&lt;localRepository&gt;路径&lt;/localRepository&gt;在eclipse中安装maven插件将插件放进eclipse安装目录下的dropeclipse4.0以上就不需要配置了maven生命周期clean 清理项目default 构建项目site 生成项目站点clean compile test package install执行某个阶段 前面的也会顺序执行clean项目 pre-clean		clean 清理上一次构建生成的所有文件        post-clean 执行清理后的文件default构建项目 （最核心） 	compile test package installsite生成项目站点  	pre-site 生成项目站点前完成工作    site 生成项目的站点文档    post-site 在生成项目站点后要完成的工作    site-deploy 发布生成的站点到服务器上pom.xml中加入 &lt;build&gt; 	&lt;plugin&gt;    	&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;    	&lt;artifactId&gt;maven-source-plugin&lt;/artifactId&gt;    	&lt;version&gt;2.4&lt;/version&gt;    	&lt;executions&gt;        	&lt;execution&gt;            	&lt;phase&gt;package&lt;/phase&gt;                &lt;goals&gt;                	&lt;goal&gt;jar-no-fork&lt;/goal&gt;                &lt;/goals&gt;            &lt;/execution&gt;        &lt;/executions&gt;    &lt;/plugin&gt; &lt;/build&gt;pom.xml常用元素  &lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"&gt;    &lt;!--指定了当前pom的版本--&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;        &lt;!--主项目的标识--&gt;     &lt;groupId&gt;反写的公司网址+项目名&lt;/groupId&gt;     &lt;!--模块的标识，项目中的--&gt;     &lt;artifactId&gt;项目名+模块名&lt;/artifactId&gt;     &lt;!--     项目版本号 大版本号 分支版本号 小版本号     snapshot快照版本 alpha内部测试 beta公测      Release稳定版	GA正式发布     --&gt;     &lt;version&gt;0.0.1SNAPSHOT&lt;/version&gt;     &lt;!--maven项目打包方式，默认是jar 还可以是war zip pom等--&gt;     &lt;packaging&gt;&lt;/packaging&gt;    &lt;!--项目描述名，一般是项目产生文档时使用--&gt;    &lt;name&gt;&lt;/name&gt;    &lt;!--项目地址--&gt;    &lt;url&gt;&lt;/url&gt;    &lt;!--项目描述--&gt;    &lt;description&gt;&lt;/description&gt;    &lt;!--开发者信息--&gt;    &lt;developers&gt;&lt;/developers&gt;    &lt;!--许可证信息--&gt;    &lt;licenses&gt;&lt;/licenses&gt;    &lt;!--组织信息--&gt;    &lt;organization&gt;&lt;/organization&gt;   &lt;!--依赖列表--&gt;   &lt;dependencies&gt;    	&lt;dependency&gt;            &lt;groupId&gt;junit&lt;/groupId&gt;            &lt;artifactId&gt;junit&lt;/artifactId&gt;            &lt;version&gt;4.10&lt;/version&gt;            &lt;type&gt;&lt;/type&gt;            &lt;!--依赖范围--&gt;            &lt;scope&gt;&lt;/scope&gt;            &lt;!--设置依赖是否可选，默认为false，如果是false默认继承 ，如果为true则必须显式引入--&gt;            &lt;optional&gt;&lt;/optional&gt;            &lt;!--排除依赖传递列表--&gt;            &lt;exclusions&gt;            	&lt;exclusion&gt;&lt;/exclusion&gt;            &lt;/exclusions&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;    &lt;!--依赖管理，这里依赖并不会执行，主要是用来给子模块进行继承--&gt;    &lt;dependencyManagement&gt;    	&lt;dependencies&gt;        	&lt;dependency&gt;&lt;/dependency&gt;        &lt;/dependencies&gt;    &lt;/dependencyManagement&gt;	&lt;build&gt;    	&lt;!--插件列表--&gt;    	&lt;plugins&gt;        	&lt;plugin&gt;            	&lt;!--依旧要指定坐标--&gt;            	&lt;groupId&gt;&lt;/groupId&gt;                &lt;artifactId&gt;junit&lt;/artifactId&gt;           		 &lt;version&gt;4.10&lt;/version&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;    &lt;!--用于子模块对于父模块的继承--&gt;    &lt;parent&gt;&lt;/parent&gt;    &lt;!--聚合，如果有很多模块需要编译，可以在这里指定多个模块一起运行--&gt;    &lt;modules&gt;    	&lt;module&gt;&lt;/module&gt;    &lt;/modules&gt;&lt;/project&gt;依赖scope标签：classpath 编译 测试 运行可以有以下值            值      作用于范围                  compile      默认的范围，编译测试运行都有效              provided      编译和测试时有效，测试时无效              runtime      测试和运行时有效，比如jdbc的驱动在编译时不需要              test      测试时有效，典型应用junit              system      和privided类似，但是与本地系统相关联，可移植性差              import      导入的范围，它只使用在dependencyManagement中，标识从其他的pom中导入dependecy的配置      依赖传递依赖会传递，如果不想传递可以使用exclusions标签进行排除settings.xml中的profile中加入用来设置默认jdk（因为maven默认使用1.5）&lt;activation&gt;	&lt;activeByDefault&gt;true&lt;/activeByDefault&gt;   	&lt;jdk&gt;1.7&lt;/jdk&gt;&lt;/activation&gt;依赖冲突依赖中有2个不同版本jar，造成冲突  短路优先，路径短的优先  先声明先优先（在路径相同情况下，xml中谁先声明谁优先）聚合和继承使用modules标签进行聚合，可以一起构建	&lt;modules&gt;    	&lt;module&gt;&lt;/module&gt;        &lt;module&gt;&lt;/module&gt;        &lt;module&gt;&lt;/module&gt;    &lt;/modules&gt;使用maven构建web项目      新建maven项目，选择 maven-archetype-webapp        需要配置servlet的api www.mvnrepository.com搜索servlet 复制servlet坐标 增加到pom.xml中的dependency中设定scope为provided        按照maven约定创建目录src/main/java和src/test/java 如果无法创建可以在Navigator视图下创建，之后到工程视图update        确保buildpath中输出路径为target的class目录中        property - project Facets-Dynamic Web Module勾选        property-deployment assembly - 去除test相关部署        中央仓库搜索jetty maven plugin 复制插件坐标粘贴进plugins中的plugin标签内 （如果要使用tomcat插件可以去tomcat官网-maven plugin复制例子中的坐标）        run as maven builder        输入 jetty:run 运行    如果想在打包时就运行则使用executions标签```xml	&lt;plugins&gt;    	&lt;plugin&gt;        	&lt;!--依旧要指定坐标--&gt;        	&lt;groupId&gt;&lt;/groupId&gt;            &lt;artifactId&gt;junit&lt;/artifactId&gt;       		 &lt;version&gt;4.10&lt;/version&gt;             &lt;executions&gt;             	&lt;execution&gt;                	&lt;!--打包成功后使用jetty:run来运行jetty服务--&gt;                	&lt;phase&gt;package&lt;/phase&gt;                    &lt;goals&gt;                    	&lt;goal&gt;run&lt;/goal&gt;                    &lt;/goals&gt;                &lt;/execution&gt;             &lt;/executions&gt;        &lt;/plugin&gt;    &lt;/plugins&gt; ```查看本地仓库路径：mvn help:effective-settings]]></content>
      <categories>
        
      </categories>
      <tags>
        
          <tag> maven </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Mybatis动态sql拼接以及使用log4j]]></title>
      <url>/2017/05/14/MyBatis%E8%A1%A5%E5%85%85/</url>
      <content type="text"><![CDATA[动态sql拼接由于select只接受一个附加参数，所以需要封装后传入，动态拼接使用了ognl表达式, &lt;select id="queryData" parameter="com.imooc.bean.Message" resultMap=""&gt; 	select ID,COMMAND from MESSAGE where 1=1    &lt;!--    这里&amp;quot;是转义的上引号  &amp;不能在这里用所以用ognl自带的操作符and 还有or 、in、 not in    ognl可以直接获取对象中的属性值，这里的command是从Message中获得，还能调用对象属性    --&gt;    &lt;if test="command!=null and !&amp;quit;&amp;quot;.equals(command.trim())"&gt;    &lt;!--这里下面的语法并不是ognl表达式，是mybatis自己的--&gt;    and COMMAND=#{command}    &lt;/if&gt;    &lt;if test="description!=null and !&amp;quit;&amp;quot;.equals(command.trim())"&gt;    and description like '%' #{description} '%'    &lt;/if&gt; &lt;/select&gt;## 使用log4j调试动态SQL 引用相应jar(log4j-*.jar)和configuration.xml 输出分为几个级别   	log.debug() log.info() log.warn() log.error() 在log4j.properties中配置 	log4j.rootLogger=DEBUG,Console如果是以上配置则会输出所有，输出为大于配置等级的信息，如果配了ERROR则只会输出log.error()其中Console只是取的一个变量名，可以更改，但是前面的不能更改log4j.rootLogger=DEBUG,Consolelog4j.appender.Console=org.apache.log4j.ConsoleAppender//定义输出布局log4j.appender.Console.layout=org.apache.log4j.PatternLayout//定义输出格式 %d日期 %t线程 -5表示输出至少为5为不足则补齐 %p输出日志级别 %c输出日志是所属类全名  %m输出时附加的信息 %n换行log4j.appender.Console.layout.ConversionPattern=%d[%t]%-5p[%c]-%m%n//org.apache是自己写的包名，个性化 第一行是整个工程的log4j.logger.org.apache=INFOmybatis本身定义了调用log工具的借口，导入哪种jar就用哪种日志，org.apache.ibatis.logging下源码。MyBatis中的配置文件标签foreach标签```xml&lt;delete id="deleteBatch" parameterType="java.util.List"&gt;    delete from message where id in(        &lt;!--用separator让mybatis来拼接，值为所需分隔符，这里index没有使用单纯只是做笔记--&gt;        &lt;foreach collection="list"  index="i" item="item" separator=","&gt;            #{item}        &lt;/foreach&gt;    )&lt;/delete&gt;```## where标签  &lt;select id="queryData" parameter="com.imooc.bean.Message" resultMap=""&gt; 	select ID,COMMAND from MESSAGE     &lt;where&gt;    &lt;if test="command!=null and !&amp;quit;&amp;quot;.equals(command.trim())"&gt;    and COMMAND=#{command}    &lt;/if&gt;   &lt;/where&gt; &lt;/select&gt;## sql标签可以重复引用sql片段。 &lt;select id="queryData" parameter="com.imooc.bean.Message" resultMap=""&gt; 	select &lt;include refid="colums"/&gt; from MESSAGE     &lt;where&gt;    &lt;if test="command!=null and !&amp;quit;&amp;quot;.equals(command.trim())"&gt;    and COMMAND=#{command}    &lt;/if&gt;   &lt;/where&gt; &lt;/select&gt;  &lt;sql id="colums"&gt; ID,COMMADN&lt;/sql&gt;## set标签  主要解决拼接时分隔符   &lt;update id=""&gt;    update message     	&lt;set&gt;        	&lt;if test="command!=null and !&amp;quit;&amp;quot;.equals(command.trim())"&gt;    and COMMAND=#{command}    &lt;/if&gt;        &lt;/set&gt;   &lt;/update&gt;## trim标签   可以代替where和set   &lt;!--prefix 如果内有内容加入where  suffix如果有内容输出则加上  如果有会在最后切掉prefixOverrides="and/or"  suffixOverrides=","--&gt;   &lt;trim prefix="where"&gt;   &lt;/trim&gt;## choose标签类似java的switch case   &lt;choose&gt;        &lt;when test=""&gt;        &lt;/when&gt;        &lt;when test=""&gt;        &lt;/when&gt;        &lt;when test=""&gt;        &lt;/when&gt;    	&lt;otherwise&gt;&lt;/otherwise&gt;   &lt;/choose&gt;## association用于一对一映射   &lt;association property="" resultMap="sss.resultid"/&gt;]]></content>
      <categories>
        
      </categories>
      <tags>
        
          <tag> MyBatis </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[MyBastis环境搭建以及单表CURD]]></title>
      <url>/2017/05/12/MyBatisSingleTable/</url>
      <content type="text"><![CDATA[MyBatisMyBatis 是支持普通 SQL查询，存储过程和高级映射的优秀持久层框架。MyBatis 消除了几乎所有的JDBC代码和参数的手工设置以及结果集的检索。MyBatis 使用简单的 XML或注解用于配置和原始映射，将接口和 Java 的POJOs（Plain Old Java Objects，普通的 Java对象）映射成数据库中的记录。1. 相关jar包下载并且导入项目https://github.com/mybatis/mybatis-3/releases2. 配置核心配置文件  如果下载的是source code可以在下面目录找到核心配置文件模板：mybatis-*/src/test/java/org/apache/ibatis/submitted/complex_property/Configuration.xml@conf.xml(这里文件名可以自己取，主要是后续自己通过方法加载)&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt;    &lt;environments default="development"&gt;        &lt;environment id="development"&gt;            &lt;transactionManager type="JDBC" /&gt;            &lt;!-- 配置数据库连接信息 --&gt;            &lt;dataSource type="POOLED"&gt;                &lt;property name="driver" value="com.mysql.jdbc.Driver" /&gt;                &lt;property name="url" value="jdbc:mysql://localhost:3306/mybatisDB" /&gt;                &lt;property name="username" value="root" /&gt;                &lt;property name="password" value="123" /&gt;            &lt;/dataSource&gt;        &lt;/environment&gt;    &lt;/environments&gt;    &lt;mappers&gt;    	 &lt;!--第一种是通过xml进行映射加载的xml，第二种是通过注解方式映射加载的是接口--&gt;	     &lt;mapper resource="com/pad/mapping/cardMapper.xml"/&gt;	     &lt;mapper class="com.pad.mapping.IUserMapper"/&gt;    &lt;/mappers&gt;&lt;/configuration&gt;3. 在数据库中建立对应表并建立实体类create table user(u_id int primary key auto_increment,u_name varchar(20),u_age int);@User.javapublic class User {	private int u_id;	private String u_name;	private int u_age;			public int getU_id() {		return u_id;	}	public void setU_id(int uId) {		u_id = uId;	}	public String getU_name() {		return u_name;	}	public void setU_name(String uName) {		u_name = uName;	}	public int getU_age() {		return u_age;	}	public void setU_age(int uAge) {		u_age = uAge;	}}4. 建立映射关系这里有2种方式注解方式和xml配置方式，因为下面将使用注解方式这里就使用xml配置方式：@userMapper.xml&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;!--命名空间可以自定义，但是习惯上是包名+映射文件名，可以保证唯一--&gt; &lt;mapper namespace="com.pad.mapping.userMapper"&gt; 	&lt;!--依次为指定id到时候调用，指定参数类型（这里u_id为int所以是int），指定返回类型，这里返回的是User类--&gt; 	&lt;select id="getUser" parameterType="int" resultType="com.pad.entity.User"&gt;    	select u_id,u_name,u_age from user where u_id=#{u_id};    &lt;/select&gt;    &lt;insert id="addUser" parameterType="com.pad.entity.User" resultType="int"&gt;    	insert into user(u_name,u_age) values(#{u_name},#{u_age});    &lt;/insert&gt;    &lt;delete id="deleteUser" parameterType="int" resultType="int"&gt;    	delete from user where u_id=#{u_id}    &lt;/delete&gt;    &lt;update id="updateUser" parameterType="com.pad.entity.User" resultType="int"&gt;    	update user set u_name=#{u_name},u_age=#{u_age} where u_id=#{u_id}    &lt;/update&gt; &lt;/mapper&gt;  如果觉得写类型时打全路径比较麻烦可以考虑取别名，在核心配置文件conf.xml的configuration标签范围内使用```          &gt; 之后就可以愉快的直接使用 _User 替代 com.pad.entity.User 了写完配置文件之后再conf.xml中引入```xml&lt;mappers&gt;	&lt;mapper resource="com/pad/mapping/userMapper.xml" /&gt;&lt;/mappers&gt;5. 编写测试代码MyBatis 向DAO层提供sqlsession对象SqlSession作用  向SQL语句传入参数  执行SQL语句  获取执行SQL语句的结果  事务的控制获取SqlSession1.通过配置文件获取数据库连接相关信息2.通过配置文件构建SqlSessionFactory3.通过SqlSessionFactory打开数据库会话/*获取SqlSession函数 *抛出IOException，在调用时try...catch 在finally中close() */public SqlSession getSqlSession() throws IOException{    Reader reader=Resources.getResourceAsReader("com/imooc/confg/xxx.xml");    SqlSessionFactory sqlSessionFactory=new SqlSessionFactoryBuilder().build(reader);    SqlSession sqlSession=sqlSessionFactory.openSession();    return sqlSession;}@TestMB.java	@Before	public void init() throws IOException{    	//加载配置文件，build方法可以接收Reader或者InputStream，用以产生XMLConfigBuilder对象		Reader reader=Resources.getResourceAsReader("conf.xml");		SqlSessionFactory sqlSessionFactory=new SqlSessionFactoryBuilder().build(reader);		session=sqlSessionFactory.openSession();//可以接收一个boolean值，如为true则自动commit	}		@After	public void destory(){		session.commit();		session.close();	}    	@Test	public void testAddU(){    	String statement="com.pad.mapping.addUser";		User u=session.selectOne(statement,1);		u.setU_name("xiaoming");		u.setU_age(18);		user.addUser(u);	}注解+接口方式实现CURD实体类@User.javapublic class User {	private int u_id;	private String u_name;	private int u_age;			public int getU_id() {		return u_id;	}	public void setU_id(int uId) {		u_id = uId;	}	public String getU_name() {		return u_name;	}	public void setU_name(String uName) {		u_name = uName;	}	public int getU_age() {		return u_age;	}	public void setU_age(int uAge) {		u_age = uAge;	}}接口 @IUserMapper.javaimport java.util.List;import org.apache.ibatis.annotations.Delete;import org.apache.ibatis.annotations.Insert;import org.apache.ibatis.annotations.Select;import org.apache.ibatis.annotations.Update;import com.pad.entity.User;public interface IUserMapper {	@Insert("insert into user(u_name,u_age) values(#{u_name},#{u_age})")	int addUser(User u);		@Delete("delete from user where u_id=#{u_id}")	int deleteUser(User u);		@Update("update user set u_name=#{u_name},u_age=#{u_age} where u_id=#{u_id}")	int updateUser(User u);		@Select("select u_id,u_name,u_age from user where u_id=#{u_id}")	User selectUser(int u_id);		@Select("select u_id,u_name,u_age from user")	List&lt;User&gt; selectUsers();}测试用例@TestMB.javaimport java.io.IOException;import java.io.Reader;import java.util.Date;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.After;import org.junit.Before;import org.junit.Test;import com.pad.entity.Card;import com.pad.entity.User;import com.pad.mapping.IUserMapper;public class TestMB {	private SqlSession session;		@Before	public void init() throws IOException{//		String res="mybatis.xml";//		InputStream is=TestMB.class.getClassLoader().getResourceAsStream(res);//		SqlSessionFactory sessionfactory=new SqlSessionFactoryBuilder().build(is);//		SqlSession session=sessionfactory.openSession();				Reader reader=Resources.getResourceAsReader("conf.xml");		SqlSessionFactory sqlSessionFactory=new SqlSessionFactoryBuilder().build(reader);		session=sqlSessionFactory.openSession();	}		@After	public void destory(){		session.commit();		session.close();	}			@Test	public void testAddU(){		IUserMapper user=(IUserMapper)session.getMapper(IUserMapper.class);		User u=new User();		u.setU_name("xiaoming");		u.setU_age(18);		user.addUser(u);	}		@Test	public void testDeleteU(){		IUserMapper user=(IUserMapper)session.getMapper(IUserMapper.class);		User u=new User();		u.setU_id(1);		u.setU_name("xiaoming");		u.setU_age(18);		System.out.println(user.deleteUser(u));	}	@Test	public void testUpdateU(){		IUserMapper user=(IUserMapper)session.getMapper(IUserMapper.class);		User u=new User();		u.setU_id(2);		u.setU_name("烫烫烫");		u.setU_age(999);		System.out.println(user.updateUser(u));	}		@Test	public void testSelectU(){		IUserMapper user=(IUserMapper)session.getMapper(IUserMapper.class);		System.out.println(user.selectUser(2));	}		@Test	public void testSelectUs(){		IUserMapper user=(IUserMapper)session.getMapper(IUserMapper.class);		System.out.println(user.selectUsers());	}}conf.xml引入映射&lt;mapper class="com.pad.mapping.IUserMapper"/&gt;因为字段名和属性不相同导致查询不出结果问题在一些情况下表中字段名和实体类中属性名不一致，如User表字段为u_id,u_name， User类属性为 uid,uname。在这种情况下直接使用select* 是查询不出结果的。有以下两种方式解决。1. 为查询字段取别名select u_id uid,u_name uname from user;2. 为字段和属性建立映射建立之后就可以使用select *来查找(当然select * 性能上比较差，还是手写字段名把)&lt;resultMap type="com.pad.entity.User" id="userResultMap"&gt;	&lt;id property="uid" column="u_id"/&gt;    &lt;result property="uname" column="u_name"/&gt;&lt;/resultMap&gt;一些配置方面优化  conf.xml对于标签的顺序是有规定的，以下是当顺序出错时提示的格式信息： (properties?,settings?,typeAliases?,typeHandlers?,objectFactory?,objectWrapperFactory?,reflectorFactory?,plugins?,environments?,databaseIdProvider?,mappers?)提取分离数据库配置信息可以把核心配置文件中的数据库相关信息提取出来，放入一个.properties文件中例如db.properties文件@db.propertiesdriver=com.mysql.jdbc.Driverurl=jdbc:mysql://localhost:3306/mybatisdbname=rootpassword=123在conf.xml中引入&lt;properties resource="db.properties"/&gt;&lt;environments default="development"&gt;        &lt;environment id="development"&gt;            &lt;transactionManager type="JDBC" /&gt;            &lt;!-- 配置数据库连接信息 --&gt;            &lt;dataSource type="POOLED"&gt;                &lt;property name="driver" value="${driver}" /&gt;                &lt;property name="url" value="${url}" /&gt;                &lt;property name="username" value="${name}" /&gt;                &lt;property name="password" value="${password}" /&gt;            &lt;/dataSource&gt;        &lt;/environment&gt;    &lt;/environments&gt;  关于在实体类映射文件中使用的sql #{属性名}与${属性名}的区别，#{}方式比较安全，可以防止sql注入，估计调的是peraparedStatement，第二种可以被sql注入，估计是Statement。]]></content>
      <categories>
        
      </categories>
      <tags>
        
          <tag> MyBatis </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[MyBatis多表关联以及调用存储过程]]></title>
      <url>/2017/05/12/MyBatisMutiTable/</url>
      <content type="text"><![CDATA[MyBatis关联表  参考 http://www.cnblogs.com/xdp-gacl/p/4264440.html一对一MyBatis中在关联映射配置文件中使用association标签来解决一对一的关联查询建表语句create table people(p_id int primary key auto_increment,p_name varchar(50),p_info varchar(50));create table idcard(ic_id int primary key auto_increment,p_id int,ic_number varchar(50),foreign key(p_id) references people(p_id));insert into people values(null,'aaa','no describe');insert into people values(null,'bbb','no describe');insert into people values(null,'ccc','no describe');insert into idcard values(null,1,'678686');insert into idcard values(null,2,'6789792');insert into idcard values(null,3,'9635224');实体类people包含3个属性p_id,p_name,p_info和一个toString方法@Idcard.javapublic class Idcard {	private int ic_id;	private String ic_number;	private People people;		public int getIc_id() {		return ic_id;	}	public void setIc_id(int icId) {		ic_id = icId;	}	public String getIc_number() {		return ic_number;	}	public void setIc_number(String icNumber) {		ic_number = icNumber;	}	public People getPeople() {		return people;	}	public void setPeople(People people) {		this.people = people;	}	@Override	public String toString() {		return "Idcard [ic_id=" + ic_id + ", ic_number=" + ic_number				+ ", people=" + people + "]";	}}映射文件@idcardMapper.xml	&lt;select id="getICard" parameterType="int" resultMap="IdcardResultMap"&gt;         select * from idcard i,people p where i.p_id=p.p_id and i.ic_id=#{ic_id}     &lt;/select&gt;     &lt;resultMap type="com.pad.entity.Idcard" id="IdcardResultMap"&gt;     	&lt;id property="ic_id" column="ic_id"/&gt;     	&lt;result property="ic_number" column="ic_number"/&gt;     	&lt;association property="people" javaType="com.pad.entity.People"&gt;     		&lt;id property="p_id" column="p_id"/&gt;     		&lt;result property="p_name" column="p_name"/&gt;     		&lt;result property="p_info" column="p_info"/&gt;     	&lt;/association&gt;     &lt;/resultMap&gt;在conf.xml中引入关联&lt;mapper resource="com/pad/mapping/idcardMapper.xml"/&gt;测试代码@Testpublic void testMuti(){	String statement="com.pad.mapping.idcardMapper.getICard";    //查询ic_id为1的数据,这里session在@Before中已经获取	Idcard ic=session.selectOne(statement, 1);	System.out.println(ic);}以上是嵌套结果方式，另一种为嵌套查询，是分别用2个select查询后进行关联。关联xml如下： 	&lt;select id="getICard2" parameterType="int" resultMap="IdcardResultMap2"&gt;         select * from idcard i,people p where i.p_id=p.p_id and i.ic_id=#{ic_id}     &lt;/select&gt;     &lt;select id="getPeople2" parameterType="int" resultType="com.pad.entity.People"&gt;         select p_id,p_name,p_info from people where p_id=#{p_id}     &lt;/select&gt;     &lt;resultMap type="com.pad.entity.Idcard" id="IdcardResultMap2"&gt;     	&lt;id property="ic_id" column="ic_id"/&gt;     	&lt;result property="ic_number" column="ic_number"/&gt;     	&lt;association property="people" column="p_id" select="getPeople2" /&gt;     &lt;/resultMap&gt;一对多关联MyBatis中使用collection标签进行一对多的关联，ofType属性指的是元素的对象类型。实体类People中加入一个属性List&lt;Items&gt; items.	&lt;select id="getItems" parameterType="int" resultMap="itemsResultMap"&gt;         select * from items,people where  items.p_id=people.p_id and people.p_id=#{p_id};     &lt;/select&gt;     &lt;resultMap type="com.pad.entity.People" id="itemsResultMap"&gt;     	&lt;id property="p_id" column="p_id"/&gt;     	&lt;result property="p_name" column="p_name"/&gt;     	&lt;result property="p_info" column="p_info"/&gt;     	&lt;collection property="items" ofType="com.pad.entity.Items"&gt;     		&lt;id property="it_id" column="it_id"/&gt;     		&lt;result property="it_name" column="it_name"/&gt;     		&lt;result property="it_info" column="it_info"/&gt;     	&lt;/collection&gt;     &lt;/resultMap&gt;嵌套查询方式也是类似配置&lt;!--方式二：嵌套查询：通过执行另外一个SQL映射语句来返回预期的复杂类型--&gt; 	&lt;select id="getItems2" parameterType="int" resultMap="itemsResultMap2"&gt;         select * from people where p_id=#{p_id};     &lt;/select&gt;     &lt;select id="getItem2" parameterType="int" resultType="com.pad.entity.Items"&gt;         select * from items where p_id=#{p_id};     &lt;/select&gt;          &lt;resultMap type="com.pad.entity.People" id="itemsResultMap2"&gt;     	&lt;id property="p_id" column="p_id"/&gt;     	&lt;result property="p_name" column="p_name"/&gt;     	&lt;result property="p_info" column="p_info"/&gt;     	&lt;collection property="items" column="p_id" ofType="com.pad.entity.Items" select="getItem2"/&gt;     &lt;/resultMap&gt;  有一点需要注意的是使用了resultMap之后再resultMap中未声明的属性将不会获取，无论字段名和属性名是否一致。使用注解方式进行关联  http://blog.csdn.net/luanlouis/article/details/35780175注解中使用@Result进行达到xml中的resultMap效果，使用@One表示一方，使用@Many表示多方。public interface StudentMapper  {      @Select("SELECT ADDR_ID AS ADDRID, STREET, CITY, STATE, ZIP, COUNTRY              FROM ADDRESSES WHERE ADDR_ID=#{id}")      Address findAddressById(int id);      @Select("SELECT * FROM STUDENTS WHERE STUD_ID=#{studId} ")      @Results(      {          @Result(id = true, column = "stud_id", property = "studId"),          @Result(column = "name", property = "name"),          @Result(column = "email", property = "email"),          @Result(property = "address", column = "addr_id",          one = @One(select = "com.mybatis3.mappers.StudentMapper.          findAddressById"))      })      Student selectStudentWithAddress(int studId);  }  public interface TutorMapper  {      @Select("select addr_id as addrId, street, city, state, zip,              country from addresses where addr_id=#{id}")      Address findAddressById(int id);      @Select("select * from courses where tutor_id=#{tutorId}")      @Results(      {          @Result(id = true, column = "course_id", property = "courseId"),          @Result(column = "name", property = "name"),          @Result(column = "description", property = "description"),          @Result(column = "start_date" property = "startDate"),          @Result(column = "end_date" property = "endDate")      })      List&lt;Course&gt; findCoursesByTutorId(int tutorId);      @Select("SELECT tutor_id, name as tutor_name, email, addr_id              FROM tutors where tutor_id=#{tutorId}")      @Results(      {          @Result(id = true, column = "tutor_id", property = "tutorId"),          @Result(column = "tutor_name", property = "name"),          @Result(column = "email", property = "email"),          @Result(property = "address", column = "addr_id",          one = @One(select = " com.mybatis3.          mappers.TutorMapper.findAddressById")),          @Result(property = "courses", column = "tutor_id",          many = @Many(select = "com.mybatis3.mappers.TutorMapper.          findCoursesByTutorId"))      })      Tutor findTutorById(int tutorId);  }  调用存储过程调用存储过程的方式对于使用时和调用select一样，主要是映射文件方面的配置,statementType=”CALLABLE”，如果没有对应的parameterMap则需要加上对应的resultType.其实可以理解为一个特殊的select.相关配置：&lt;select id="getUserCount" parameterMap="getUserCountMap" statementType="CALLABLE"&gt;    CALL mybatis.ges_user_count(?,?)&lt;/select&gt;&lt;!--如果有参数，参数的设置，如果没有则需要在select标签中加上resultType--&gt;&lt;parameterMap type="java.util.Map" id="getUserCountMap"&gt;    &lt;parameter property="sexid" mode="IN" jdbcType="INTEGER"/&gt;    &lt;parameter property="usercount" mode="OUT" jdbcType="INTEGER"/&gt;&lt;/parameterMap&gt;]]></content>
      <categories>
        
      </categories>
      <tags>
        
          <tag> MyBatis </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[HQL以及N+1和缓存问题]]></title>
      <url>/2017/05/10/HQL/</url>
      <content type="text"><![CDATA[HQL以及N+1和缓存问题Hibernate Query Language，Hibernate查询语言是面向对象的查询语言，对java类与熟悉大小写敏感 对关键字不区分大小写Query接口  Query接口定义有执行查询的方法  Query接口支持方法链编程风格，使得程序代码更为简洁list()方法返回的结果为java.util.listfrom子句1.HQL语句最简形式2.from指定了HQL语句查询主体-持久化类及其属性from 类名String hql="from Student"List result=session.createQuery(hql).list();1.不需要引用全限定名，直接使用类名2.由于auto-importselect子句1.select子句中未指定返回数据类型，默认为Object[]select子句中指定new listString hql="select new list(u.name,u.tel) from User u";List&lt;List&gt; lists=session.createQuery(hql);select子句中指定new MapString hql="select new map(u.name,u.tel) from User u";List&lt;Map&gt; maps=session.createQuery(hql);获取时是键值时索引，有别名则是别名  还可以指定自定义类where子句比较运算1.=、&lt;&gt;、&lt;、&gt;、&gt;=、&lt;=2.null值判断-is[not] null范围[not] in、between .. and ..集合运算is [not] empty  大体上和sql一样,只是表替换成了对象，字段名换成了对象的属性，就不多赘述了。查询单个对象 uniqueResult()如果查询条件有问题返回多个则会抛出异常。链接hibernate的hql查询语句总结http://www.cnblogs.com/xiaoluo501395377/p/3376256.htmlhibernate缓存机制详细分析（N+1和一二级缓存）http://www.cnblogs.com/xiaoluo501395377/p/3377604.html一级缓存是session级别的缓存hibernate提供，二级缓存hibernate不提供，需要第三方jar包，比较契合的是ehcache]]></content>
      <categories>
        
      </categories>
      <tags>
        
          <tag> Hibernate </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Hibernate映射]]></title>
      <url>/2017/05/09/Hibernate%E5%A4%9A%E8%A1%A8%E6%98%A0%E5%B0%84/</url>
      <content type="text"><![CDATA[Hibernate映射1-1，1-N，N-N一般由外键所在的实体类去维护注解方式1-1映射@Person.javapackage com.pad.entity;import javax.persistence.Column;import javax.persistence.Entity;import javax.persistence.GeneratedValue;import javax.persistence.GenerationType;import javax.persistence.Id;import javax.persistence.OneToOne;import javax.persistence.Table;@Entity@Table(name="t_person")public class Person {	private int pid;	private String name;	private boolean sex;	private IdCard idcard;		@Id	@GeneratedValue(strategy=GenerationType.AUTO)	@Column(name="p_id")	public int getPid() {		return pid;	}	public void setPid(int pid) {		this.pid = pid;	}		@Column(name="p_name")	public String getName() {		return name;	}	public void setName(String name) {		this.name = name;	}	@Column(name="p_sex")	public boolean isSex() {		return sex;	}	public void setSex(boolean sex) {		this.sex = sex;	}	//表示由IdCard中的p进行维护	@OneToOne(mappedBy="p")	public IdCard getIdcard() {		return idcard;	}	public void setIdcard(IdCard idcard) {		this.idcard = idcard;	}	}@IdCard.javapackage com.pad.entity;import java.util.Date;import javax.persistence.Column;import javax.persistence.Entity;import javax.persistence.GeneratedValue;import javax.persistence.GenerationType;import javax.persistence.Id;import javax.persistence.JoinColumn;import javax.persistence.OneToOne;@Entity(name="idcard")public class IdCard {	private int C_Id;	private Date birth;	private Person p;	@Id	@GeneratedValue(strategy=GenerationType.AUTO)	public int getC_Id() {		return C_Id;	}	public void setC_Id(int cId) {		C_Id = cId;	}	@Column(name="birth")	public Date getBirth() {		return birth;	}    	public void setBirth(Date birth) {		this.birth = birth;	}	//维护方，使用外键p_id进行关联	@OneToOne	@JoinColumn(name="p_id")	public Person getP() {		return p;	}	public void setP(Person p) {		this.p = p;	}	}测试代码@testHibernate.javaimport java.util.Date;import org.hibernate.Session;import org.hibernate.SessionFactory;import org.hibernate.Transaction;import org.hibernate.cfg.Configuration;import org.hibernate.service.ServiceRegistry;import org.hibernate.service.ServiceRegistryBuilder;import org.junit.After;import org.junit.Before;import org.junit.Test;import com.pad.entity.IdCard;import com.pad.entity.Person;public class testHibernate {	private SessionFactory sessionFactory;	private Session session;	private Transaction transaction;			@SuppressWarnings("deprecation")	@Before	public void init(){		Configuration config=new Configuration().configure();		ServiceRegistry serviceRegistry=new ServiceRegistryBuilder()			.applySettings(config.getProperties()).buildServiceRegistry();		sessionFactory=config.buildSessionFactory(serviceRegistry);		session=sessionFactory.openSession();		transaction=session.beginTransaction();	}		@After	public void destory(){		transaction.commit();		session.close();		sessionFactory.close();	}		@Test public void testOTO(){		Person p=new Person();		p=(Person)session.load(Person.class, 2);//第二个参数为person表中的主键		System.out.println(p.getIdcard().getBirth());	}}1-N@Course.javapackage com.pad.entity;import java.util.Set;import javax.persistence.Entity;import javax.persistence.GeneratedValue;import javax.persistence.GenerationType;import javax.persistence.Id;import javax.persistence.OneToMany;@Entity(name="course")public class Course {	private int c_id;	private String c_name;	private Set&lt;Student&gt; stu;		@Id	@GeneratedValue(strategy=GenerationType.AUTO)	public int getC_id() {		return c_id;	}	public void setC_id(int cId) {		c_id = cId;	}	public String getC_name() {		return c_name;	}	public void setC_name(String cName) {		c_name = cName;	}	@OneToMany(mappedBy="course")	public Set&lt;Student&gt; getStu() {		return stu;	}	public void setStu(Set&lt;Student&gt; stu) {		this.stu = stu;	}}@Student.javapackage com.pad.entity;import javax.persistence.Entity;import javax.persistence.GeneratedValue;import javax.persistence.GenerationType;import javax.persistence.Id;import javax.persistence.JoinColumn;import javax.persistence.ManyToOne;@Entity(name="student")public class Student {	private int s_id;	private String s_name;	private int s_age;	private Course course;		@Id	@GeneratedValue(strategy=GenerationType.AUTO)	public int getS_id() {		return s_id;	}	public void setS_id(int sId) {		s_id = sId;	}	public String getS_name() {		return s_name;	}	public void setS_name(String sName) {		s_name = sName;	}	public int getS_age() {		return s_age;	}	public void setS_age(int sAge) {		s_age = sAge;	}		@ManyToOne	@JoinColumn(name="c_id")	public Course getCourse() {		return course;	}	public void setCourse(Course course) {		this.course = course;	}	@Override	public String toString() {		return "Student [course=" + course + ", s_age=" + s_age + ", s_id="				+ s_id + ", s_name=" + s_name + "]";	}}测试代码：	//在运行下面Test之前插入数据，先运行testOTM()    //在这里如果把student放在循环之外new会造成s_id是一样的，所以多个save只是会更新第一条记录。    public void testOTM(){		Course c=new Course();		c.setC_name("1A");		session.save(c);				int count=5;		while(count--&gt;0){			Student s=new Student();			s.setCourse(c);			s.setS_name("xiaom"+count);			s.setS_age(count);			session.save(s);		}	}	@Test	public void testOTMResult(){		Course c=(Course)session.load(Course.class,1);		System.out.println(c); //当把下面for循环注释掉之后控制台输出的sql语句只select了course表字段，并没有查询student表，验证了懒加载。		for(Student s:c.getStu()){			System.out.println(s);		}	}N-N@Teacher.javapackage com.pad.entity;import java.util.Set;import javax.persistence.Entity;import javax.persistence.GeneratedValue;import javax.persistence.GenerationType;import javax.persistence.Id;import javax.persistence.JoinColumn;import javax.persistence.JoinTable;import javax.persistence.ManyToMany;@Entity(name="teacher")public class Teacher {	private int t_id;	private int t_name;	private Set&lt;Course&gt; course;		@Id	@GeneratedValue(strategy=GenerationType.AUTO)	public int getT_id() {		return t_id;	}	public void setT_id(int tId) {		t_id = tId;	}	public int getT_name() {		return t_name;	}	public void setT_name(int tName) {		t_name = tName;	}		@ManyToMany	@JoinTable(			name="t_id_c_id",			joinColumns=@JoinColumn(name="t_id"),			inverseJoinColumns=@JoinColumn(name="c_id")			)	public Set&lt;Course&gt; getCourse() {		return course;	}	public void setCourse(Set&lt;Course&gt; course) {		this.course = course;	}	}@Course.javapackage com.pad.entity;import java.util.Set;import javax.persistence.Entity;import javax.persistence.GeneratedValue;import javax.persistence.GenerationType;import javax.persistence.Id;import javax.persistence.ManyToMany;import javax.persistence.OneToMany;@Entity(name="course")public class Course {	private int c_id;	private String c_name;	private Set&lt;Student&gt; stu;	private Set&lt;Teacher&gt; t;		@Id	@GeneratedValue(strategy=GenerationType.AUTO)	public int getC_id() {		return c_id;	}	public void setC_id(int cId) {		c_id = cId;	}	public String getC_name() {		return c_name;	}	public void setC_name(String cName) {		c_name = cName;	}	@OneToMany(mappedBy="course")	public Set&lt;Student&gt; getStu() {		return stu;	}	public void setStu(Set&lt;Student&gt; stu) {		this.stu = stu;	}		@ManyToMany(mappedBy="course")	public Set&lt;Teacher&gt; getT() {		return t;	}	public void setT(Set&lt;Teacher&gt; t) {		this.t = t;	}}运行之后数据库表已经创建，这里如果不把对象创建为set，而只是普通的Teacher运行时会抛异常：     org.hibernate.AnnotationException: Illegal attempt to map a non collection as a @OneToMany, @ManyToMany or @CollectionOfElements: com.pad.entity.Course.t	at org.hibernate.cfg.annotations.CollectionBinder.getCollectionBinder(CollectionBinder.java:331)    ….hbm方式一对多 一方	&lt;!--set中设置inverse属性为true则由多方维护关系--&gt;    &lt;set name="students" table="student" inverse="true"&gt;        &lt;key column="gid"&gt;&lt;/key&gt;        &lt;one-to-many class="com.imooc.entity.Student"/&gt;    &lt;/set&gt;    inverse属性用于指定关联关系的维护，有利于优化性能。一对多 多方&lt;many-to-one name="grade" class="com.imooc.entity.Grade" column="gid"&gt;&lt;/many-to-one&gt;当cascade属性不为none时，Hibernate会自动持久化所关联对象。cascade属性的设置会带来性能上的变动，需谨慎设置            属性值      含义和作用                  all      对所有操作进行级联操作              save-update      执行保存和更新操作时进行级联操作              delete      执行删除操作时进行级联操作              none      对所有操作不进行级联操作      	&lt;!--set中设置inverse属性为true则由多方维护关系--&gt;    &lt;set name="students" table="student" inverse="true" cascade="save-update"&gt;        &lt;key column="gid"&gt;&lt;/key&gt;        &lt;one-to-many class="com.imooc.entity.Student"/&gt;    &lt;/set&gt;设置之后班级的save会级联保存学生的信息，不需要手动save学生。如果学生对应班级没有，需要级联班级，可以在学生那边增加cascade属性 cascade=”all”，这样就能级联增加班级。总结实现单向一对多：在one方的实体中添加保存many方的集合在one方的配置文件中添加&lt;one-to-many&gt;配置 #### 实现单向多对一： 在many方的实体中添加one方的引用 在many方的配置文件中添加&lt;many-to-one&gt;配置逆向生成Hibernate实体类和配置文件  Myeclipse添加数据库连接 右上角增加视图-打开数据库视图，新建连接  为工程添加hibernate 右键项目-&gt;myeclipse-&gt;add hibernate capicity-&gt;选择之前新建的数据库连接-&gt;create SessionFactory class(可以方便获取sesson)  创建包，切换到数据库视图-&gt;选中表右键-&gt;Hibernate Reverse Engineering-&gt;指定位置-&gt;选中Create POJO&lt;&gt; DB Table mapping information和java Data Object（去掉创建抽象类的勾）-&gt;选择主键生成策略-&gt;勾选2个include]]></content>
      <categories>
        
      </categories>
      <tags>
        
          <tag> Hibernate </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Hibernate基础单表]]></title>
      <url>/2017/05/08/Hibernate%E5%9F%BA%E7%A1%80%E5%8D%95%E8%A1%A8/</url>
      <content type="text"><![CDATA[HibernateORM(Object/Relationship Mapping):对象/关系映射利用面向对象思想编写的数据库应用程序最终都是把对象信息保存在关系型数据库中，于是要编写很多sql1.不同数据库使用sql语法不同2.同一个功能使用的SQL不同。HibernateHibernate是java领域的一款开元的ORM框架技术对jdbc进行了封装。业务逻辑层通过持久化层（Hibernate）操作数据库简单配置方便Hibernate使用的eclipse插件 Hibernate Tools for Eclipse PluginJBoss tools搭建步骤：  编写Hibernate配置文件  创建持久化类  创建对象-关系映射文件  通过Hibernate API编写访问数据库的代码导入Hibernate必须的jar包hibernate-release-*\lib\required导入jdbc驱动  创建java工程  导入Hibernate必须的jar包 hibernate-release-*\lib\required ，导入jdbc驱动      创建Hibernate的配置文件 如果没有代码提示功能就需要手工导入 hibernate-release-*\project\hibernate-core\src\main\resources\org\hibernate\hibernate-mapping-3.0.dtd 在src下创建hibernate添加了插件的话直接可以右键新建hibernate。     &lt;property name="connection.username"&gt;root&lt;/property&gt; &lt;property name="connection.password"&gt;&lt;/property&gt; &lt;property name="connection.driver_class"&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;!--\\\ 是简写 useUnicode防止乱码--&gt; &lt;property name="connection.url"&gt;jdbc:mysql:///hibernate?useUnicode=true&amp;amp;characterEncoding=UTF-8&lt;/property&gt; &lt;property name="dialect"&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt; &lt;!--常用的3个属性--&gt; &lt;property name="show_sql"&gt;true&lt;/property&gt; &lt;property name="format_sql"&gt;true&lt;/property&gt; &lt;property name="hbm2ddl.auto"&gt;create&lt;/property&gt;            创建持久化层    创建实体化类 @Student.java     public class Students{ 	private int id;     private String name;             public int getId() {         return id;     }     public void setId(int id) {         this.id = id;     }     public String getName() {         return name;     }     public void setName(String name) {         this.name = name;     } }        还可以使用注解的方式进行关系映射，这样就不需要创建关系映射文件，可以跳过第5步，使用注解方式关联的实体类如下    @Person.java     package com.pad.entity; import javax.persistence.Column; import javax.persistence.Entity; import javax.persistence.GeneratedValue; import javax.persistence.GenerationType; import javax.persistence.Id; import javax.persistence.Table; @Entity @Table(name="t_person") public class Person {     private int id;     private String name;     private boolean sex;     @Id     @GeneratedValue(strategy=GenerationType.AUTO)     @Column(name="p_id")     public int getId() {         return id;     }     public void setId(int id) {         this.id = id;     }     @Column(name="p_name")     public String getName() {         return name;     }     public void setName(String name) {         this.name = name;     }     @Column(name="p_sex")     public boolean isSex() {         return sex;     }     public void setSex(boolean sex) {         this.sex = sex;     } }        创建对象关系映射文件     &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;!DOCTYPE hibernate-mapping PUBLIC      "-//Hibernate/Hibernate Mapping DTD 3.0//EN"     "http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"&gt; &lt;hibernate-mapping package="com.pad.entity"&gt;     &lt;class name="Student" table="t_student"&gt;         &lt;id name="id"&gt;             &lt;!-- 交由数据库处理。如果有设置自增则自增，否则由java代码指定 --&gt;             &lt;generator class="native" /&gt;             &lt;!-- 由代码指定主键 --&gt;             &lt;!--&lt;generator class="assigned"&gt;  --&gt;             &lt;!--强制为自增--&gt;             &lt;!--  &lt;generator class="identity"&gt;  --&gt;             &lt;!--指定序列,oracle，db2上--&gt;             &lt;!--  &lt;generator class="sequence"&gt;  --&gt;             &lt;!--随机生成16进制的唯一ID--&gt;             &lt;!-- &lt;generator class="hexuid"&gt;  --&gt;         &lt;/id&gt;         &lt;property name="name"&gt;&lt;/property&gt;         &lt;property name="age"&gt;&lt;/property&gt;     &lt;/class&gt; &lt;/hibernate-mapping&gt;        在hibernate.cfg.xml中包含如果使用xml配置关联则	&lt;mapping resource="Student.hbm.xml"/&gt;如果使用注解方式则为	&lt;mapping class="com.pad.entity.Person"/&gt;  访问数据     Configuration config=new Configuration().configure(); //创建配置对象 ServiceRegistry serviceRegistry=new ServiceRegistryBuilder().applySettings(config.getProperties()).buildServiceRegistry();//创建服务注册对象 sessionFactory=config.buldSessionFactory(serviceRegistry);//创建会话工厂对象 session=sessionFactory.openSesson();//打开会话 transaction=session.beginTransaction();//打开事务        创建测试用例@testHibernate.java     import org.hibernate.Session; import org.hibernate.SessionFactory; import org.hibernate.Transaction; import org.hibernate.cfg.Configuration; import org.hibernate.service.ServiceRegistry; import org.hibernate.service.ServiceRegistryBuilder; import org.junit.After; import org.junit.Before; import org.junit.Test; import com.pad.entity.Student; public class testHibernate {     private SessionFactory sessionFactory;     private Session session;     private Transaction transaction;     @Before     public void init(){         Configuration config=new Configuration().configure();         ServiceRegistry serviceRegistry=new ServiceRegistryBuilder().applySettings(config.getProperties())         	.buildServiceRegistry();         sessionFactory=config.buildSessionFactory(serviceRegistry);         session=sessionFactory.openSession();         transaction=session.beginTransaction();     }     @After     public void destory(){         transaction.commit();         session.close();         sessionFactory.close();     }     @Test     public void testHiber(){         Student stu=new Student();         stu.setAge(12);         stu.setName("aaa");         session.save(stu);     } }        Hibernate执行流程  hibernate.cfg.xml常用配置  show_sql 是否把Hibernate运行时将sql语句输出到控制台  format_sql 对输出到控制台的sql是否进行排版，便于阅读  auto 可以帮助由java代码生成数据库脚本，进而生成具体表结构。 属性有create（如果原来表存在则先删除）|update（在原有表数据上更新）|create-drop（先创建在删除）|validate（对原表结构验证，如果现有表结构与原来表结构不同则不会创建表结构，不执行）  default_schema 默认数据库  dialect 数据库方言，Hibernate可以对特殊数据库进行优化。session（会话）是一个操作数据库的对象session与connection，是多对一关系，每个session都有一个与之对应的connection，一个connection不同时刻可以供多个session使用。把对象保存在关系数据库中需要调用session的各种方法，如：save(),update(),delete(),createQuery()等。      获取session    1) openSession    2)getCurrentSession    如果使用getCurrentSession需要在hibernate.cfg.xml文件中配置如果是本地事务（jdbc事务）    &lt;property name="hibernate.current_session_context_class"&gt;thread&lt;/property&gt;        如果是全局事务（jta事务）    &lt;property name="hibernate.current_session_context_class"&gt;jta&lt;/property&gt;        两种方式获取session的区别：      1. 使用getCurrentSession在事务提交或者回滚之后会自动关闭，而openSession需要手动关闭。如果使用openSession而没有手动关闭，多次之后会导致连接池溢出。      2. openSession每次创建新的session对象，getCurrentSession使用现有的session对象。  transaction（事务）hibernate对数据库的操作都是封装在事务中，并默认是非自动提交的方式，所以session保存对象时，如果不开启事务，并且手动提交事务，对象并不会真保存进数据库。如果想像jdbc一样自动提交事务，必须调用session对象的doWork()方法，获取jdbc的connection后，设置为自动提交事务模式。（不推荐）session.doWork(new Work(){	@Override    public void execute(Connection connection)throws SQLException{    	connection.setAutoCommit(true);    }})；session.save(s);session.flush();//没有这句也不会提交hbm配置文件常用设置&lt;hibernate-mapping	schema="schemaName"    catalog="catalogName"    default-cascade="cascade_style" //级联风格    default-access="field|property|ClassName" //访问策略    default-lazy="true|false" //加载策略    package="packagename"    /&gt;  &lt;class  	name="ClassName"    table="tableName"    batch-size="N"   //一次抓取N条记录    where="condition"	//抓取条件    entity-name="EntityName"  //同一个类映射多张表    /&gt;    &lt;id    	name="propertyName"        type="typename"	//数据类型        column="column_name" //映射成字段名        length="length"&gt;	//长度        &lt;generator class="generatorClass"/&gt; //主键生成策略    &lt;/id&gt;单表映射单一主键  assigned由java应用程序负责生成（手工赋值）  native 由底层数据库自动生成标识符，如果是MySQL就是increment,如果是Oracle就是sequence，等等。&lt;generator class="native" /&gt;基本类型&lt;property name="birthday" type="timestamp"&gt;&lt;/property&gt;对象类型@Testpublic void testWriteBlob()throwsException{ Student s=new Students(1,"ss","m",new Date(),"wudang"); File f=new File("d:"+File.separator+"filenamebak.jpg"); InputStream input=new FileInputStream(f); Blob image=Hibernate.getLobCreator(session).createBlob(input,input.available()); s.setPicture(image);session.save(s);}@Testpublic void testReadBlob() throws Exception{	Student s=(Student)session.get(Students.class,1);    //获得Blob对象    Blob image=s.getPicture();    InputStream input=image.getBinaryStream();    File f=new File("d:"+File.separator+"filename.jpg");    OutputStream output=new FileOutputStream(f);    //创建缓冲区    byte[] buff=new byte[input.available()];    inpput.read(buff);    output.write(buff);    input.close();    output.close(); }组件属性实体类中的某个属性属于用户自定义的类的对象。&lt;component name="address" class="com.pad.entity.Address"&gt;&lt;property name="postcode" column="POSTCODE"/&gt;&lt;property name="phone" column="PHONE"/&gt;&lt;property name="address" column="ADDRESS"/&gt;&lt;/component&gt;测试用例没有什么变化单表CRUD实例  save  update  delete  get/loadget/load区别      get在调用后立即向数据库发出sql，返回持久化对象 load方法会在调用后返回一个代理对象，该对象只是保存了实体类的id，直到使用对象的非主键属性时才会发出sql        查询数据库中不存在的数据时，get返回null， load方法抛出异常org.hibernate.ObjectNotFoundException  Hibernate持久化对象的三种状态http://blog.csdn.net/lovesummerforever/article/details/19171571Hibernate注解相关  Hibernate4注解方法(全) http://blog.csdn.net/houfeng30920/article/details/51439958  hibernate annotation注解方式来处理映射关系 http://www.cnblogs.com/xiaoluo501395377/p/3374955.html]]></content>
      <categories>
        
      </categories>
      <tags>
        
          <tag> Hibernate </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Struts2与Ajax交互]]></title>
      <url>/2017/05/05/Struts2%E4%B8%8EAjax%E4%BA%A4%E4%BA%92/</url>
      <content type="text"><![CDATA[Struts2和Ajax交互1.原生方法（直接调用response输出）原生方法就是直接使用ServletActionContext获取response进行操作。但是这种方式不被推荐。@index.jsp//引入jqury&lt;script type="text/javascript" src="http://ajax.aspnetcdn.com/ajax/jQuery/jquery-3.2.0.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt;window.onload=function(){    var actionUrl="testAjax"    $.ajax({  		tyep="post",		url:actionUrl,        data:{"name","pad"},        success:function(data){        	alert(data);        }    });}&lt;/script&gt;@TestAajaxActionpublic class AjaxTestAction extends ActionSupport{	private String name;	public void testAjax(){		PrintWriter out=null;		try{        	//通过ServletActionContext获取Response，之后获取PrintWriter			out=ServletActionContext.getResponse().getWriter();		}catch(IOException e){			e.printStackTrace();		}				out.println("I have got your message "+name);	}		public String getName() {		return name;	}	public void setName(String name) {		this.name = name;	}	}@struts.xml&lt;action name="testAjax" method="testAjax" class="com.pad.action.AjaxTestAction"/&gt;   2.采用stream形式与ajax交互&lt;action name="testStream" class="com.pad.action.AjaxTestAction" method="testAjaxStream"&gt;   		&lt;result type="stream"&gt;   			&lt;param name="inputName"&gt;result&lt;/param&gt;   		&lt;/result&gt;   	&lt;/action&gt;public class AjaxTestAction extends ActionSupport{	private String name;	private InputStream input;    	public String testAjaxStream()throws Exception{		String tip="It`s ok to use it.";		if("lalal".equals(name)){			tip="UserName has been used.";		}				input=new ByteArrayInputStream(tip.getBytes());		return "success";	}	public InputStream getResult(){		return input;	}    	public String getName() {		return name;	}	public void setName(String name) {		this.name = name;	}}3.使用Struts2提供的jar包Struts2+ajax+json网上找资料发现很多需要使用jar包struts2-json-plugin-2.5.2.jar，但是去除之后发现并不影响使用，很奇怪。也许是在xml中的json-default中已经有处理（不从json-default继承后tomcat启动加载struts.xml失败）。@struts.xml &lt;package name="json" extends="struts-default,json-default"&gt; 	&lt;action name="json" class="com.pad.action.AjaxTestAction" method="testAjaxSJ"&gt; 		&lt;result type="json"&gt; 			&lt;param name="root"&gt;dataMap&lt;/param&gt; 		&lt;/result&gt; 	&lt;/action&gt; &lt;/package&gt;@AjaxTestAction public class AjaxTestAction extends ActionSupport{	private Map&lt;String,Object&gt; dataMap;    public String testAjaxSJ(){		List&lt;String&gt; list=new ArrayList&lt;String&gt;();		list.add("abc1");		list.add("abc2");		list.add("abc3");		list.add("abc4");		list.add("abc5");				dataMap=new HashMap&lt;String,Object&gt;();		dataMap.put("list", list);        		return SUCCESS;	}		public Map&lt;String, Object&gt; getDataMap() {		return dataMap;	}}直接访问后页面返回： {"list":["abc1","abc2","abc3","abc4","abc5"]}]]></content>
      <categories>
        
      </categories>
      <tags>
        
          <tag> Struts2 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Struts2总结笔记]]></title>
      <url>/2017/05/04/LearningStruts2/</url>
      <content type="text"><![CDATA[Struts2学习笔记struts1是世界上第一个mvc框架，struts2不是一个全新的框架，因此稳定性、性能等各个方面都有很好的保证，同时吸收了struts1和webwork两者的优势。环境要求  servlet api 2.4  jsp api 2.0  java 5搭建步骤1.下载相关jar包	struts.apache.org/2.创建web项目	引入相关jar包- commons-fileupload-xxx.jar- commons-io-xx.jar- commons-langxxx.jar- commons-logging-xxx.jar- freemarkes-xxx.jar	（模板引擎，基于模板生成输出的通用工具）- ognl-xxx.jar	（可以理解为一个el表达式）- struts2-core-xxx.jar- xwork-core-xx.jar (struts2有些类是关联xwork的)- javassist-xxx.jar (可以理解为解析java类文件的包)3.创建完善配置文件	配置web.xml    增加一个过滤器      &lt;filter&gt;  	  &lt;filter-name&gt;struts2&lt;/filter-name&gt;  	  &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt;   &lt;/filter&gt;        &lt;filter-mapping&gt;  	  &lt;filter-name&gt;struts2&lt;/filter-name&gt;	  &lt;url-pattern&gt;/*&lt;/url-pattern&gt;  &lt;/filter-mapping&gt;在src中创建struts.xml文件（在struts-2.5.10.1\src\apps\rest-showcase\src\main\resources中有示例）&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE struts PUBLIC "-//Apache Software Foundation//DTD Struts Configuration 2.3//EN""http://struts.apache.org/dtds/struts-2.3.dtd"&gt;&lt;struts&gt;    &lt;package name="default" namespace="/" extends="struts-default"&gt;    	&lt;action name="helloworld" class="com.xxx.xxx.类名"&gt;        	&lt;result &gt;/result.jsp&lt;/result&gt;        &lt;/action&gt;    &lt;/package&gt;&lt;/struts&gt;4.创建Action并测试启动创建class继承ActionSupport(也可以不继承，如果action标签中未指定class属性则默认使用ActionSupport类)import com.opensymphony.xwork2.ActionSupport;public class HellowrodAction extends ActionSupport{	@Override    	public String execute() throws Exception{    		system.out.println("执行");        	return SUCESS;//返回的string是视图的路径    	}}  myeclipse可以直接右键项目-&gt;myeclipse-&gt;add Struts Cpibilities 添加struts2的工作原理和执行流程首先HttpServletRequest请求经过一些过滤器（ActionContextCleanup、OtherFilters(SiteMesh,etc)、FilterDispatcher(struts2.1.3之后变为StrutsPrepareAndExcuteFiler)）,到达ActionMapper,如果ActionMapper决定请求是否需要请求一个action，则由struts的核心控制器（图中第三层）将控制权委派给ActionProxy,ActionProxy通过ConfigureManager加载核心控制文件Struts.xml进行配置找到需要调用的action，如果找到之后ActionProxy创建一个ActionInvocation实例（实例中包含拦截器，Action，Result）之后开始进行拦截器的执行，拦截器1，拦截器2，拦截器3…，之后执行Action，得到结果Result，获取相应视图Template（jsp，freemarker等），之后反序执行拦截器，最后HttpServletResponse响应客户端请求。struts.xml中包含内容：1.全局熟悉2.用户请求和响应Action之间的对应关系3.Action可能用到的参数和返回结果4.各种拦截器的配置&lt;!--引用其他struts.xml--&gt;&lt;include file="struts-default.xml"&gt;&lt;/include&gt;package提供了将多个Action组织为一个模块的方式package的名字必须是唯一的package可以扩展,当package扩展自另一个package时,该package会在本身配置的基础上加入扩展的package的配置,父package必须在子package前配置name：package名称extends：继承的父package名称abstract：设置package的属性为抽象， 抽象的package不能定义action 值true：falsenamespace:定义package命名空间，该命名空间影响到url的地址，例如此命名空间为/testname访问的地址为http:xxx:8080/proname/test/xx.action定义拦截器&lt;interceptors&gt;	&lt;interceptor name="timer" class="classpath1"&gt;&lt;/interceptor&gt;	&lt;interceptor name="logger" class="classpath2"&gt;&lt;/interceptor&gt;    &lt;!--拦截器栈--&gt;    	&lt;interceptor-stack name="timer" class="classpath"&gt;            &lt;interceptor-ref name="timer" &gt;&lt;/interceptor-ref&gt;        	&lt;interceptor-ref name="logger" &gt;&lt;/interceptor-ref&gt;        &lt;/interceptor-stack&gt;&lt;/interceptors&gt;&lt;action name="" class=""&gt; 	&lt;interceptor-ref name="timer"&gt;&lt;/interceptor-ref&gt;    &lt;result name="success" type="dispatcher"&gt;/talk.jsp&lt;/result&gt;    &lt;!--name：对应get/set--&gt;	&lt;param name="url"&gt;http://www.sina.com&lt;/param&gt;&lt;/action&gt;struts.properties放在struts.xml相同目录1.struts2框架的全局属性文件，自动加载。2.该文件包含很多key-value键值对。3.该文件完全可以配置在struts.xml中，使用constant元素。Action搜索顺序http://localhost:8080/struts2/path1/path2/path3/xxx.action第一步：判断package是否存在，如path1/path2/path3第二步： 存在：判断action是否存在，如果不存在则去默认的namespace的package里面寻找action      	不存在：检查上一级路径的package是否存在（直到默认namespace）重复第一步。第三步：如果没有则报错。动态方法调用：解决一个action对应多个请求，防止action过多。1.method属性在struts.xml中的action标签设置    &lt;action name="addAction" method="add" class="xxx.xx.xx"&gt;    	&lt;result&gt;xxx.jsp&lt;/result&gt;    &lt;/action&gt;2.感叹号方式(官方不推荐这种方法)    对应方法返回对应 return “add”;     &lt;action name="addAction"  class="xxx.xx.xx"&gt;    	&lt;result&gt;xxx1.jsp&lt;/result&gt;        &lt;result name="add"&gt;xxx2.jsp&lt;/result&gt;        &lt;result name="del"&gt;xxx3.jsp&lt;/result&gt;    &lt;/action&gt;        &lt;constant name="struts.enable.DynamicMethodInvocation" value="true"&gt;&lt;/constant&gt;访问方式：localhost:8080/xxx/helloworld!add.action3.通配符方式(官方推荐)    &lt;action name="addAction_*"  method="{1}" class="xxx.xx.xx"&gt;    	&lt;result&gt;{1}.jsp&lt;/result&gt;        &lt;result name="add"&gt;{1}.jsp&lt;/result&gt;        &lt;result name="del"&gt;{1}.jsp&lt;/result&gt;    &lt;/action&gt; 访问方式：localhost:8080/xxx/helloworld_add.action更加简洁，可以一个项目中只配置一个action      &lt;action name="*_*"  method="{2}" class="xxx.xx.{1}Action"&gt;    	&lt;result&gt;{2}.jsp&lt;/result&gt;   这里默认不写的话执行execute（）方法；        &lt;result name="add"&gt;{2}.jsp&lt;/result&gt;        &lt;result name="del"&gt;{2}.jsp&lt;/result&gt;      &lt;/action&gt;指定多个配置文件    &lt;include file="login1.xml"&gt;&lt;/include&gt;    &lt;include file="login2.xml"&gt;&lt;/include&gt;                 &lt;!--在每个配置文件中加入解决编码问题--&gt;        &lt;constant name="struts.i18n.encoding" value="UTF-8"&gt;&lt;/constant&gt;默认action        &lt;default-action-ref name="notfound"&gt;&lt;/default-action-ref&gt;        &lt;action name="notfound"&gt;        	&lt;result&gt;404page.jsp&lt;/result&gt;        &lt;/action&gt; 		&lt;!--struts2后缀 --&gt;        &lt;constant name="struts.action.extension" value="html"&gt;&lt;/constant&gt;  为空则去掉后缀，或者直接不设置这个属性   可配置地点：web.xml,struts.properties,struts.xml接收参数    1.使用action的属性接收    	在action中定义private属性，和表单提交name对应，实现get/set方法。    2.使用DomainModel接收    	在action中定义private的实体类，实体类中实现get/set 方法，action中实现实体类的get和set方法，在表单中name为	对象名.属性名     3.使用ModelDriven接收参数    实现ModelDriven&lt;T&gt;接口    对象需要实例化，并且用getset方法， 表单中的name则是属性名。        对于List类型from表单中的name为属性名【下标】    如果List中是对象类型则表单中未属性名[下标].属性名处理结果类型：省略name值则默认name值为successresult中带/表示绝对路径 项目起始 没有则为相对路径com.opensymphony.xwork2.Action 类中  SUCCESS	 正确执行，返回相应视图  NONE	表示正确执行，并不反悔任何视图  ERROR 表示Action执行失败，返回到错误处理视图  LOGIN Action因为用户没有登录的原因没有正确执行，将返回该登录视图，要求用户登录。  INPUT 唯一有特殊意义的，Action的执行，需要从前端界面获取参数，INPUT就是代表这个参数输入的界面，在一般应用中，会对这些参数进行验证，如果验证没有通过，将自动返回到该视图。在result中name换成input，当在action中数据类型转换错误的情况下会自动触发。第二种在action的方法中实现validate       @Override       public void validate(){        this.addFieldError("username","用户名不能为空");       }jsp页面中添加struts标签       &lt;%@ taglib prefix="s" uri="/struts-tags" %&gt;       &lt;input type="text" name="username"/&gt;&lt;s:fielderror name="username"&gt;&lt;/s:fielderror&gt;处理结果类型全局result需要在包中定义。      &lt;global-results&gt;      	&lt;result name="404page"&gt;xxx.jsp&lt;/result&gt;      &lt;/global-results&gt;            &lt;result name="add"&gt;      	&lt;param name="location"&gt;/$(#requst.path).jsp&lt;/param&gt;      &lt;/result&gt;  这里为ognl表达式 表示从request中获取path属性值同requst.getAttribute(“path”).  result的type属性  chain:将action和另一个action链接起来，  dispatcher  redirect	  redirectAction  stream  流  plainText  freemarker拦截器的执行过程是一个递归的过程 从ActionProxy出来后先依次执行intercpt1，2，3执行Action之后得到result到template（jsp，freemarker…）又执行 3 ，2 ，1 intercpt，之后给HttpServletResponse,响应客户端。自定义拦截器实现Interceptor接口void init()void destroy()String intercept(ActionInvocation ai)throws Exception;- 实现拦截功能- 利用ActionInvocation参数获取Action状态- 返回result字符串作为逻辑视图继承AbstractInterceptor类  提供了init()和destroy()方法的空实现。  只需要实现intercept方法即可实际开发中一般继承AbstractInterceptor类  创建拦截器    public class TimerInterceptor extends AbstarctInterceptor{ @Override public String intercept(ActionInvocation invocation) throw Exception{ long start=System.currentTimeMillis();     //执行下一个拦截器，如果已经是最后一个拦截器则执行目标action，返回结果视图 String result=invocation.invoke();     long end=System.currentTimeMillis(); System.out.println(end-start); return result; }}        配置注册拦截器 在package标签中注册拦截器     &lt;interceptors&gt; 		&lt;interceptor name="mytimer" class="xxx.xxx.xx.classname"&gt;&lt;/interceptor&gt; &lt;/interceptors&gt;        在相应action标签中引用拦截器     &lt;interceptor-ref name="mytimer"&gt;&lt;/interceptor-ref&gt;      Struts2内建拦截器  params拦截器      负责将请求参数设置为Action属性  staticParams拦截器      将配置文件中的action元素的子元素param参数设置为Action属性  servletConfig拦截器      将源于ServletAPI的各种对象注入到Action，必须实现对应接口  fileUpload拦截器      对文件上传提供支持，将文件和元数据设置对应的Action 		实际上还是使用了Commons-FileUpload  exception拦截器      捕获异常，并且将异常映射到用户自定义的错误页面      validation拦截器      调用验证框架进行数据验证。          在struts2-corexx.jar中的struts-default.xml中能找到这些拦截器  拦截器栈是拦截器的组合 defaultStack，  default-interceptor-ref name=”defaultStack”默认调用了defaultStack      关于拦截器的注意点：  在struts-default.xml中定义了一个defaultStack拦截器栈，并指定了作为默认拦截器。  只要在定义包的过程中继承struts-default包，那么defaultStack将是默认拦截器。  当为包中的某个action显式指定了某个拦截器，则默认拦截器不会起作用。（类似继承的构造函数）  拦截器栈中各个拦截器顺序很重要。  如果要使用则在之前手动调用defaultStack栈,引用方式和interceptor一样。下面是4个开发模式常用配置的简介(摘自imooc)    &lt;!-- 开启使用开发模式，详细错误提示 --&gt;    &lt;constant name="struts.devMode" value="true"/&gt;    &lt;!-- 指定每次请求到达，重新加载资源文件 --&gt;    &lt;constant name="struts.i18n.reload" value="true"/&gt;    &lt;!-- 指定每次配置文件更改后，自动重新加载 --&gt;    &lt;constant name="struts.configuration.xml.reload" value="true"/&gt;    &lt;!-- 指定XSLT Result使用样式表缓存 --&gt;    &lt;constant name="struts.xslt.nocache" value="true"/&gt;]]></content>
      <categories>
        
      </categories>
      <tags>
        
          <tag> Struts2 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[JavaSE控制流]]></title>
      <url>/2017/04/28/JavaSE%E6%8E%A7%E5%88%B6%E6%B5%81/</url>
      <content type="text"><![CDATA[JavaSE 控制流java中控制流总分为3种：分支语句，循环语句，跳转语句1.分支语句      if..else    格式为：      if(条件){ 	   语句块1  }else{     语句块2  }  //或者  if(条件1){     语句块1  }else if(条件2){     语句块2  }else{     语句块3  }        当条件成立时结果为true时执行语句块1,当结果为false时执行语句块2在java中不像c/c++或者其他语言一样可以用非0代表true，0代表false。java中if的条件结果必须要为一个boolean值，否则编译器会报错，while条件同。        switch..case    格式为：      switch(值){  	case 常量1：语句块1; 		case 常量2：语句块2;  	default:语句块3;  }        jdk1.7之前，switch中的值必须要是整型，或者可以转换为整型的值，比如：byte，short，int,char。 enum也是可以的。    jdk1.7之后可以使用字符串。    case后必须跟的是常量。    switch的使用是用switch中传入的值与case后的常量依次对比，如果匹配则执行相应case后面的语句块，语句块中通常用break关键字进行跳出，否则会执行执行case以下的所有case条件后的语句。 如果没有匹配则执行default后的语句块，default不是必须要有的。  2.循环语句  while格式为：    while(条件){    	语句块    }    //或者    do{    	语句块    }while(条件)while中的条件与if中的条件规则一样，需要是boolean，或者结果为boolean。 上一种先进行条件的判断，如果条件成立则执行语句块，循环判断与执行，直到条件为false。 do..while则是先执行语句块再判断条件是否成立，如果成立则继续执行和判断，直到条件结果为false。  for格式为：   //普通for循环    for(语句1;条件;语句2){    	语句块    }    //或者    //增强for循环    for(容器中变量类型的变量:数组或容器){    	语句    }        //死循环    for(;;){    }普通for循环一般语句1为记录的值，当i小于total的值时进行循环，语句1只在第一次执行时执行一次后面就先判断后执行语句块在执行语句2,一直到条件为false为止,如    for(int i=0;i&lt;total;i+=step){    }step为步长。这里初始化i为0,当每次循环i都会加上step的值，一直到i小于total不成立。  循环总结：一般当明确了解循环要进行的次数的时候使用for循环，当只知道一个条件不明确要执行几次的情况下使用while循环比较多。3.跳转语句跳转语句一般在循环中或者函数中配合使用，用来灵活的控制程序的执行。      break    作用：在循环中使用，当执行到break的时候跳出循环，运行循环后面的语句。        continue    作用：在循环中使用，当执行到continue的时候结束当前单次循环，进行下一次的循环。        return    作用：在函数中使用，直接跳出这个函数，如果后面有值则返回值，如果没有默认返回空。    注：break和continue后可以加标签，表示跳到标签位置，类似c/c++中的goto语句。关于在之后异常中catch中有return值而finally中也有return值，则return的是finally中的值。]]></content>
      <categories>
        
      </categories>
      <tags>
        
          <tag> JavaSE </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[JavaSE运算符]]></title>
      <url>/2017/04/27/JavaSE%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      <content type="text"><![CDATA[JavaSE运算符先上全家福，来自百度百科java中操作符分以下几类：1.算数运算符 2.关系运算符 3.逻辑运算符 4.位运算符 5.移位运算符1.算数运算符  +,- ,× ,/ ,%2.关系运算符 &lt;,&gt;,&lt;=,&gt;=,==,!=3.逻辑运算符&amp;&amp;，&amp;，||，|  &gt; 在逻辑运算符中，&amp;&amp;，||是短路运算符，当结果已经不会发生改变的情况下就不会进行完整的判断，而是直接得出结果。如 false&amp;&amp;(i++==1) 运算后i++并没有执行，因为无论后面这一部分结果为如何整个表达式的结果都为false，||操作符同理。&amp;和|则会完整执行完表达式。4.位运算符 &amp;,|,!（非）,^（异或）,~ (按位取反) &gt; 位运算是把数值转换成二进制，按位进行位运算。5.移位运算符&lt;&lt;,&gt;&gt;,&gt;&gt;&gt;  移位运算符后面是二目运算符，格式为 value»bitToMove ， value是需要操作的数值，bitToMove表示需要左移或者右移的位数，»和«是带符号的移动，»&gt;则是无符号的右移，无论是正数还是负数都会在左边补0。（»&gt;在c/c++中没有）补充：      老生常谈的自增顺序:  	value=i++ 和value=++i 这个是一直被提起的一个东西，先赋值在自增还是先自增再赋值呢？      我的理解是根据操作符号的位置 i++ i在++操作之前，所以是先使用i这个值再自增，而++i中++在前，所以先自增，自增之后的值拿来使用。    java中没有像c++那样的运算符重载  运算时会发生自动类型转换，小类型转大类型会自动转换，范围比较大的类型转成小的类型需要强制转换（可能会损失精度）。  java中没有像c/c++中的sizeof， 原因是c/c++在不同位数的机器上数据类型大小会不同，而在java中则没有这种问题。]]></content>
      <categories>
        
      </categories>
      <tags>
        
          <tag> JavaSE </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[vim命令]]></title>
      <url>/2017/04/20/VI%E5%85%A8%E9%80%89/</url>
      <content type="text"><![CDATA[Vim命令全选 ggvG1. gg到达文件最开头2. v进入visual模式3. G到达文件末尾 - 全选复制到剪切板中 ：%y+撤销以及撤销撤销u 撤销ctrl+r 恢复上一步撤销]]></content>
      <categories>
        
      </categories>
      <tags>
        
          <tag> vi </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[JavaSE数据类型]]></title>
      <url>/2017/04/20/JavaSE%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      <content type="text"><![CDATA[JavaSE数据类型在java中数据类型分为2种类型：基本类型以及引用类型  基本类型          布尔型(boolean)      字符型（char）      数值型                  浮点型(float,double)          整型（byte,short,int,long）                      引用类型          类（class）      接口（interface）      数组      java基本数据类型范围及存储空间大小：            数据类型      存储空间大小（位）      取值范围                  boolean      ——      true/false              char      16      \u0000~\uffff              byte      8      -128~127              short      16      -2^15~2^15-1              int      32      -2^31~2^31-1              long      64      -2^63~2^63-1              float      32      -2^128 ~ +2^128              double      64      -2^1024 ~ +2^1024      1.布尔型(boolean)boolean类型值只可以为true或者false，与c/c++不同不能使用非0或者0来代表true或者false。在编译器中会直接报错。2.字符型（char）在java中字符采用Unicode编码，所以每个字符型占2个字节，可以使用16进制编码进行表示如 '\u0061'.3.数值型java中各整数类型有固定的长度和范围，不受系统的影响，可以保证代码的可移植型。整型默认在计算中使用int类型，如果需要声明long类型或者byte类型需要注意类型，如long类型初始化需要在数值后加L否则会报错。浮点型常量默认为double类型（后缀为D或者d），在初始化float型时需要在数值后面加上f。整型的进制表示：	- 十进制 	- 八进制 以0开头 如	- 十六进制 以0x或者0X开头。简单类型存在栈里面变量引用类型指针存在栈里，对象存在堆里 ,类的方法存放在方法区.  类型转换：       char–&gt;    自动转换：byte–&gt;short–&gt;int–&gt;long–&gt;float–&gt;double                   强制转换：①会损失精度，产生误差，小数点以后的数字全部舍弃。②容易超过取值范围。  Ascii码   A：65    a:98     0:48  变量运算中默认使用int类型，所以将2个byte变量运算后用来初始化byte类型的值 会报错。  ※ 常量运算使用补码进行运算，对于强转的越界的变量转成补码后截断 转回原码。  例子：byte b=130;130为int类型 转换成二进制后 截断后为10000010 获得补码 转回原码为11111101  换算成十进制为-126]]></content>
      <categories>
        
      </categories>
      <tags>
        
          <tag> JavaSE </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[数据库索引存储过程视图]]></title>
      <url>/2017/04/17/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%E8%A7%86%E5%9B%BE%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E5%87%BD%E6%95%B0%E7%AD%89%E6%80%BB%E7%BB%93/</url>
      <content type="text"><![CDATA[数据库总结（索引，存储过程，函数等）      索引（index）    给某个列，或者某些列的组合，进行添加加快查询的效率的标记。    作用：索引在一定条件下可以提高查询效率，但是在某些情况下可能会拖慢运行效率    适用场景：  		- 在数据量大的情况下，数据量大于10万行+的情况下比较适用。          - 因为创建索引开销不小，所以在数据需要频繁更改的情况下不适用。比较适合在数据不经常更改的情况。          - 在字段需要经常查询或者排序的情况下          - 查询出来结果占表的15%  索引分为唯一索引，集簇索引，非集簇索引。    索引的创建和删除      --创建索引  create [unique] index index_name on table_name(colum_name[,cloumn_name2]);      --删除索引  drop index table_name.index_name;              创建索引开销比较大，所以尽量不要多建索引有索引就尽量使用，用explain plan for (sql语句)可以解析sql执行，查看索引是否使用了索引。  where关键字后的索引字段不能使用函数进行处理否则不使用索引。            视图（view）    本质上是子查询，把子查询结果看成新表。    定义：是一张虚表，数据来自于表，并可对原来数据进行操作，可能包含一些实际不存在的数据    作用：  	1.作为表使用。  	2.隐藏一些重要数据，提升数据的安全性。  	3.简化数据操作的过程。    适用场景：  		- 当数据要进行复杂操作的情况下          - 数据比较重要且需要转换    视图的创建和删除      --创建视图  create view view_name as (select 结果);      --删除视图  drop view view_name;              在视图中可以对数据进行直接插入，但是要在特定条件下，比如单表的视图，而且插入的数据受到实体表的约束影响。但是一般约定俗成，不在视图中进行数据的修改操作。            存储过程（procedure）    定义：存在数据库中，比较独立的对象。主要是对数据进行复杂的过程化处理，供外部调用。    作用：  	1.封装数据库的操作，在数据库内部进行数据处理，提高数据安全性。  	2.在数据处理比较复杂的情况下，提高程序的性能。  	3.处理过程中可以结合事务，进一步提高数据的安全性。    适用场景：  		- 供外部程序直接调用          - 数据需要进行繁杂的处理结合事务          - 不适合数据库之间的移植（geshujuku）    存储过程的创建、使用和删除      --创建存储过程  create procedure procedure_name([param1 in paramtype,[param2 out paramtpe]])  is[|as]  [delare]  begin  	[sql]  end;  /  --调用存储过程  exec procedure_name([param1[,param2]]); --sqlplus独有exec  call procedure_name([param1[,param2]]); --其他程序可以调用  --删除存储过程  drop procedure procedure_name;              在存储过程中可以进行commit和rollback，但是一般不再之中进行commit和rollback。            函数（function）    定义：定义在数据库中。主要是对数据进行复杂的过程化处理，供sql调用。    作用：  	1.封装数据库的操作，在数据库内部进行数据处理，提高数据安全性。  	2.有返回值，供sql语句调用    适用场景：  		- 需要对数据进行处理，并有结果返回，这个结果用于其他sql语句中。    函数的创建、使用和删除      --创建函数  create functio function_name([param1 paramtype,[param2 paramtpe]])  return paramtype  is[|as]  [delare]  begin  	[sql-有return]  end;  /  --调用函数  select  function_name([param1[,param2]]) from table_name; --其他程序可以调用  --删除函数  drop function function_name;            游标（cursor）    定义：只存在于函数或者存储过程中，类似于一个独特的变量    作用：  	内存中的一块区域,存放的是select 的结果。    游标的使用：  1.声明	2.打开	3.循环	4.关闭      --创建函数  create procedure function_name  is[|as]  v_record emp%rowtype;  cursor c_query is select * from emp;	--声明游标  begin  	if not c_query%ISOPEN then	--打开游标      	open c_query;      end if;      loop      	fetch c_query into v_record;	--将游标中数据存入v_record中          exit when c_query%NOTFOUND;          dbms_output.put_line(v_record.ename);          dbms_output.put_line(v_record.deptno);          dbms_output.put_line(v_record.sal);      end loop;      close c_query;	--关闭游标  end;  /            序列（sequence）  使用场景：可以实现类似mysql的auto_increment序列的创建Create 创建Sequence 序列 seqEmop 序列名称Increment by 步长Stat with 1 开始值Maxvalue  最大值Minvalue  最小值 Cycle 循环 nocycle 不循环Cache 缓存   Cache&lt;maxvalue-minvalue/increment by//一般不采用缓存Nextvalue 下一个Currval 当前值  序列一般不能清零，只能重新删除后新建。  触发器（trigger）定义:当某表中数据发生改变（insert、delete、update）时，出发相应触发器。场景：用来记录用户操作数据的日志表。也可以和序列组合使用实现自动递增。使用create sequence seq_userInfo_usid start with 1001;create or replace triggle tri_userInfo_usid --创建或替换触发器tri_userInfo_usidbefore insert on userInfo	--在向userInfo表中添加 记录之前的触发for each row	--每次影响一行出发一次begin	--触发之后执行下面的语句 select seq_userInfo_usid.nextval into :new.usid from dual;	--:new新值 :old老值end;      索引（index）    给某个列，或者某些列的组合，进行添加加快查询的效率的标记。    作用：索引在一定条件下可以提高查询效率，但是在某些情况下可能会拖慢运行效率    适用场景：  		- 在数据量大的情况下，数据量大于10万行+的情况下比较适用。          - 因为创建索引开销不小，所以在数据需要频繁更改的情况下不适用。比较适合在数据不经常更改的情况。          - 在字段需要经常查询或者排序的情况下          - 查询出来结果占表的15%  索引分为唯一索引，集簇索引，非集簇索引。    索引的创建和删除      --创建索引  create [unique] index index_name on table_name(colum_name[,cloumn_name2]);      --删除索引  drop index table_name.index_name;              创建索引开销比较大，所以尽量不要多建索引有索引就尽量使用，用explain plan for (sql语句)可以解析sql执行，查看索引是否使用了索引。  where关键字后的索引字段不能使用函数进行处理否则不使用索引。            视图（view）    本质上是子查询，把子查询结果看成新表。    定义：是一张虚表，数据来自于表，并可对原来数据进行操作，可能包含一些实际不存在的数据    作用：  	1.作为表使用。  	2.隐藏一些重要数据，提升数据的安全性。  	3.简化数据操作的过程。    适用场景：  		- 当数据要进行复杂操作的情况下          - 数据比较重要且需要转换    视图的创建和删除      --创建视图  create view view_name as (select 结果);      --删除视图  drop view view_name;              在视图中可以对数据进行直接插入，但是要在特定条件下，比如单表的视图，而且插入的数据受到实体表的约束影响。但是一般约定俗成，不在视图中进行数据的修改操作。            存储过程（procedure）    定义：存在数据库中，比较独立的对象。主要是对数据进行复杂的过程化处理，供外部调用。    作用：  	1.封装数据库的操作，在数据库内部进行数据处理，提高数据安全性。  	2.在数据处理比较复杂的情况下，提高程序的性能。  	3.处理过程中可以结合事务，进一步提高数据的安全性。    适用场景：  		- 供外部程序直接调用          - 数据需要进行繁杂的处理结合事务          - 不适合数据库之间的移植（geshujuku）    存储过程的创建、使用和删除      --创建存储过程  create procedure procedure_name([param1 in paramtype,[param2 out paramtpe]])  is[|as]  [delare]  begin  	[sql]  end;  /  --调用存储过程  exec procedure_name([param1[,param2]]); --sqlplus独有exec  call procedure_name([param1[,param2]]); --其他程序可以调用  --删除存储过程  drop procedure procedure_name;              在存储过程中可以进行commit和rollback，但是一般不再之中进行commit和rollback。            函数（function）    定义：定义在数据库中。主要是对数据进行复杂的过程化处理，供sql调用。    作用：  	1.封装数据库的操作，在数据库内部进行数据处理，提高数据安全性。  	2.有返回值，供sql语句调用    适用场景：  		- 需要对数据进行处理，并有结果返回，这个结果用于其他sql语句中。    函数的创建、使用和删除      --创建函数  create functio function_name([param1 paramtype,[param2 paramtpe]])  return paramtype  is[|as]  [delare]  begin  	[sql-有return]  end;  /  --调用函数  select  function_name([param1[,param2]]) from table_name; --其他程序可以调用  --删除函数  drop function function_name;            游标（cursor）    定义：只存在于函数或者存储过程中，类似于一个独特的变量    作用：  	内存中的一块区域,存放的是select 的结果。    游标的使用：  1.声明	2.打开	3.循环	4.关闭      --创建函数  create procedure function_name  is[|as]  v_record emp%rowtype;  cursor c_query is select * from emp;	--声明游标  begin  	if not c_query%ISOPEN then	--打开游标      	open c_query;      end if;      loop      	fetch c_query into v_record;	--将游标中数据存入v_record中          exit when c_query%NOTFOUND;          dbms_output.put_line(v_record.ename);          dbms_output.put_line(v_record.deptno);          dbms_output.put_line(v_record.sal);      end loop;      close c_query;	--关闭游标  end;  /            序列（sequence）  使用场景：可以实现类似mysql的auto_increment序列的创建Create 创建Sequence 序列 seqEmop 序列名称Increment by 步长Stat with 1 开始值Maxvalue  最大值Minvalue  最小值 Cycle 循环 nocycle 不循环Cache 缓存   Cache&lt;maxvalue-minvalue/increment by//一般不采用缓存Nextvalue 下一个Currval 当前值  序列一般不能清零，只能重新删除后新建。  触发器（trigger）定义:当某表中数据发生改变（insert、delete、update）时，出发相应触发器。场景：用来记录用户操作数据的日志表。也可以和序列组合使用实现自动递增。使用create sequence seq_userInfo_usid start with 1001;create or replace triggle tri_userInfo_usid --创建或替换触发器tri_userInfo_usidbefore insert on userInfo	--在向userInfo表中添加 记录之前的触发for each row	--每次影响一行出发一次begin	--触发之后执行下面的语句 select seq_userInfo_usid.nextval into :new.usid from dual;	--:new新值 :old老值end;]]></content>
      <categories>
        
      </categories>
      <tags>
        
          <tag> 数据库 </tag>
        
          <tag> db </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
</search>
